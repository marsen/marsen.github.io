<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marsen&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c2458ad941ad5f8ca05b12c705fd4912</icon>
  <subtitle>waiting to load</subtitle>
  <link href="https://blog.marsen.me/atom.xml" rel="self"/>
  
  <link href="https://blog.marsen.me/"/>
  <updated>2024-11-08T05:02:30.829Z</updated>
  <id>https://blog.marsen.me/</id>
  
  <author>
    <name>Marsen L.</name>
    <email>admin@marsen.me</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title> [實作筆記] 個人經歷 STAR 試寫</title>
    <link href="https://blog.marsen.me/2024/11/04/2024/star_career_feedback/"/>
    <id>https://blog.marsen.me/2024/11/04/2024/star_career_feedback/</id>
    <published>2024-11-04T01:22:58.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>STAR 是一種行之有效的行為面試方法，全名為 Situation（情境）、Task（任務）、Action（行動） 和 Result（結果）。<br>這個框架幫助應徵者組織答案，描述過去經驗時更有條理，清楚展示個人在特定情境下的行動力及成效。<br>具體來說：  </p><ul><li>Situation（情境）：描述事情發生的背景或狀況，讓聽者了解事件的前因後果。</li><li>Task（任務）：指出自己在該情境中所負責的任務或需完成的目標。</li><li>Action（行動）：詳細說明為了完成任務所採取的具體步驟和行動。</li><li>Result（結果）：描述行動的成果，最好是能量化的結果或正面的</li></ul><p>透過 STAR 方法，可以清晰地展示個人職涯解決問題的能力及帶來的正面影響。</p><h2 id="個人經歷-STAR-試寫"><a href="#個人經歷-STAR-試寫" class="headerlink" title="個人經歷 STAR 試寫"></a>個人經歷 STAR 試寫</h2><table><thead><tr><th>公司名</th><th>情境</th><th>任務</th><th>行動</th><th>結果</th></tr></thead><tbody><tr><td><strong>N 社.</strong></td><td>團隊負責開發維護跨國電商系統，面臨整合不同市場需求的挑戰。</td><td>確保開發過程的順利，協調跨團隊成員，並確保系統的本地化符合各地要求。並最需要回歸到 ONE CODE BASE</td><td>實施敏捷方法，善用分支策略，進行代碼審查和測試，引入 TDD 和 CI&#x2F;CD 流程，提升開發效率。</td><td>成功推動三個國家的服務上線，縮短開發時間 30%，獲得客戶的積極反饋，促進未來業務擴展和合作機會。在全公司中是最少發生合併衝突的開發團隊。</td></tr><tr><td><strong>N 社.</strong></td><td>產品 24&#x2F;7 監控系統的實施，以確保服務的穩定性和可用性。</td><td>設計並實施監控解決方案，確保系統在出現故障時能迅速響應，並減少停機時間。</td><td>分析系統需求並適當排序，建置監控工具，警報系統與流程。並依序修復異常</td><td>成功降低系統故障響應時間 90%，顯著提高服務可靠性，提升客戶滿意度。</td></tr><tr><td><strong>N 社 &amp; B 社產學合作</strong></td><td>與中華大學及建中學校進行產學合作項目，推動學生的實踐經驗和技術分享。</td><td>指導 B 社學生，確保項目能按時完成，達到教育和實踐的雙重目標。</td><td>舉辦技術工作坊，提供指導並進行項目評估，促進學生在實際環境中的學習。</td><td>學生在項目中獲得寶貴經驗，成功展示成果並就業，促進學校與業界的合作關係。</td></tr><tr><td><strong>N 社</strong></td><td>在 2018 年成為團隊技術領導，面對管理與技術職能切換的挑戰。</td><td>與跨部門成員重組成跨國團隊</td><td>組織讀書會工作坊，促進團隊成員達成共識，並引入相關的軟體開發工具和流程。</td><td>成功建立了一支開發團隊，如期如質的交付產品。</td></tr><tr><td><strong>C 社</strong></td><td>擔任開發工程師，負責0到1設計和開發金融相關的應用程式和服務。</td><td>建立多產品線與後台以功能符合內外用戶需求並持續改進。</td><td>利用用戶反饋進行產品迭代，並推動新功能的開發，使用敏捷開發方法提升效率。導入版本控制以解決多人協作問題。</td><td>成功推出了數個新的功能，顯著提高了用戶滿意度和產品的使用率。整體營收提昇 20 倍以上（2000%↑）</td></tr></tbody></table><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;STAR 是一種行之有效的行為面試方法，全名為 Situation（情境）、Task（任務）、Action（行動） 和 Re</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [學習筆記] TypeScript tsconfig 設定備忘錄</title>
    <link href="https://blog.marsen.me/2024/10/08/2024/typescript_tsconfig_cheat_sheet/"/>
    <id>https://blog.marsen.me/2024/10/08/2024/typescript_tsconfig_cheat_sheet/</id>
    <published>2024-10-08T15:28:35.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>tsconfig.json 文件是一個 TypeScript 專案的配置文件, 它位於根目錄中, 並定義了專案的編譯器選項。<br>提供給開發人員輕鬆配置 TypeScript 編譯器, 並確保專案的程式碼在不同的環境中始終保持一致。<br>你可以使用 <code>tsc --init</code> 指令自動產生。<br>也可以參考 Matt Pocock 的 <a href="https://www.totaltypescript.com/tsconfig-cheat-sheet">TSConfig Cheat Sheet</a></p><p>TSConfig 有上百個配置, 本文將用來重點記錄一些相關的配置  </p><h2 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h2><h3 id="2024-10-Matt-Pocock-的建議配置"><a href="#2024-10-Matt-Pocock-的建議配置" class="headerlink" title="2024&#x2F;10 Matt Pocock 的建議配置"></a>2024&#x2F;10 Matt Pocock 的建議配置</h3><p>相關說明請參考<a href="https://www.totaltypescript.com/tsconfig-cheat-sheet">原文</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/* Base Options: */</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es2022&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;resolveJsonModule&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;moduleDetection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;force&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;verbatimModuleSyntax&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strictness */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noUncheckedIndexedAccess&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noImplicitOverride&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If transpiling with TypeScript: */</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NodeNext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AND if you&#x27;re building for a library: */</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AND if you&#x27;re building for a library in a monorepo: */</span></span><br><span class="line">    <span class="attr">&quot;composite&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;declarationMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If NOT transpiling with TypeScript: */</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If your code runs in the DOM: */</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;es2022&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dom&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dom.iterable&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If your code doesn&#x27;t run in the DOM: */</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;es2022&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>預設值為 <code>false</code>, 如果只有少量的 ts 檔, 很適合設定這個<code>files</code><br>但實務上更常用 <code>include</code> 與 <code>exclude</code> 搭配,<br>兩者都可使用 wildcard , exclude 擁有較高的優先級,<br>例如下面的設定 <code>src/.test</code> 底下的檔案將不會被編譯:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/**/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/test/**/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;a_typescript_file.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;other_ts_code.ts&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Compiler-Options"><a href="#Compiler-Options" class="headerlink" title="Compiler Options"></a>Compiler Options</h3><p>這部份是 tsconfig 相關設定的主體, 有需要時來<a href="https://www.typescriptlang.org/tsconfig/#compilerOptions">這裡</a>查就好<br>下面的例子是一些常用的設定說明:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// esModuleInterop: 這個選項使 TypeScript 能夠更好地與 CommonJS 模組兼容, 允許以 ES 模組方式導入 CommonJS 模組。</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// skipLibCheck: 當設置為 true 時, TypeScript 將跳過對聲明檔案（.d.ts）的型別檢查, 可以加快編譯速度, 尤其是在大型專案中。</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// target: 指定編譯後的 JavaScript 代碼的 ECMAScript 版本。這裡設定為 ES2022, 這意味著生成的代碼將使用該版本的新特性。</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es2022&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// allowJs: 此選項允許在 TypeScript 專案中使用 JavaScript 檔案, 這對於逐步遷移到 TypeScript 的專案特別有用。</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// resolveJsonModule: 使 TypeScript 能夠導入 JSON 檔案, 並將其視為模組。</span></span><br><span class="line">    <span class="attr">&quot;resolveJsonModule&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// moduleDetection: 設置為 force 使 TypeScript 將所有檔案視為模組, 避免了使用全局變數引起的錯誤。</span></span><br><span class="line">    <span class="attr">&quot;moduleDetection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;force&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// isolatedModules: 每個檔案將被獨立編譯, 這對於使用 Babel 或其他工具的場景特別重要。</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// verbatimModuleSyntax: 強制使用類型專用的導入和導出, 使 TypeScript 更加嚴格, 這樣有助於在編譯時優化生成的代碼。</span></span><br><span class="line">    <span class="attr">&quot;verbatimModuleSyntax&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Watch-Option"><a href="#Watch-Option" class="headerlink" title="Watch Option"></a>Watch Option</h3><p><code>watchOptions</code> 用於配置 TypeScript 在開發過程中如何監控文件變更。<br>這些選項主要用於改善開發效率, 當監控的文件或目錄發生變化時, TypeScript 會自動重新編譯或執行其他指定操作。<br>這對於開發階段非常重要, 因為它允許<strong>開發者即時查看更改的影響, 而不必手動重新編譯代碼。</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;watchOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// watchFile: 用於設定 TypeScript 監控單個檔案的方式。</span></span><br><span class="line">    <span class="comment">// fixedPollingInterval: 每隔固定時間檢查所有檔案是否變更。</span></span><br><span class="line">    <span class="comment">// priorityPollingInterval: 根據啟發式方法, 對某些類型的檔案進行優先輪詢。</span></span><br><span class="line">    <span class="comment">// dynamicPriorityPolling: 使用動態隊列, 較少修改的檔案將會被較少檢查。</span></span><br><span class="line">    <span class="comment">// useFsEvents (預設): 嘗試使用操作系統/檔案系統的原生事件來監控檔案變更。</span></span><br><span class="line">    <span class="comment">// useFsEventsOnParentDirectory: 嘗試監聽檔案父目錄的變更事件, 而不是直接監控檔案。</span></span><br><span class="line">    <span class="attr">&quot;watchFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;useFsEvents&quot;</span><span class="punctuation">,</span> <span class="comment">// 預設為使用文件系統事件來監控檔案變更。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// watchDirectory: 用於設定 TypeScript 監控整個目錄的方式。</span></span><br><span class="line">    <span class="comment">// fixedPollingInterval: 每隔固定時間檢查所有目錄是否變更。</span></span><br><span class="line">    <span class="comment">// dynamicPriorityPolling: 使用動態隊列, 較少修改的目錄將會被較少檢查。</span></span><br><span class="line">    <span class="comment">// useFsEvents (預設): 嘗試使用操作系統/檔案系統的原生事件來監控目錄變更。</span></span><br><span class="line">    <span class="attr">&quot;watchDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dynamicPriorityPolling&quot;</span><span class="punctuation">,</span> <span class="comment">// 使用動態優先級輪詢, 檢查變更較少的目錄次數較少。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 設置檔案或目錄的輪詢間隔時間（以毫秒為單位）, 適用於輪詢策略。</span></span><br><span class="line">    <span class="attr">&quot;pollingInterval&quot;</span><span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span> <span class="comment">// 設置為每 2000 毫秒輪詢一次檔案或目錄變更。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 設置是否監控目錄及其所有子目錄</span></span><br><span class="line">    <span class="attr">&quot;recursive&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// 設置為 true 以監控所有子目錄的變更。</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Type-Acquisition"><a href="#Type-Acquisition" class="headerlink" title="Type Acquisition"></a>Type Acquisition</h3><p>Type Acquisition 主要適用於 JavaScript 專案。<br>在 TypeScript 專案中, 開發者必須明確地將型別包含在專案中。<br>相對地, 對於 JavaScript 專案, TypeScript 工具會自動在後台下載所需的型別, 並將其儲存在 node_modules 以外的位置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typeAcquisition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// enable: 啟用自動獲取 JavaScript 專案的型別檔案 (.d.ts)。</span></span><br><span class="line">    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// include: 指定自動獲取型別檔案的庫。</span></span><br><span class="line">    <span class="comment">// 例如, 在這裡指定了 jQuery 和 lodash, TypeScript 將自動獲取它們的型別檔案。</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;jquery&quot;</span><span class="punctuation">,</span> <span class="string">&quot;lodash&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// exclude: 指定不需要自動獲取型別檔案的庫。</span></span><br><span class="line">    <span class="comment">// 這裡指定了 &quot;some-legacy-library&quot;, 即使它存在於專案中, TypeScript 也不會嘗試獲取它的型別檔案。</span></span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;some-legacy-library&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disableFilenameBasedTypeAcquisition: 禁用基於檔案名稱自動獲取型別檔案的功能。</span></span><br><span class="line">    <span class="comment">// 當設置為 true 時, TypeScript 不會基於檔案名稱來推測並下載型別檔案。</span></span><br><span class="line">    <span class="attr">&quot;disableFilenameBasedTypeAcquisition&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://www.typescriptlang.org/tsconfig/">Intro to the TSConfig</a></li><li><a href="https://www.totaltypescript.com/tsconfig-cheat-sheet">The TSConfig Cheat Sheet</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content">What is a tsconfig.json</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;tsconfig.json 文件是一個 TypeScript 專案的配置文件, 它位於根目錄中, 並定義了專案的編譯器選項。</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [學習筆記] Omit 與 Pick 的 Distributive 版本：解決 TypeScript Utility Types 的陷阱</title>
    <link href="https://blog.marsen.me/2024/10/05/2024/typescript_omit_pick_distributive_union_issue/"/>
    <id>https://blog.marsen.me/2024/10/05/2024/typescript_omit_pick_distributive_union_issue/</id>
    <published>2024-10-05T07:58:30.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在 TypeScript 中，Omit 和 Pick 是廣受喜愛的 Utility Types，<br>它們允許你從現有型別中排除或選擇特定的屬性來創建新型別。<br>參考我之前的<a href="https://blog.marsen.me/2022/09/12/2022/TypeScript_Omit/">文章</a></p><h2 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h2><h3 id="基礎示範：Omit-的使用"><a href="#基礎示範：Omit-的使用" class="headerlink" title="基礎示範：Omit 的使用"></a>基礎示範：Omit 的使用</h3><p>我們先來看個簡單的例子，假設我們有一個 Game 型別，其中包含 id、name 和 price 三個屬性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Game</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;    <span class="comment">// 遊戲的唯一識別碼</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;  <span class="comment">// 遊戲名稱</span></span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span>; <span class="comment">// 遊戲價格</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GameWithoutIdentity</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">Game</span>, <span class="string">&quot;id&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">game</span>: <span class="title class_">GameWithoutIdentity</span> = &#123;</span><br><span class="line">  <span class="comment">//id: &quot;1&quot;, // ❗ 編譯錯誤：&#x27;price&#x27; 不存在於 &#x27;GameWithoutIdentity&#x27; 型別中</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;The Legend of Zelda&quot;</span>, </span><br><span class="line">  <span class="attr">price</span>: <span class="number">59.99</span>, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Omit 可以幫助我們排除 id 屬性並創建新型別 GameWithoutIdentity<br>這在單一型別中運行良好，但當我們引入 Union Types 時，就有一些細節值得討論。</p><h2 id="問題：Union-Types-中的-Omit-行為"><a href="#問題：Union-Types-中的-Omit-行為" class="headerlink" title="問題：Union Types 中的 Omit 行為"></a>問題：Union Types 中的 Omit 行為</h2><p>假設我們有三個型別：Game、VideoGame 和 PCGame。<br>它們的 id 和 name 屬性相同，但每個型別都有其獨特的屬性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Game</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;        <span class="comment">// 遊戲的唯一識別碼</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;      <span class="comment">// 遊戲名稱</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">VideoGame</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;              <span class="comment">// 遊戲的唯一識別碼</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;            <span class="comment">// 遊戲名稱</span></span><br><span class="line">  <span class="attr">platform</span>: <span class="built_in">string</span>;        <span class="comment">// 遊戲平台</span></span><br><span class="line">  <span class="attr">genre</span>: <span class="built_in">string</span>;           <span class="comment">// 遊戲類型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PCGame</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;                    <span class="comment">// 遊戲的唯一識別碼</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;                  <span class="comment">// 遊戲名稱</span></span><br><span class="line">  <span class="attr">systemRequirements</span>: <span class="built_in">string</span>;    <span class="comment">// 系統需求</span></span><br><span class="line">  <span class="attr">hasDLC</span>: <span class="built_in">boolean</span>;              <span class="comment">// 是否有 DLC</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>當我們將這三個型別聯合起來形成 GameProduct 並嘗試使用 Omit 排除 id 時，結果卻不是我們預期的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GameProduct</span> = <span class="title class_">Game</span> | <span class="title class_">VideoGame</span> | <span class="title class_">PCGame</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GameProduct</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">GameProduct</span>, <span class="string">&quot;id&quot;</span>&gt;;</span><br></pre></td></tr></table></figure><p>你可能期望 GameProductWithoutId 是三個型別排除 id 屬性的 Union Type，但實際上，我們只得到了這樣的結構：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GameProduct</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這表示 <code>Omit</code> 在處理 <code>Union Types</code> 時，並沒有對每個聯合成員單獨操作，而是將它們合併成了一個結構。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>這種行為的根源在於，<code>Omit</code> 和 <code>Pick</code> 不是 <code>Distributive</code> 的 <code>Utility Types</code>。<br>它們不會針對每個 <code>Union Type</code> 成員進行個別操作，而是將 <code>Union Type</code> 視為一個整體來操作。<br>因此，當我們排除 id 屬性時，它無法處理每個成員型別中的不同屬性。</p><p>這與其他工具型別如 <code>Partial</code> 和 <code>Required</code> 不同，這些工具型別可以正確地處理 Union Types，並在每個成員上應用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PartialGameProduct</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">GameProduct</span>&gt;;</span><br><span class="line"><span class="comment">// 正確地給出了聯合型別的部分化版本</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialGameProduct</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Game</span>&gt; | <span class="title class_">Partial</span>&lt;<span class="title class_">VideoGame</span>&gt; | <span class="title class_">Partial</span>&lt;<span class="title class_">PCGame</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="解決方案：Distributive-Omit-與-Distributive-Pick"><a href="#解決方案：Distributive-Omit-與-Distributive-Pick" class="headerlink" title="解決方案：Distributive Omit 與 Distributive Pick"></a>解決方案：Distributive Omit 與 Distributive Pick</h3><p>要解決這個問題，我們可以定義一個 Distributive 的 Omit，這個版本會針對 Union Type 的每個成員進行操作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DistributiveOmit</span>&lt;T, K <span class="keyword">extends</span> <span class="title class_">PropertyKey</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span></span><br><span class="line">  ? <span class="title class_">Omit</span>&lt;T, K&gt;</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>使用 DistributiveOmit 後，我們可以正確地得到想要的結果：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GameProductWithoutId</span> = <span class="title class_">DistributiveOmit</span>&lt;<span class="title class_">GameProduct</span>, <span class="string">&quot;id&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// Hover 正確地給出了聯合型別的必填化版本</span></span><br><span class="line"><span class="comment">//type GameProductWithoutId = Omit&lt;Game, &quot;id&quot;&gt; | Omit&lt;VideoGame, &quot;id&quot;&gt; | Omit&lt;PCGame, &quot;id&quot;&gt;</span></span><br></pre></td></tr></table></figure><p>這將生成以下結構：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所以</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GameProductWithoutId</span> = </span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; | </span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">platform</span>: <span class="built_in">string</span>; <span class="attr">genre</span>: <span class="built_in">string</span> &#125; | </span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">systemRequirements</span>: <span class="built_in">string</span>; <span class="attr">hasDLC</span>: <span class="built_in">boolean</span> &#125;;</span><br></pre></td></tr></table></figure><p>現在，GameProductWithoutId 正確地成為了每個型別的 Union Type，並且成功地排除了 id 屬性。</p><h3 id="Distributive-Pick"><a href="#Distributive-Pick" class="headerlink" title="Distributive Pick"></a>Distributive Pick</h3><p>類似的，我們也可以定義一個 Distributive 的 Pick：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DistributivePick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span></span><br><span class="line">  ? <span class="title class_">Pick</span>&lt;T, K&gt;</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>這個 <code>Distributive</code> 版本的 <code>Pick</code> 確保了你所選擇的屬性實際存在於你正在操作的型別中，與內建的 <code>Pick</code> 行為一致。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p><code>Omit</code> 和 <code>Pick</code> 雖然在單一型別中表現良好，但在 <code>Union Types</code> 中，<br>它們並不是 <code>Distributive</code> 的，這可能導致意想不到的結果。<br>我們可以創建 <code>DistributiveOmit</code> 和 <code>DistributivePick</code>，<br>使它們能夠針對每個 <code>Union Type</code> 成員單獨進行操作，從而獲得更為預期的結果。<br>如果你在專案中遇到這類問題，記得可以考慮使用自定義的 <code>Distributive</code> 版本來處理 <code>Union Types</code>，這樣可以避免踩雷！</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在 TypeScript 中，Omit 和 Pick 是廣受喜愛的 Utility Types，&lt;br&gt;它們允許你從現有型別</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [學習筆記] TypeScript 的 Narrowing Types 與 Boolean 的例外</title>
    <link href="https://blog.marsen.me/2024/10/04/2024/typescript_type_narrowing_example/"/>
    <id>https://blog.marsen.me/2024/10/04/2024/typescript_type_narrowing_example/</id>
    <published>2024-10-04T17:48:30.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在使用 TypeScript 時，我們常常會利用條件語句來收窄型別(Narrowing Types)，確保程式邏輯的正確性。<br>例如:<br>Narrowing Types的例子：使用 typeof</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">processValue</span> = (<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 在這裡 TypeScript 已經收窄為 string，所以可以使用 .toUpperCase 的方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`String value: <span class="subst">$&#123;value.toUpperCase()&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 在這裡 TypeScript 已經收窄為 number，所以可以使用 .toFixed 的方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Number value: <span class="subst">$&#123;value.toFixed(<span class="number">2</span>)&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>在這個例子中，我們定義了一個 processValue 函數，它接受一個 string 或 number 類型的參數。<br>使用 typeof 來檢查 value 的類型後，TypeScript 會自動進行 Narrowing Types：<br>當 <code>typeof value === &quot;string&quot;</code> 時，TypeScript 將 value 的類型自動收窄為 string，<br>所以我們可以安全地使用字串方法，如 <code>toUpperCase()</code>。<br>當 else 條件觸發時，value 類型已經收窄為 number，因此我們可以使用 number 專有的方法，如 toFixed()。<br>這樣的收窄機制能夠在多態的情況下提高程式的安全性和可讀性，讓開發者更清楚在不同條件下該如何操作不同類型的值。</p><h2 id="主文"><a href="#主文" class="headerlink" title="主文"></a>主文</h2><p>然而，在一些特定情況下，TypeScript 的 Narrowing Types 並不如我們預期的那麼靈活。<br>比如說 Boolean() 函數進行條件檢查時，TypeScript 不會像其他檢查方法那樣進行 Narrowing Types。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">NarrowFun</span> = (<span class="params">input: <span class="built_in">string</span> | <span class="literal">null</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!!input) &#123;</span><br><span class="line">    input.<span class="title function_">toUpperCase</span>();  <span class="comment">// 這裡 TypeScript 收窄為 string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">NotNarrowFun</span> = (<span class="params">input: <span class="built_in">string</span> | <span class="literal">null</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Boolean</span>(input)) &#123;</span><br><span class="line">    input.<span class="title function_">toUpperCase</span>();  <span class="comment">// 這裡 TypeScript 沒有收窄，仍然是 string | null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在這段程式碼中，我們希望透過條件語句來檢查 input 是否為 null。<br>使用 <code>!!input</code> 時，TypeScript 會正確地將 input 的 Narrowing Types為 string，<br>但當我們改用 Boolean(input) 時，TypeScript 並沒有收窄，仍然認為 input 可能是 string | null。  </p><h3 id="為什麼會這樣？"><a href="#為什麼會這樣？" class="headerlink" title="為什麼會這樣？"></a>為什麼會這樣？</h3><h4 id="Boolean-函數的行為"><a href="#Boolean-函數的行為" class="headerlink" title="Boolean 函數的行為"></a>Boolean 函數的行為</h4><p>Boolean 是 JavaScript 的一個內建函數，它接受任何值並將其轉換為 true 或 false，<br>基於 JavaScript 的「true」或「false」邏輯。<br>然而，TypeScript 並不視 Boolean(input) 作為一個能收窄類型的操作。<br>它只將 Boolean(input) 視為一個普通的布林值返回，不會對 input 進行更深入的類型推斷。  </p><p>在 TypeScript 中，Boolean 函數的定義是這樣的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BooleanConstructor</span> &#123;</span><br><span class="line">  <span class="title function_">new</span>(value?: <span class="built_in">any</span>): <span class="title class_">Boolean</span>;</span><br><span class="line">  &lt;T&gt;(value?: T): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="title class_">Boolean</span>: <span class="title class_">BooleanConstructor</span>;</span><br></pre></td></tr></table></figure><p>如你所見，Boolean 是一個接受任何類型 (any) 的值作為輸入，並返回 boolean 類型的結果。<br>它會將輸入轉換為布林值 (true 或 false)，但並不提供關於輸入值的具體類型資訊。<br>因此，TypeScript 只知道返回的是一個 boolean，而無法推斷 input 的原始類型是否已經被過濾（例如從 string | null 到 string）。  </p><h4 id="缺乏類型推斷"><a href="#缺乏類型推斷" class="headerlink" title="缺乏類型推斷"></a>缺乏類型推斷</h4><p>在 Boolean(input) 中，TypeScript 僅知道 input 被轉換為 true 或 false，<br>但它不會從中推斷 input 的實際類型。<br>因此，TypeScript 並沒有收窄 input 為 string 或 null。<br>這就是為什麼即使你在 if(Boolean(input)) 內部，input 依然是 <code>string | null</code>，而不是單純的 <code>string</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Boolean</span>(input)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(input);  <span class="comment">// TypeScript 仍視 input 為 string | null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="類型收窄的條件"><a href="#類型收窄的條件" class="headerlink" title="類型收窄的條件"></a>類型收窄的條件</h4><p>TypeScript 進行類型收窄的條件是根據語法或邏輯條件來進行推斷，<br>例如 <code>typeof</code>、<code>instanceof</code>、比較操作 (<code>==</code>, <code>===)</code> 等。<br>這些條件能幫助 TypeScript 推斷出更具體的類型。<br>當你使用 typeof input &#x3D;&#x3D;&#x3D; “string” 時，TypeScript 可以自動將 input 收窄為 string，<br>因為這是一個明確的類型檢查：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(input);  <span class="comment">// 現在 input 是 string 類型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="為什麼-input-能收窄"><a href="#為什麼-input-能收窄" class="headerlink" title="為什麼 !!input 能收窄"></a>為什麼 !!input 能收窄</h4><p>與 Boolean(input) 不同，<code>!!input</code> 能夠收窄類型。<br>因為這個雙重否定操作 (!!) 是 JavaScript 的一個常見模式，它會將任意值轉換為布林值。<br>由於 TypeScript 能識別這個模式，當你寫 if(!!input) 時，<br>TypeScript 可以推斷 input 是 truthy，並將 null 或 undefined 排除在外。<br>因此，input 被收窄為一個具體的類型（在這裡是 string）。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!!input) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(input);  <span class="comment">// input 被收窄為 string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替代方案：自定義判斷函數"><a href="#替代方案：自定義判斷函數" class="headerlink" title="替代方案：自定義判斷函數"></a>替代方案：自定義判斷函數</h2><p>如果我們需要更加靈活的 Narrowing Types，可以考慮使用自定義的判斷函數。<br>例如，我們可以創建一個 isString 函數來明確檢查某個值是否為字串，這樣就可以正確進行 Narrowing Types。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isString = (<span class="attr">value</span>: <span class="built_in">unknown</span>): value is <span class="built_in">string</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">myFunc</span> = (<span class="params">input: <span class="built_in">string</span> | <span class="literal">null</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(input)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(input);  <span class="comment">// 這裡 TypeScript 收窄為 string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在這段程式碼中，我們定義了一個 isString 函數，它不僅進行類型判斷，還告訴 TypeScript 當返回 true 時，value 確實是 string。<br>這樣的函數可以幫助我們更好地進行 Narrowing Types。  </p><h3 id="另一個常見的例子：filter-Boolean"><a href="#另一個常見的例子：filter-Boolean" class="headerlink" title="另一個常見的例子：filter(Boolean)"></a>另一個常見的例子：filter(Boolean)</h3><p>filter(Boolean) 是 JavaScript 中常用的一個語法糖，用來過濾掉 falsy 值（如 null、undefined、0 等）。<br>但在 TypeScript 中，這個模式無法進行 Narrowing Types。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 結果類型仍然包含 null 和 undefined</span></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br></pre></td></tr></table></figure><p>在這裡，TypeScript 沒有收窄 result 的類型，它仍然認為結果可能包含 null 和 undefined。<br>要解決這個問題，我們可以自定義一個過濾函數，來正確處理這些類型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filterNullOrUndefined = &lt;T&gt;(<span class="attr">value</span>: T | <span class="literal">null</span> | <span class="literal">undefined</span>): value is T =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> value !== <span class="literal">null</span> &amp;&amp; value !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">filter</span>(isNotNullOrUndefined);  <span class="comment">// 現在類型是 number[]</span></span><br></pre></td></tr></table></figure><p>這樣，我們就能確保結果陣列只包含 number，而不再包含 null 和 undefined。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>雖然 Boolean() 是 JavaScript 中常見的布林判斷工具，但在 TypeScript 中，它無法像其他判斷語句一樣進行 Narrowing Types。<br>我們可以透過自定義類型判斷函數，來精確地告知 TypeScript 在特定條件下的類型，從而實現更強大和靈活的類型檢查。</p><p>參考</p><ul><li><a href="https://commerce.nearform.com/blog/2022/narrowing-types">Narrowing Types in TypeScript</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">Narrowing</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在使用 TypeScript 時，我們常常會利用條件語句來收窄型別(Narrowing Types)，確保程式邏輯的正確性。</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [學習筆記] 使用 Discriminated Unions 解決多狀態問題</title>
    <link href="https://blog.marsen.me/2024/10/04/2024/typescript_discriminated_unions_guide/"/>
    <id>https://blog.marsen.me/2024/10/04/2024/typescript_discriminated_unions_guide/</id>
    <published>2024-10-04T16:30:00.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在日常開發中，我們常需要定義不同狀態下的數據結構，這類需求通常涉及到多個狀態及其對應的屬性。<br>在 TypeScript 中，如果不加以控制，這些狀態容易變成一個充滿可選屬性的複雜物件，導致程式碼難以管理。<br>我們有一種更優雅的解決方案 —— <code>Discriminated Unions</code>，<br>它在 TypeScript 中幫助我們避免常見的「bag of optionals」的問題。  </p><h2 id="主文"><a href="#主文" class="headerlink" title="主文"></a>主文</h2><p>假設我們正在開發一個付款流程，並需要一個 PaymentState 類型來描述付款狀態：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PaymentState</span> = &#123;</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;processing&quot;</span> | <span class="string">&quot;success&quot;</span> | <span class="string">&quot;failed&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此時，我們還需要根據不同狀態保存資料或錯誤訊息，<br>因此我們為 PaymentState 類型新增了可選的 receiptUrl 和 error 屬性：  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PaymentState</span> = &#123;</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;processing&quot;</span> | <span class="string">&quot;success&quot;</span> | <span class="string">&quot;failed&quot;</span>;</span><br><span class="line">  errorMessage?: <span class="built_in">string</span>;</span><br><span class="line">  receiptUrl?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這個定義表面上看起來可行，但在實際使用時容易出現問題。<br>假設我們定義了一個渲染 UI 的函式 renderUI：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">renderUI</span> = (<span class="params">state: PaymentState</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (state.<span class="property">status</span> === <span class="string">&quot;processing&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Payment Processing...&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state.<span class="property">status</span> === <span class="string">&quot;failed&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Error: <span class="subst">$&#123;state.errorMessage.toUpperCase()&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state.<span class="property">status</span> === <span class="string">&quot;success&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Receipt: <span class="subst">$&#123;state.receiptUrl&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TypeScript 提示 state.errorMessage 可能是 undefined，<br>這意味著我們在某些狀態下無法安全地操作 errorMessage 或 receiptUrl 屬性。<br>這是因為這兩個屬性是可選的，並且沒有和 status 明確地綁定。<br>這就造成了<strong>類型過於鬆散</strong>。</p><h2 id="解決方案：Discriminated-Unions"><a href="#解決方案：Discriminated-Unions" class="headerlink" title="解決方案：Discriminated Unions"></a>解決方案：Discriminated Unions</h2><p>為了解決這個問題，我們可以使用 Discriminated Unions。<br>這種模式可以將多個狀態拆分為具體的物件，並通過共同的 status 屬性來區分每個狀態。</p><p>首先，我們可以將每個狀態單獨建模：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">State</span> =</span><br><span class="line">  | &#123; <span class="attr">status</span>: <span class="string">&quot;processing&quot;</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>; <span class="attr">errorMessage</span>: <span class="built_in">string</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">status</span>: <span class="string">&quot;success&quot;</span>; <span class="attr">receiptUrl</span>: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure><p>這樣一來，我們就能明確地將 errorMessage 屬性與 error 狀態綁定，<br>並且 receiptUrl 屬性只會出現在 success 狀態下。<br>當我們在 renderUI 函式中使用這些屬性時，TypeScript 會自動根據 status 來縮小類型範圍：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">renderUI</span> = (<span class="params">state: State</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (state.<span class="property">status</span> === <span class="string">&quot;processing&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Processing...&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state.<span class="property">status</span> === <span class="string">&quot;error&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Error: <span class="subst">$&#123;state.errorMessage.toUpperCase()&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state.<span class="property">status</span> === <span class="string">&quot;success&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Receipt: <span class="subst">$&#123;state.receiptUrl&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TypeScript 現在能夠根據 status 確保 errorMessage 在 error 狀態下是一個字串，<br>並且 receiptUrl 只會在 success 狀態出現。<br>這大大提高了我們程式碼的安全性和可讀性。  </p><h3 id="進一步優化：提取類型別名"><a href="#進一步優化：提取類型別名" class="headerlink" title="進一步優化：提取類型別名"></a>進一步優化：提取類型別名</h3><p>為了讓程式碼更加清晰，我們可以將每個狀態定義為單獨的類型別名：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LoadingState</span> = &#123; <span class="attr">status</span>: <span class="string">&quot;processing&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ErrorState</span> = &#123; <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>; <span class="attr">errorMessage</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SuccessState</span> = &#123; <span class="attr">status</span>: <span class="string">&quot;success&quot;</span>; <span class="attr">receiptUrl</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">State</span> = <span class="title class_">LoadingState</span> | <span class="title class_">ErrorState</span> | <span class="title class_">SuccessState</span>;</span><br></pre></td></tr></table></figure><p>這樣的結構不僅清晰易讀，也方便日後的擴展。<br>如果我們需要增加其他狀態，比如 idle 或 cancelled，只需要新增對應的類型別名即可，保持程式碼的擴展性和一致性。  </p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>Discriminated Unions 是 TypeScript 中處理多狀態情境的強大工具，特別適合用來解決「可選屬性的大集合」問題。它能夠：</p><p>確保每個屬性和狀態間的強關聯，減少錯誤和不一致性。<br>提升程式碼的可讀性和維護性，並且有助於擴展性。<br>讓 TypeScript 自動推斷正確的屬性類型，避免不必要的空值檢查。<br>當你發現程式碼中有過多的可選屬性且沒有強烈關聯時，考慮使用 discriminated unions 來重構並簡化你的類型定義。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://www.totaltypescript.com/discriminated-unions-are-a-devs-best-friend">TypeScript Discriminated Unions for Frontend Developers</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html">TypeScript Handbook - Unions and Intersection Types</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在日常開發中，我們常需要定義不同狀態下的數據結構，這類需求通常涉及到多個狀態及其對應的屬性。&lt;br&gt;在 TypeScript</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [學習筆記] 探索 TypeScript 的 Template Literals </title>
    <link href="https://blog.marsen.me/2024/09/30/2024/typescript_template_literals/"/>
    <id>https://blog.marsen.me/2024/09/30/2024/typescript_template_literals/</id>
    <published>2024-09-30T07:35:00.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什麼是 Template Literals 類型？<br>在 TypeScript 中，Template Literals 類型是 ES6 引入的一個強大的功能。<br>Template literals ，主要用來加強字串的操作，它提供了更靈活和易讀的字串插值方式，<br>這不僅提高了代碼的可讀性，結合上 TypeScript <strong>還可以增加了類型安全性</strong>。<br>本篇提供大量範例與適用場景以供測試，有任何問題歡迎提出。  </p><h2 id="基礎應用-JS-TS-都適用"><a href="#基礎應用-JS-TS-都適用" class="headerlink" title="基礎應用(JS&#x2F;TS　都適用)"></a>基礎應用(JS&#x2F;TS　都適用)</h2><h3 id="字串插值-String-Interpolation"><a href="#字串插值-String-Interpolation" class="headerlink" title="字串插值 (String Interpolation)"></a>字串插值 (String Interpolation)</h3><p>傳統的字串拼接需要用 + 號，使用 Template Literals 可以讓拼接更簡單。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lin&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 傳統拼接</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;My name is &quot;</span> + name + <span class="string">&quot; and I am &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template Literals </span></span><br><span class="line"><span class="keyword">const</span> message2 = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span> and I am <span class="subst">$&#123;age&#125;</span> years old.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message2);</span><br></pre></td></tr></table></figure><h3 id="多行字串-Multi-line-Strings"><a href="#多行字串-Multi-line-Strings" class="headerlink" title="多行字串 (Multi-line Strings)"></a>多行字串 (Multi-line Strings)</h3><p>Template literals 支援多行字串，可以避免使用 <code>\n</code> 或其他換行符號。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> poem = <span class="string">`</span></span><br><span class="line"><span class="string">  Roses are red,</span></span><br><span class="line"><span class="string">  Violets are blue,</span></span><br><span class="line"><span class="string">  Sugar is sweet,</span></span><br><span class="line"><span class="string">  And so are you.</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(poem);</span><br></pre></td></tr></table></figure><h3 id="內嵌表達式-Embedded-Expressions"><a href="#內嵌表達式-Embedded-Expressions" class="headerlink" title="內嵌表達式 (Embedded Expressions)"></a>內嵌表達式 (Embedded Expressions)</h3><p>可以在字串中插入任意的 JavaScript 表達式，例如函數調用、運算等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The sum of <span class="subst">$&#123;a&#125;</span> and <span class="subst">$&#123;b&#125;</span> is <span class="subst">$&#123;a + b&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h3 id="條件判斷-Conditional-Statements"><a href="#條件判斷-Conditional-Statements" class="headerlink" title="條件判斷 (Conditional Statements)"></a>條件判斷 (Conditional Statements)</h3><p>結合三元運算符或簡單的 if 判斷，可以在字串中靈活地處理條件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loggedIn = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`You are <span class="subst">$&#123;loggedIn ? <span class="string">&quot;logged in&quot;</span> : <span class="string">&quot;not logged in&quot;</span>&#125;</span>.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br></pre></td></tr></table></figure><h3 id="標記模板字串-Tagged-Templates"><a href="#標記模板字串-Tagged-Templates" class="headerlink" title="標記模板字串 (Tagged Templates)"></a>標記模板字串 (Tagged Templates)</h3><p>標記模板允許你在插值之前處理字串，可以用於處理國際化、多語系或安全操作（如避免 XSS 攻擊）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sanitizeHTML</span>(<span class="params">literals, ...values</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  literals.<span class="title function_">forEach</span>(<span class="function">(<span class="params">literal, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = values[i] ? <span class="title class_">String</span>(values[i]).<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>).<span class="title function_">replace</span>(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    result += literal + value;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInput = <span class="string">&quot;&lt;script&gt;alert(&#x27;Hacked!&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// call function use Tagged Template Literal</span></span><br><span class="line"><span class="keyword">const</span> safeOutput = sanitizeHTML<span class="string">`&lt;div&gt;<span class="subst">$&#123;userInput&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(safeOutput);  <span class="comment">// &lt;div&gt;&amp;lt;script&amp;gt;alert(&#x27;Hacked!&#x27;)&amp;lt;/script&amp;gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><h3 id="動態生成-HTML-或模版字串"><a href="#動態生成-HTML-或模版字串" class="headerlink" title="動態生成 HTML 或模版字串"></a>動態生成 HTML 或模版字串</h3><p>當需要動態生成 HTML 或動態內容時，使用 Template Literals 可以讓結構更清晰。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;list.map(item =&gt; <span class="string">`&lt;li&gt;<span class="subst">$&#123;item&#125;</span>&lt;/li&gt;`</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(html);</span><br></pre></td></tr></table></figure><h2 id="進階應用-with-Type"><a href="#進階應用-with-Type" class="headerlink" title="進階應用 with Type"></a>進階應用 with Type</h2><h3 id="動態生成-URL-路徑"><a href="#動態生成-URL-路徑" class="headerlink" title="動態生成 URL 路徑"></a>動態生成 URL 路徑</h3><p>在構建 API 或動態路徑時，Template Literals 結合 TypeScript 類型檢查可以確保參數類型正確，避免拼接錯誤。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Endpoint</span> = <span class="string">&quot;/users&quot;</span> | <span class="string">&quot;/posts&quot;</span> | <span class="string">&quot;/comments&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createURL</span>(<span class="params">endpoint: Endpoint, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`https://api.example.com<span class="subst">$&#123;endpoint&#125;</span>/<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="title function_">createURL</span>(<span class="string">&quot;/users&quot;</span>, <span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url); <span class="comment">// https://api.example.com/users/123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若傳入不存在的路徑，TypeScript 會報錯</span></span><br><span class="line"><span class="title function_">createURL</span>(<span class="string">&quot;/invalid&quot;</span>, <span class="number">123</span>); <span class="comment">// Error: Argument of type &#x27;&quot;invalid&quot;&#x27; is not assignable to parameter of type &#x27;Endpoint&#x27;.</span></span><br></pre></td></tr></table></figure><p>可以作開發中的路由檢查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">HTTPMethod</span> = <span class="string">&quot;GET&quot;</span> | <span class="string">&quot;POST&quot;</span> | <span class="string">&quot;PUT&quot;</span> | <span class="string">&quot;DELETE&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Route</span> = <span class="string">`/api/<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">method: HTTPMethod, route: Route</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Sending <span class="subst">$&#123;method&#125;</span> request to <span class="subst">$&#123;route&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">request</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>);  <span class="comment">// 正確</span></span><br><span class="line"><span class="title function_">request</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/api/posts&quot;</span>); <span class="comment">// 正確</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 這會觸發類型檢查錯誤</span></span><br><span class="line"><span class="title function_">request</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/invalidRoute&quot;</span>); <span class="comment">// Error: Argument of type &#x27;&quot;/invalidRoute&quot;&#x27; is not assignable to parameter of type &#x27;Route&#x27;.</span></span><br></pre></td></tr></table></figure><p>相同的概念也可以來動態生成 SQL 查詢語句，同時確保參數的安全性與類型正確性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TableName</span> = <span class="string">&quot;users&quot;</span> | <span class="string">&quot;posts&quot;</span> | <span class="string">&quot;comments&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">selectFromTable</span>(<span class="params">table: TableName, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`SELECT * FROM <span class="subst">$&#123;table&#125;</span> WHERE id = <span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> query = <span class="title function_">selectFromTable</span>(<span class="string">&quot;users&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(query); <span class="comment">// SELECT * FROM users WHERE id = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 傳入錯誤的表名時，會被 TypeScript 類型檢查發現</span></span><br><span class="line"><span class="title function_">selectFromTable</span>(<span class="string">&quot;invalidTable&quot;</span>, <span class="number">1</span>); <span class="comment">// Error: Argument of type &#x27;&quot;invalidTable&quot;&#x27; is not assignable to parameter of type &#x27;TableName&#x27;.</span></span><br></pre></td></tr></table></figure><h3 id="字串聯合類型構造器"><a href="#字串聯合類型構造器" class="headerlink" title="字串聯合類型構造器"></a>字串聯合類型構造器</h3><p>一個常見的模式是將Template Literals 類型與聯合類型結合，這樣可以生成所有可能的組合。<br>例如，假設我們有一組顏色和相應的色調：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ColorShade</span> = <span class="number">100</span> | <span class="number">200</span> | <span class="number">300</span> | <span class="number">400</span> | <span class="number">500</span> | <span class="number">600</span> | <span class="number">700</span> | <span class="number">800</span> | <span class="number">900</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = <span class="string">&quot;red&quot;</span> | <span class="string">&quot;blue&quot;</span> | <span class="string">&quot;green&quot;</span>;</span><br></pre></td></tr></table></figure><p>我們可以創建一個顏色調色板，代表所有可能的顏色和色調的組合：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ColorPalette</span> = <span class="string">`<span class="subst">$&#123;Color&#125;</span>-<span class="subst">$&#123;ColorShade&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">color</span>: <span class="title class_">ColorPalette</span> = <span class="string">&quot;red-500&quot;</span>; <span class="comment">// 正確</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">badColor</span>: <span class="title class_">ColorPalette</span> = <span class="string">&quot;red&quot;</span>; <span class="comment">// 錯誤</span></span><br></pre></td></tr></table></figure><p>這樣，我們就得到了 27 種可能的組合（3 種顏色乘以 9 種色調）。<br>又或者，在樣式生成工具或 CSS-in-JS 的場景中，Template Literals 可以結合類型系統來強化樣式生成工具的正確性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CSSUnit</span> = <span class="string">&quot;px&quot;</span> | <span class="string">&quot;em&quot;</span> | <span class="string">&quot;rem&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CSSProperty</span> = <span class="string">&quot;margin&quot;</span> | <span class="string">&quot;padding&quot;</span> | <span class="string">&quot;font-size&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">applyStyle</span>(<span class="params">property: CSSProperty, value: <span class="built_in">number</span>, unit: CSSUnit</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;property&#125;</span>: <span class="subst">$&#123;value&#125;</span><span class="subst">$&#123;unit&#125;</span>;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">applyStyle</span>(<span class="string">&quot;margin&quot;</span>, <span class="number">10</span>, <span class="string">&quot;px&quot;</span>));  <span class="comment">// margin: 10px;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">applyStyle</span>(<span class="string">&quot;font-size&quot;</span>, <span class="number">1.5</span>, <span class="string">&quot;em&quot;</span>)); <span class="comment">// font-size: 1.5em;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若單位或屬性錯誤，會觸發類型檢查錯誤</span></span><br><span class="line"><span class="title function_">applyStyle</span>(<span class="string">&quot;background&quot;</span>, <span class="number">10</span>, <span class="string">&quot;px&quot;</span>); <span class="comment">// Error: Argument of type &#x27;&quot;background&quot;&#x27; is not assignable to parameter of type &#x27;CSSProperty&#x27;.</span></span><br></pre></td></tr></table></figure><h3 id="另一個例子"><a href="#另一個例子" class="headerlink" title="另一個例子"></a>另一個例子</h3><p>在構建大型系統時，常常需要動態生成變量名稱或類型，<br>這時可以使用 Template Literal Types 來幫助構造更具彈性的類型系統。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Eventa</span> = <span class="string">&quot;click&quot;</span> | <span class="string">&quot;hover&quot;</span> | <span class="string">&quot;focus&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ElementID</span> = <span class="string">&quot;button&quot;</span> | <span class="string">&quot;input&quot;</span> | <span class="string">&quot;link&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 動態生成事件處理函數名稱 3x3 種型別檢查</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EventHandlerName</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Eventa</span>, T <span class="keyword">extends</span> <span class="title class_">ElementID</span>&gt; = <span class="string">`<span class="subst">$&#123;T&#125;</span>On<span class="subst">$&#123;Capitalize&lt;E&gt;&#125;</span>Handler`</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">buttonOnClickHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;click&quot;</span>, <span class="string">&quot;button&quot;</span>&gt; = <span class="string">&quot;buttonOnClickHandler&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">buttonOnHoverHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;hover&quot;</span>, <span class="string">&quot;button&quot;</span>&gt; = <span class="string">&quot;buttonOnHoverHandler&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">buttonOnFocusHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;focus&quot;</span>, <span class="string">&quot;button&quot;</span>&gt; = <span class="string">&quot;buttonOnFocusHandler&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">inputOnClickHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;click&quot;</span>, <span class="string">&quot;input&quot;</span>&gt; = <span class="string">&quot;inputOnClickHandler&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">inputOnHoverHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;hover&quot;</span>, <span class="string">&quot;input&quot;</span>&gt; = <span class="string">&quot;inputOnHoverHandler&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">inputOnFocusHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;focus&quot;</span>, <span class="string">&quot;input&quot;</span>&gt; = <span class="string">&quot;inputOnFocusHandler&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">linkOnClickHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;click&quot;</span>, <span class="string">&quot;link&quot;</span>&gt; = <span class="string">&quot;linkOnClickHandler&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">linkOnHoverHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;hover&quot;</span>, <span class="string">&quot;link&quot;</span>&gt; = <span class="string">&quot;linkOnHoverHandler&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">linkOnFocusHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;focus&quot;</span>, <span class="string">&quot;link&quot;</span>&gt; = <span class="string">&quot;linkOnFocusHandler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">invalidHandler</span>: <span class="title class_">EventHandlerName</span>&lt;<span class="string">&quot;click&quot;</span>, <span class="string">&quot;button&quot;</span>&gt; = <span class="string">&quot;buttonOnHoverHandler&quot;</span>; <span class="comment">// Error: Type &#x27;&quot;buttonOnHoverHandler&quot;&#x27; is not assignable to type &#x27;&quot;buttonOnClickHandler&quot;&#x27;.</span></span><br></pre></td></tr></table></figure><h3 id="參考網路上的例子"><a href="#參考網路上的例子" class="headerlink" title="參考網路上的例子"></a>參考網路上的例子</h3><p>Template Literals 類型允許我們在 TypeScript 中插入其他類型到字符串類型中。<br>例如，假設我們想要定義一個表示 PNG 文件的類型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Excel</span> = <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>.xlsx`</span>;</span><br></pre></td></tr></table></figure><p>這樣，當我們為變量指定 Excel 類型時，它必須以 .xlsx 結尾：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">new_excel</span>: <span class="title class_">Excel</span> = <span class="string">&quot;my-image.xlsx&quot;</span>; <span class="comment">// ✅正確</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">old_excel</span>: <span class="title class_">Excel</span> = <span class="string">&quot;my-image.xls&quot;</span>; <span class="comment">// ❌錯誤</span></span><br></pre></td></tr></table></figure><p>當字符串不符合定義時，TypeScript 會顯示錯誤提示，這有助於減少潛在的錯誤。<br>我們可以確保字符串符合特定的前綴或中間包含特定子字符串。<br>例如，若要確保路由以 <code>/</code> 開頭，我們可以這樣定義：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Route</span> = <span class="string">`/<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">myRoute</span>: <span class="title class_">Route</span> = <span class="string">&quot;/home&quot;</span>; <span class="comment">// ✅正確</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">badRoute</span>: <span class="title class_">Route</span> = <span class="string">&quot;home&quot;</span>; <span class="comment">// ❌錯誤</span></span><br></pre></td></tr></table></figure><p>同樣的，如果我們需要確保字符串包含 ?，以便視為查詢字符串，我們可以這樣定義：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">QueryString</span> = <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>?<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">myQueryString</span>: <span class="title class_">QueryString</span> = <span class="string">&quot;search?query=hello&quot;</span>; <span class="comment">// 正確</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">badQueryString</span>: <span class="title class_">QueryString</span> = <span class="string">&quot;search&quot;</span>; <span class="comment">// 錯誤</span></span><br></pre></td></tr></table></figure><p>此外，TypeScript 還提供了一些內建的實用類型來轉換字符串類型，例如 Uppercase 和 Lowercase，可以將字符串轉換為大寫或小寫：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UppercaseHello</span> = <span class="title class_">Uppercase</span>&lt;<span class="string">&quot;hello&quot;</span>&gt;; <span class="comment">// &quot;HELLO&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LowercaseHELLO</span> = <span class="title class_">Lowercase</span>&lt;<span class="string">&quot;HELLO&quot;</span>&gt;; <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>還有 Capitalize 和 Uncapitalize 這兩個實用類型，可以用來改變字符串的首字母大小寫：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CapitalizeMatt</span> = <span class="title class_">Capitalize</span>&lt;<span class="string">&quot;matt&quot;</span>&gt;; <span class="comment">// &quot;Matt&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UncapitalizePHD</span> = <span class="title class_">Uncapitalize</span>&lt;<span class="string">&quot;PHD&quot;</span>&gt;; <span class="comment">// &quot;pHD&quot;</span></span><br></pre></td></tr></table></figure><p>這些功能展示了 TypeScript 類型系統的靈活性。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Template Literals 類型是一個非常有用的特性，能夠幫助開發者在 TypeScript 中更精確地控制字符串類型。<br>從定義特定格式的文件名到生成複雜的組合類型，它為代碼提供了更高的可讀性和安全性。<br>如果你在開發過程中需要處理字符串模式，Template Literals 類型無疑是值得考慮的工具。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">Template literals (Template strings)</a></li><li><a href="https://medium.com/onedegree-tech-blog/javascript-%E6%9C%89%E8%B6%A3%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AD%98-tagged-template-literals-5ca9db71f066">JavaScript 有趣的冷知識：tagged template literals</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;什麼是 Template Literals 類型？&lt;br&gt;在 TypeScript 中，Template Literals 類型是 ES6 </summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [學習筆記] TypeScript 字串建議的小技巧</title>
    <link href="https://blog.marsen.me/2024/09/30/2024/typescript_string_intersection_trick/"/>
    <id>https://blog.marsen.me/2024/09/30/2024/typescript_string_intersection_trick/</id>
    <published>2024-09-30T06:00:14.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近在寫一個 Hero component，需求是讓使用者能指定英雄的種族。<br>我們的設計有一些既定的種族，例如 human 和 demon，同時也希望讓使用者能輸入任何自定義的種族名稱。<br>最初的想法是用以下的定義：  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Race</span> = <span class="string">&#x27;human&#x27;</span> | <span class="string">&#x27;demon&#x27;</span> | <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>並在 Hero 的 props 中使用這個型別：  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">HeroProps</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">race</span>: <span class="title class_">Race</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// component 大概如下</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Hero</span> = (<span class="params">&#123; race,name &#125;: HeroProps</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hero: &#123;name&#125; is &#123;race&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這樣一來，使用者可以像這樣使用：  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/HeroDisplay.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Hero</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../components/hero&#x27;</span>; <span class="comment">// 引入 Hero 型別</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">HeroDisplay</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Hero</span> <span class="attr">name</span>=<span class="string">&quot;alice&quot;</span> <span class="attr">race</span>=<span class="string">&quot;human&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Hero</span> <span class="attr">name</span>=<span class="string">&quot;mark&quot;</span> <span class="attr">race</span>=<span class="string">&quot;demon&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!--more heros --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HeroDisplay</span>;</span><br></pre></td></tr></table></figure><p>一切看似沒問題，但問題是——在使用 Hero component 時，TypeScript 並不會自動給出 human 或 demon 這樣的建議。  </p><p><strong>既然我們希望能提供建議，該怎麼解決這個問題呢？</strong>  </p><h2 id="實作記錄"><a href="#實作記錄" class="headerlink" title="實作記錄"></a>實作記錄</h2><p>解決方法看起來有些奇怪，我們可以透過將字串類型與一個空的物件相交來達成目標：  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Race</span> = <span class="string">&#x27;human&#x27;</span> | <span class="string">&#x27;demon&#x27;</span> | (<span class="built_in">string</span> &amp; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>這樣一來，在使用 Hero component 時，TypeScript 就會正確地給出 primary 和 secondary 的建議。<br>為什麼這會起作用？這其實是 TypeScript 編譯器的一個小「怪癖」。<br>當你把字串常值類型（例如 “human”）與字串類型（string）進行聯集時，<br>TypeScript 會急切地將其轉換為單純的 string，因此在 Hover 時會看到類似這樣的結果：  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Race</span> = <span class="string">&#x27;human&#x27;</span> | <span class="string">&#x27;demon&#x27;</span> | <span class="built_in">string</span> ;</span><br><span class="line"><span class="comment">// Hover 時會顯示： type Race = string</span></span><br></pre></td></tr></table></figure><p>換句話說，TypeScript 在使用前就忘記了 human 和 demon。<br>而透過與空物件 &amp; {} 進行相交，我們能「欺騙」 TypeScript，讓它在更長時間內保留這些字串常值類型。  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Race</span> = <span class="string">&#x27;human&#x27;</span> | <span class="string">&#x27;demon&#x27;</span> | (<span class="built_in">string</span> &amp; &#123;&#125;);</span><br><span class="line"><span class="comment">// Hover 時會顯示： type Race = &#x27;human&#x27; | &#x27;demon&#x27; | (string &amp; &#123;&#125;);</span></span><br></pre></td></tr></table></figure><p>這樣，我們在使用 Race 型別時，TypeScript 就能記得 human 和 demon，並給出對應的建議。</p><p>值得注意的是，<code>string &amp; &#123;&#125;</code> 實際上和單純的 string 是相同的類型，因此不會影響我們傳入的任何字串：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Hero</span> name=<span class="string">&quot;alice&quot;</span> race=<span class="string">&quot;human&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Hero</span> <span class="attr">name</span>=<span class="string">&quot;mark&quot;</span> <span class="attr">race</span>=<span class="string">&quot;demon&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>這感覺像是在利用 TypeScript 的漏洞。<br>不過，TypeScript 團隊其實是知道這個「技巧」的，他們甚至針對這種情況進行測試。<br>或許將來，TypeScript 會原生支援這樣的功能，但在那之前，這仍是一個實用的小技巧。  </p><p><a href="https://gist.github.com/marsen/9b6f041177d736f36c42a372ff684f66">範例 Code</a></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>總結來說，當你想允許使用者輸入任意字串但又想提供已知字串常值的自動補全建議時，可以考慮使用 <code>string &amp; &#123;&#125;</code> 這個技巧：  </p><p>它防止 TypeScript 過早將 <code>string | &#39;literal&#39;</code> 合併成單純的 string。<br>實際使用時行為與 string 一樣，但會多提供自動補全功能。<br>這或許不是最正式的解法，但目前仍是一個可以信賴的方式。<br>也許未來 TypeScript 能夠原生解決這個問題，但在那之前，這個小技巧可以為開發帶來便利。  </p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近在寫一個 Hero component，需求是讓使用者能指定英雄的種族。&lt;br&gt;我們的設計有一些既定的種族，例如 hum</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [學習筆記] 淺談 TypeScript 方法簡寫與物件屬性語法的差異</title>
    <link href="https://blog.marsen.me/2024/09/26/2024/type_vs_object_method_syntax_typescript/"/>
    <id>https://blog.marsen.me/2024/09/26/2024/type_vs_object_method_syntax_typescript/</id>
    <published>2024-09-26T03:14:58.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在 TypeScript 中，我們常見到兩種方法的定義方式：<br>**方法簡寫語法(Method Shorthand Syntax) 和 物件屬性語法(Object property syntax)**。<br>乍看之下，這兩種語法非常相似，但實際上，Method Shorthand Syntax 在類型檢查上的表現可能會導致潛在的運行時錯誤。<br>本篇將討論這個問題，並提供避免這類錯誤的最佳做法。</p><h2 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h2><p>在 TypeScript 中，我們可以用兩種不同的方式定義物件的方法：</p><p>Method Shorthand Syntax：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">makeSound</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object property syntax：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">makeSound</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兩者表面上似乎只是不同的語法選擇，但實際上，它們在類型檢查時有著不同的行為。<br>當我們使用 Method Shorthand Syntax 時，TypeScript 的類型檢查會出現雙變性（Bivariance），<br>這意味著參數的類型檢查會變得寬鬆，允許接受與定義不完全符合的類型。</p><p>問題例子<br>讓我們看一個新的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">  <span class="title function_">attack</span>(<span class="attr">character</span>: <span class="title class_">Character</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Monster</span> <span class="keyword">extends</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">  <span class="attr">counterattack</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hero</span>: <span class="title class_">Character</span> = &#123;</span><br><span class="line">    <span class="title function_">attack</span>(<span class="params">victim: Monster</span>) &#123;</span><br><span class="line">      <span class="comment">// victim do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">goblin</span>: <span class="title class_">Character</span> = &#123;</span><br><span class="line">    <span class="title function_">attack</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hero.<span class="title function_">attack</span>(goblin); <span class="comment">// 編譯時無錯，運行時錯誤！</span></span><br></pre></td></tr></table></figure><p>在這個例子中，我們有一個 Character 介面和一個繼承它的 Monster 介面。<br>Monster 介面具有一個 counterattack 方法，這表示怪物應該能夠進行反擊。<br>接著，我們定義了一個 hero 物件，它可以攻擊任何 Monster 角色並呼叫它的 counterattack 方法。<br>然而，我們創建了一個 goblin 物件，這個物件實現了 Character 介面，但並不符合 Monster 介面的要求。<br>當我們試圖讓 hero 攻擊 goblin 時，雖然 TypeScript 在編譯時不會報錯，但在運行時會導致錯誤，因為 goblin 並沒有實作 counterattack 方法。<br>這是由於參數類型的雙變性（Bivariance）造成的問題，因為 hero.attack 方法的參數類型過於寬鬆，導致運行時出現預期外的行為。</p><p>解決方案<br>為了解決這個問題，應該使用物件屬性語法來定義方法，這樣 TypeScript 會進行更嚴格的類型檢查，並能在編譯時捕捉到類型不匹配的問題。</p><p>改寫後的範例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">  <span class="attr">attack</span>: <span class="function">(<span class="params">character: Character</span>) =&gt;</span> <span class="built_in">void</span>; <span class="comment">// 改用 Object property syntax</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這裡會報錯，因為 attack 應該傳入的是 Character</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hero</span>: <span class="title class_">Character</span> = &#123;</span><br><span class="line">    <span class="title function_">attack</span>(<span class="params">victim: Monster</span>) &#123;</span><br><span class="line">      <span class="comment">// victim do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在這個改寫後的範例中，TypeScript 會在編譯時警告我們 attack 方法的參數類型不匹配，從而避免了運行時錯誤。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>TypeScript 的類型系統非常強大，但也有一些容易被忽略的陷阱。<br>雙變性可能看似便利，但它也可能導致運行(Runtime)時的錯誤。<br>為了減少這類錯誤的風險，我們應該使用物件屬性語法來定義方法，<br>可以讓 TypeScript 進行更加嚴格的類型檢查，從而在開發過程中及早發現問題。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://www.totaltypescript.com/method-shorthand-syntax-considered-harmful">Method Shorthand Syntax Considered Harmful</a></li><li><a href="https://webmix.cc/tutorials/typescript/%E9%80%B2%E9%9A%8E%E5%9E%8B%E5%88%A5">TypeScript Variance</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在 TypeScript 中，我們常見到兩種方法的定義方式：&lt;br&gt;**方法簡寫語法(Method Shorthand Sy</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [學習筆記] 一些復盤的方法</title>
    <link href="https://blog.marsen.me/2024/09/17/2024/different_FUPAN_ways/"/>
    <id>https://blog.marsen.me/2024/09/17/2024/different_FUPAN_ways/</id>
    <published>2024-09-17T16:25:22.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>吾日三省吾身：為人謀而不忠乎？<br>與朋友交而不信乎？傳不習乎？<br>—論語‧學而</p></blockquote><p>在現代化的管理手段，反省、復盤是一個系統化系統中重要的一環，本文將記錄我所知道一些復盤方法。  </p><h2 id="為什麼要復盤？"><a href="#為什麼要復盤？" class="headerlink" title="為什麼要復盤？"></a>為什麼要復盤？</h2><p>復盤的核心目的是通過回顧和分析過去的行動，提升未來的表現。復盤的主要理由有三個：</p><ol><li>知其然與所以然<br>幫助了解實際情況及其背後的原因，不僅知道「發生了什麼」，還能明白「為什麼會發生」。  </li><li>從錯誤中學習，避免重蹈覆轍，進而提升表現。  </li><li>總結經驗，持續改善;系統化地總結經驗教訓，轉化為改善的具體步驟或方法論。</li></ol><h2 id="經典的復盤方法"><a href="#經典的復盤方法" class="headerlink" title="經典的復盤方法"></a>經典的復盤方法</h2><ol><li><p>PDCA 循環<br>PDCA 是一種持續改進的工具，適用於長期項目和計劃管理。其四個步驟為：  </p><ul><li>Plan（計劃）：設定目標和制定計劃。  </li><li>Do（執行）：實施計劃中的行動。  </li><li>Check（檢查）：檢查實施結果，與計劃進行對比。  </li><li>Act（行動）：根據檢查結果進行改進或調整，進入下一個循環。</li></ul><p>這種方法幫助我們在行動中不斷檢查和調整，達到持續改進的目的。  </p></li><li><p>SMART 目標<br> SMART 是一種設定明確目標的框架，使復盤更具體化。其五個原則為：  </p><ul><li>Specific（具體的）：目標應該明確，針對某一具體領域。  </li><li>Measurable（可衡量的）：確定可量化的指標。  </li><li>Achievable（可達成的）：設定合理且可實現的目標。  </li><li>Relevant（相關的）：確保目標與團隊或個人的發展方向一致。  </li><li>Time-bound（有時限的）：設定明確的時間範圍。</li></ul><p> SMART 方法幫助我們設立清晰且可衡量的目標，使復盤更具方向性和實效性。  </p></li><li><p>GARI 復盤法<br>GARI 是一種結構化的復盤方式，幫助我們從整體回顧、分析到總結經驗教訓。<br>其具體過程如下：</p><ul><li>Goal（回顧目標）：首先回顧當初設定的目標或期望，這有助於明確我們的初衷，為後續的結果分析奠定基礎。</li><li>Result（評估結果）：對比實際結果與當初目標，找出成功的亮點以及不足之處。</li><li>Analysis（分析原因）：深入分析事情成功或失敗的原因，這個過程需要考慮主觀和客觀的因素，例如個人行動、外部環境等。</li><li>Insight（總結規律）：最後，從分析中總結出可供未來參考的經驗和規律，找出更符合本質規律的方法。</li></ul><p>這是一個全面的工具，適合用來結構化地反思和提升，幫助我們在下一次行動中表現得更好</p></li><li><p>KISS 反思法<br>KISS 是一種簡潔有效的反思框架，著眼於具體行動的調整與改進。<br>它分為以下四個部分：</p><p>Keep（需要保持的）：回顧過程中哪些做法是有效的，應繼續保持並發揚光大。<br>Improve（需要改進的）：哪些環節還有提升的空間，並制定具體的改進計劃。<br>Stop（需要停止的）：有哪些不必要或無效的做法，應該果斷停止。<br>Start（需要開始的）：是否有新的嘗試或做法需要納入，以應對未來挑戰。</p><p>KISS 反思法簡明扼要，能夠快速聚焦在關鍵點上，幫助我們更具效率地進行行動調整。</p></li></ol><h2 id="分析法"><a href="#分析法" class="headerlink" title="分析法"></a>分析法</h2><ol><li><p>SWOT 分析<br>SWOT 分析是一種評估內外部環境的工具，幫助識別成功因素和改進空間。其四個要素為：  </p><ul><li>Strengths（優勢）：識別內部的優勢。  </li><li>Weaknesses（劣勢）：了解內部的劣勢。  </li><li>Opportunities（機會）：評估外部可能帶來的機會。  </li><li>Threats（威脅）：分析外部的潛在威脅。<br>這種方法可以幫助我們全面了解內外部環境，制定有效的策略。</li></ul></li><li><p>魚骨圖分析（Ishikawa Diagram）<br>魚骨圖用於分析問題的各種潛在原因，圖形像魚骨，因此得名。其步驟包括：<br>問題作為「魚頭」，根據不同類別（如人員、設備、流程等）畫出「魚刺」。<br>每條「魚刺」代表可能的原因，進行討論分析。<br>這種方法能夠系統化地分析問題的多種可能原因。  </p></li><li><p>德魯克的五個問題(Drucker’s five questions)<br>  這是一種基於商業戰略方法。其問題包括：</p><ul><li>我們的使命是什麼？What is your mission?  </li><li>我們的顧客是誰？Who is your customer?  </li><li>顧客真正重視的是什麼？What does your customer value?  </li><li>我們的成果是什麼？ What results do you seek?  </li><li>我們的計劃是什麼？ What is your plan?<br>有一種說法是上面五個問題可以被濃縮成<strong>我們怎樣满足顧客的需求？</strong></li></ul></li><li><p>5 Why 分析法<br>5 Why 分析法是一種深挖問題根源的方法，通過不斷追問「為什麼」來找到問題的核心原因。其步驟包括：<br>從問題開始，問「為什麼」。<br>每次回答後，再次問「為什麼」，重複五次或直到找到根本原因。<br>這種方法能夠幫助我們深入分析問題的根本原因，避免表面化的解決方案。</p></li></ol><h2 id="其他參考的方法"><a href="#其他參考的方法" class="headerlink" title="其他參考的方法"></a>其他參考的方法</h2><ul><li>AAR（After Action Review）</li><li>KPT（Keep, Problem, Try）</li><li>OKR（Objectives and Key Results）</li></ul><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>復盤能夠幫助我們從過去的行動中汲取智慧，避免重蹈覆轍，並促進持續進步。<br>「學而不思則罔，思而不學則殆」，復盤正是「思」與「學」的結合。<br>前面引言的白話文是：我每天都再三自我反省：替別人做事有沒有盡心竭力？<br>和朋友相處有沒有言而無信？學習到的道理，我有沒有好好認真實踐？  </p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;吾日三省吾身：為人謀而不忠乎？&lt;br&gt;與朋友交而不信乎？傳不習乎？&lt;br&gt;—論語‧學而&lt;/p&gt;
&lt;/blockqu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [實作筆記] Azure Function Queue Trigger 開發(以Python為例) </title>
    <link href="https://blog.marsen.me/2024/09/09/2024/azure_function_developer_with_queue/"/>
    <id>https://blog.marsen.me/2024/09/09/2024/azure_function_developer_with_queue/</id>
    <published>2024-09-09T09:47:01.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>Azure Functions 提供了在雲端執行無伺服器函數的強大能力，<br>但在本地環境中開發和測試這些函數可以大大提高開發效率。<br>為了模擬 Azure Storage 服務，我們可以使用 Azurite，這是一個 Storage 的本地模擬器。<br>本文將記錄我如何在本機上設置建立本機的 Azurite Queue 進行開發。</p><p>註:本文假設你已具備<a href="https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-azure-developer-cli?pivots=programming-language-python&tabs=linux,get,bash,powershell">建立 Azure Functions 的前置基礎</a></p><h2 id="實作記錄"><a href="#實作記錄" class="headerlink" title="實作記錄"></a>實作記錄</h2><h3 id="1-建立和設定本機開發環境"><a href="#1-建立和設定本機開發環境" class="headerlink" title="1. 建立和設定本機開發環境"></a>1. 建立和設定本機開發環境</h3><h4 id="安裝-Azurite"><a href="#安裝-Azurite" class="headerlink" title="安裝 Azurite"></a>安裝 Azurite</h4><p>Azurite 是用於模擬 Azure Storage 服務的本地工具，您可以通過以下命令進行安裝：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g azurite</span><br></pre></td></tr></table></figure><h4 id="啟動-Azurite"><a href="#啟動-Azurite" class="headerlink" title="啟動 Azurite"></a>啟動 Azurite</h4><p>啟動 Azurite 並指定 Storage 位置和日誌文件。</p><p>下面的語法會建立 <code>.azurite</code> 資料夾為 Azurite 的默認資料夾，<br>你可以根據需要修改路徑或刪除並重建此資料夾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">azurite --silent --location ./.azurite --debug ./.azurite/debug.log</span><br></pre></td></tr></table></figure><p>啟動後，你會看到以下輸出，表示 Azurite 成功啟動並監聽相關端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Azurite Blob service is starting at http://127.0.0.1:10000</span><br><span class="line">Azurite Queue service is starting at http://127.0.0.1:10001</span><br><span class="line">Azurite Table service is starting at http://127.0.0.1:10002</span><br></pre></td></tr></table></figure><h4 id="設定本機-Azure-Storage-連線字串"><a href="#設定本機-Azure-Storage-連線字串" class="headerlink" title="設定本機 Azure Storage 連線字串"></a>設定本機 Azure Storage 連線字串</h4><p>為了方便操作本機 Azure Storage，<br>我們需要設置 AZURE_STORAGE_CONNECTION_STRING 環境變數：<br>這裡要查看<a href="https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite?tabs=visual-studio,blob-storage#connect-to-azurite-with-sdks-and-tools">微軟官方文件取得地端連線字串</a><br>你們可以看到它包含了一組 AccountKey 與 Account(devstoreaccount1)<br>這個例子中我們只使用了 Azurite Queue Service  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export AZURE_STORAGE_CONNECTION_STRING=&quot;DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;QueueEndpoint=http://127.0.0.1:10001/devstoreaccount1;&quot;</span><br></pre></td></tr></table></figure><p>開發完成後，記得刪除此連線字串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset AZURE_STORAGE_CONNECTION_STRING</span><br></pre></td></tr></table></figure><h4 id="常用語法"><a href="#常用語法" class="headerlink" title="常用語法"></a>常用語法</h4><p>檢視所有 Queue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az storage queue list</span><br></pre></td></tr></table></figure><p>建立 Local Queue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az storage queue create --name myqueue</span><br></pre></td></tr></table></figure><p>建立資料到指定 Queue 中, 下面的例子會建立一包 JSON 檔，當然你也可以使用純文字(text)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az storage message put --queue-name myqueue --content &quot;&#123;\&quot;message\&quot;: \&quot;Hello, World\!\&quot;, \&quot;id\&quot;: 123, \&quot;status\&quot;: \&quot;active\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure><p>顯示前 5 筆指定 Queue 中的資料</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az storage message peek -q myqueue --num-messages 5</span><br></pre></td></tr></table></figure><p>取出 Queue 中的資料</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az storage message get --queue-name myqueue --num-messages 1</span><br></pre></td></tr></table></figure><p>刪除 Queue 中的資料</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az storage message delete --queue-name myqueue --id &lt;message-id&gt; --pop-receipt &lt;pop-receipt&gt;</span><br></pre></td></tr></table></figure><p>補充說明:</p><p>popReceipt 是 Azure Queue 中用來確認消息取出和刪除操作的唯一識別碼。<br>當取出消息時，Azure 會返回 popReceipt，確保只有取出的客戶端能夠刪除該消息。<br>如果 popReceipt 顯示為 null，通常表示消息尚未取出或命令不正確。<br>要獲取 popReceipt，使用 az storage message get 命令取出訊息。</p><h3 id="2-Azure-Functions-的本機開發與執行"><a href="#2-Azure-Functions-的本機開發與執行" class="headerlink" title="2. Azure Functions 的本機開發與執行"></a>2. Azure Functions 的本機開發與執行</h3><p>啟動 Azure Functions</p><p>當本機環境設置完成後，你可以使用以下命令來啟動 Azure Functions：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func start</span><br></pre></td></tr></table></figure><p>這條命令會啟動你的本地 Azure Functions 執行環境，使你可以在本機上測試和調試你的函數。</p><h3 id="3-加碼，代碼檢查和格式化"><a href="#3-加碼，代碼檢查和格式化" class="headerlink" title="3. 加碼，代碼檢查和格式化"></a>3. 加碼，代碼檢查和格式化</h3><h4 id="安裝與配置-Pylint"><a href="#安裝與配置-Pylint" class="headerlink" title="安裝與配置 Pylint"></a>安裝與配置 Pylint</h4><p>Pylint 是一個 Python 代碼靜態分析工具，可以檢查代碼中的錯誤和不符合最佳實踐的地方。首先，安裝 Pylint：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pylint</span><br></pre></td></tr></table></figure><p>配置 Pylint，創建或修改 .pylintrc 文件來包含你的檢查規則：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[MESSAGES CONTROL]</span><br><span class="line">disable=C0114,C0115,C0116</span><br><span class="line"></span><br><span class="line">[FORMAT]</span><br><span class="line">max-line-length=120</span><br></pre></td></tr></table></figure><p>使用 Pylint 進行代碼檢查</p><p>運行以下命令來檢查所有 Python 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pylint *.py</span><br></pre></td></tr></table></figure><h4 id="安裝與使用-Black-進行代碼格式化"><a href="#安裝與使用-Black-進行代碼格式化" class="headerlink" title="安裝與使用 Black 進行代碼格式化"></a>安裝與使用 Black 進行代碼格式化</h4><p>Black 是一個自動格式化 Python 代碼的工具，能夠保持代碼風格的一致性。首先，安裝 Black：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install black</span><br></pre></td></tr></table></figure><p>格式化整個專案的所有 Python 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">black .</span><br></pre></td></tr></table></figure><p>整合檢查和格式化工具</p><p>你可以將代碼檢查和格式化工具整合到一個命令中，這樣可以簡化工作流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pylint *.py &amp;&amp; black .</span><br></pre></td></tr></table></figure><h4 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h4><p>在 Azure Functions 中，某些函數參數不符合 Pylint 的命名規則，這可能會導致部署失敗。你可以忽略這些特定的 Pylint 警告，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pylint: disable=C0103</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dispatch_worker</span>(<span class="params">inputQueue: func.QueueMessage, watchQueue: func.Out[<span class="built_in">str</span>]</span>):</span><br></pre></td></tr></table></figure><h2 id="問題與排除"><a href="#問題與排除" class="headerlink" title="問題與排除"></a>問題與排除</h2><ul><li>如果 Azurite 無法啟動，請檢查是否已正確安裝 Azurite 以及是否有其他應用程序佔用了相關端口。</li><li>如果 Azure Functions 無法啟動，請確保所有相關的配置文件和依賴項已正確設置。</li></ul><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://github.com/Azure/Azurite">Azurite 官方文檔</a></li><li><a href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=macos,isolated-process,node-v4,python-v2,http-trigger,container-apps&pivots=programming-language-python">Azure Functions 本地開發指南</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;Azure Functions 提供了在雲端執行無伺服器函數的強大能力，&lt;br&gt;但在本地環境中開發和測試這些函數可以大大提高</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [踩雷筆記] Gitlab 整合 Azure DevOps Pipeline 以 python on Azure Functions 為例</title>
    <link href="https://blog.marsen.me/2024/08/13/2024/azure_function_python_deploy_with_devops_pipeline/"/>
    <id>https://blog.marsen.me/2024/08/13/2024/azure_function_python_deploy_with_devops_pipeline/</id>
    <published>2024-08-13T03:17:42.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>我目前主要使用 GitLab 進行版本控制和持續集成(CI&#x2F;CD)，<br>主要整合 Google Cloud Platform (GCP) ，許多專案都運行在 GCP 上。<br>因商務需求最近開始探索第二朵雲 Azure。<br>雖然 Azure DevOps 也有提供 CI／CD 與 Repo 的解決方案;<br>但為了減少邏輯與認知負擔，我希望能將 GitLab 與 Azure DevOps Pipeline 進行整合。<br>具體來說，這次要在 Azure Functions 上部署 Python 應用程式，<br>我想要 RD 往 Gitlab 推送並執行 CI&#x2F;CD 就好，而不用特別因為服務在不同的雲上，而需要推送到不到同 Repo 中 。<br>面對這樣的需求，下面是我找到的解決方案。  </p><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>以這次的例子來說，我需要控管 Azure 的 Serverless 解決方案「Azure Functions」的程式。<br>但是 Azure DevOps Pipeline 有相當高度的整合 Azure Cloud，只要能將程式推送到 Azure DevOps Repo，<br>部署就會相當簡單，<strong>而無需處理繁鎖的授權問題</strong>。<br>CI／CD 流程大致如下</p><ul><li>建立相對應的權限與憑証並提供給 Gitlab-Runner</li><li>RD 推送新版本程式給 Gitlab，觸發 Gitlab-Runner</li><li>Gitlab-Runner 執行測試、建置等相關作業後，部署到 Azure Functions</li></ul><ol><li><p><strong>設置 Azure DevOps Pipeline</strong>：</p><ol><li>選擇 New pipeline</li><li>Other Git</li><li>設定連線方式 &amp; 選擇分支<ol><li>Connection name (任意命名)</li><li>Repo URL 輸入 Gitlab Repo URL</li><li>User Name (任意命名)</li><li>Password &#x2F; Token Key (Gitlab PAT，需注意效期)</li></ol></li><li>使用「Azure Functions for Python」Template<ul><li>Build extensions</li><li>Use Python 3.10(可以更換合適的版本)</li><li>Install Application Dependencies</li><li>Archive files</li><li>Publish Artifact: drop</li></ul></li><li>追加 Agent job Task<ul><li>搜尋「Azure Functions Deploy」</li><li>填寫<ul><li>Azure Resource Manager connection<ul><li>Manage &gt; Service Connection &gt; New Service Connection &gt; Azure Resource Manager &gt; Service principal(automatic)<ul><li>Service connection name</li><li>Description (optional)</li></ul></li><li>也可以選擇 &gt; Service principal (manual)，需要先加上 App registrations 具體流程如下：<ul><li>在 Azure Portal 上建立一個新的 Azure Registration。</li><li>選擇 Certificates &amp; secrets，建立一組 Certificates &amp; secrets。</li><li>回到 Service principal (manual)<ul><li>Subscription Id</li><li>Subscription Name</li><li>Service Principal Id (App registrations Client secrets 的 Secret ID)</li><li>Service principal key (App registrations Client secrets 的　Value)</li><li>Tenant ID</li></ul></li></ul></li></ul></li><li>App type (我的情況是選 Function App on Linux)</li><li>Azure Functions App name</li></ul></li></ul></li></ol></li><li><p><strong>配置 GitLab CI&#x2F;CD</strong>：</p><ul><li>在 GitLab 中，建立 <code>.gitlab-ci.yml</code> 如下：</li></ul> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">debian:stable-slim</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">AZURE_PIPELINE_NAME:</span> <span class="string">&quot;dispatch-worker-deploy-pipeline&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apt-get</span> <span class="string">update</span> <span class="string">&amp;&amp;</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">-y</span> <span class="string">curl</span> <span class="string">jq</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">trigger_pipeline:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">      json=$(curl -u $AZURE_DEVOPS_USER:$AZURE_DEVOPS_PAT \</span></span><br><span class="line"><span class="string">        -H &quot;Content-Type: application/json&quot; \</span></span><br><span class="line"><span class="string">        &quot;https://dev.azure.com/Aiplux/Inpas/_apis/build/definitions?api-version=6.0&quot;)</span></span><br><span class="line"><span class="string">      id=$(echo $json | jq -r --arg pipeline_name &quot;$AZURE_PIPELINE_NAME&quot; &#x27;.value[] | select(.name==$pipeline_name) | .id&#x27;)</span></span><br><span class="line"><span class="string">      echo -e &quot;\033[1;33mPipeline: $AZURE_PIPELINE_NAME ID is $id\033[0m&quot;</span></span><br><span class="line"><span class="string">      RESPONSE_CODE=$(curl -X POST &quot;https://dev.azure.com/My_Organization/My_Project/_apis/build/builds?api-version=6.0&quot; \</span></span><br><span class="line"><span class="string">        --data &#x27;&#123;&quot;definition&quot;: &#123;&quot;id&quot;: &#x27;$id&#x27;&#125;&#125;&#x27; \</span></span><br><span class="line"><span class="string">        -u $&#123;AZURE_DEVOPS_USER&#125;:$&#123;AZURE_DEVOPS_PAT&#125; \</span></span><br><span class="line"><span class="string">        -H &#x27;Content-Type: application/json&#x27; \</span></span><br><span class="line"><span class="string">        -w &quot;%&#123;http_code&#125;&quot; -o /dev/null -s)</span></span><br><span class="line"><span class="string">      if [ &quot;$RESPONSE_CODE&quot; -ne 200 ]; then</span></span><br><span class="line"><span class="string">        echo -e &quot;\033[1;31mRequest failed with status code $RESPONSE_CODE\033[0m&quot;</span></span><br><span class="line"><span class="string">        exit 1</span></span><br><span class="line"><span class="string">      fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">&#x27;$CI_COMMIT_BRANCH == &quot;main&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p> 可以看到 AZURE_DEVOPS_USER 與 AZURE_DEVOPS_PAT 兩個參數,<br> 可以在登入 Azure DevOps 後，在 User Settings &gt;&gt; Personal Access Tokens 取得,<br> 實務上由管理者提供，但是有時效性，仍然需要定期更新（１年），應該有更簡便的方法才對。</p></li></ol><p>完成以上的設定後，只要推送到 Gitlab Repo 的 main 分支，就會觸發 Azure DevOps Pipeline 部署。</p><h2 id="踩雷"><a href="#踩雷" class="headerlink" title="踩雷"></a>踩雷</h2><p>在整合過程中遇到了一個問題。<br>儘管使用了 Azure Pipeline 提供的官方模板，部署過程依然出現了錯誤。<br>具體而言並沒有明顯的錯誤，但是 Log 會記錄</p><blockquote><p><strong>1 function found</strong><br><strong>0 function loaded</strong></p></blockquote><p>導致 Azure Functions Apps 無法正常工作。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p><a href="https://github.com/Azure/azure-functions-python-worker/issues/708#issuecomment-765528255">參考</a></p><p>在 Azure Functions for Python 其中一步驟　Install Application Dependencies<br>Template 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python3.6 -m venv worker_venv</span><br><span class="line">source worker_venv/bin/activate</span><br><span class="line">pip3.6 install setuptools</span><br><span class="line">pip3.6 install -r requirements.txt</span><br></pre></td></tr></table></figure><p>需要修改成才能作用，不確定 Azure 會不會提出修正或新的 template</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python3.10 -m venv .python_packages</span><br><span class="line">source .python_packages/bin/activate</span><br><span class="line">pip3.10 install setuptools</span><br><span class="line">pip3.10 install --target=&quot;./.python_packages/lib/site-packages&quot; -r ./requirements.txt</span><br></pre></td></tr></table></figure><p>查閱了 Azure 和 GitLab 的官方文檔以及技術社群中的討論，找到了有效的解決方案。<br>通過修改 template，成功解決了部署問題，<br>GitLab 和 Azure DevOps Pipeline 的整合成功。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://github.com/Azure/azure-functions-python-worker/issues/708#issuecomment-765528255">ModuleNotFoundError when using DevOps Pipeline Task AzureFunctionApp@1</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;我目前主要使用 GitLab 進行版本控制和持續集成(CI&amp;#x2F;CD)，&lt;br&gt;主要整合 Google Cloud P</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [踩雷筆記] Azure Function 開關虛擬機與錯誤排除</title>
    <link href="https://blog.marsen.me/2024/08/12/2024/azure_function_toggle_virtual_machine/"/>
    <id>https://blog.marsen.me/2024/08/12/2024/azure_function_toggle_virtual_machine/</id>
    <published>2024-08-12T06:09:10.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在 Azure Functions 和 Queue 的架構下，我們試圖通過自動化開關虛擬機器來節省成本。　　<br>這是因為 GPU 設備的價格相當高昂，而我們的 AI 服務又離不開這些昂貴的機器。</p><h2 id="實作記錄"><a href="#實作記錄" class="headerlink" title="實作記錄"></a>實作記錄</h2><p>最初的構想非常簡單：通過 Queue 接收特定的任務，然後由 Azure Function 判斷需要哪些資源，<br>如果需要進行 AI 計算，就必須啟動特定的虛擬機器，而在任務完成後，再將機器關閉。<br>這樣的方式不僅能夠節省資源，還能有效控制成本。</p><p>以下是 Python 程式碼的大致實作，主要為虛擬機器的開關控制邏輯：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> azure.functions <span class="keyword">as</span> func</span><br><span class="line"><span class="keyword">from</span> azure.identity <span class="keyword">import</span> DefaultAzureCredential</span><br><span class="line"><span class="keyword">from</span> azure.mgmt.compute <span class="keyword">import</span> ComputeManagementClient</span><br><span class="line"><span class="keyword">import</span> logging, os</span><br><span class="line"></span><br><span class="line">app = func.FunctionApp()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.queue_trigger(<span class="params">arg_name=<span class="string">&quot;args&quot;</span>, queue_name=<span class="string">&quot;vm-queue&quot;</span>, connection=<span class="string">&quot;CONNECTION_STRING&quot;</span></span>) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args: func.QueueMessage</span>):</span><br><span class="line">    logging.info(<span class="string">&#x27;Queue Msg: %s&#x27;</span>, args.get_body().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        credential = DefaultAzureCredential()</span><br><span class="line">        subscription_id = os.getenv(<span class="string">&quot;SUBSCRIPTION&quot;</span>)</span><br><span class="line">        resource_group = os.getenv(<span class="string">&quot;RG&quot;</span>)</span><br><span class="line">        vm_name = os.getenv(<span class="string">&quot;VM_NAME&quot;</span>)</span><br><span class="line"></span><br><span class="line">        compute_client = ComputeManagementClient(credential, subscription_id)</span><br><span class="line">        vm = compute_client.virtual_machines.get(resource_group, vm_name, expand=<span class="string">&#x27;instanceView&#x27;</span>)</span><br><span class="line">        vm_status = vm.instance_view.statuses[<span class="number">1</span>].display_status</span><br><span class="line">        logging.info(<span class="string">&#x27;VM 狀態: %s&#x27;</span>, vm_status)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> vm_status == <span class="string">&quot;VM running&quot;</span>:</span><br><span class="line">            logging.info(<span class="string">&#x27;正在關閉VM: %s&#x27;</span>, vm_name)</span><br><span class="line">            operation = compute_client.virtual_machines.begin_deallocate(resource_group, vm_name)</span><br><span class="line">            operation.result()</span><br><span class="line">            logging.info(<span class="string">&#x27;%s 已關閉&#x27;</span>, vm_name)</span><br><span class="line">        <span class="keyword">elif</span> vm_status <span class="keyword">in</span> [<span class="string">&quot;VM deallocated&quot;</span>, <span class="string">&quot;VM stopped&quot;</span>]:</span><br><span class="line">            logging.info(<span class="string">&#x27;正在啟動VM: %s&#x27;</span>, vm_name)</span><br><span class="line">            operation = compute_client.virtual_machines.begin_start(resource_group, vm_name)</span><br><span class="line">            operation.result()</span><br><span class="line">            logging.info(<span class="string">&#x27;VM %s 已啟動&#x27;</span>, vm_name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logging.info(<span class="string">&#x27;非預期的 VM 狀態: %s&#x27;</span>, vm_status)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">&#x27;異常錯誤: %s&#x27;</span>, <span class="built_in">str</span>(e))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="異常問題-EnvironmentCredential"><a href="#異常問題-EnvironmentCredential" class="headerlink" title="異常問題:EnvironmentCredential"></a>異常問題:EnvironmentCredential</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultAzureCredential failed to retrieve a token from the included credentials.</span><br><span class="line">Attempted credentials:</span><br><span class="line"> EnvironmentCredential: EnvironmentCredential authentication unavailable. Environment variables are not fully configured.</span><br><span class="line">Visit https://aka.ms/azsdk/python/identity/environmentcredential/troubleshoot to troubleshoot this issue.</span><br><span class="line"> ManagedIdentityCredential: ManagedIdentityCredential authentication unavailable, no response from the IMDS endpoint.</span><br><span class="line"> SharedTokenCacheCredential: SharedTokenCacheCredential authentication unavailable. No accounts were found in the cache.</span><br><span class="line"> AzureCliCredential: Azure CLI not found on path</span><br><span class="line"> AzurePowerShellCredential: PowerShell is not installed</span><br><span class="line"> AzureDeveloperCliCredential: Azure Developer CLI could not be found. Please visit https://aka.ms/azure-dev for installation instructions and then,once installed, authenticate to your Azure account using &#x27;azd auth login&#x27;.</span><br><span class="line">To mitigate this issue, please refer to the troubleshooting guidelines here at https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.</span><br></pre></td></tr></table></figure><p><strong>這個問題表面上看似由於權限不足引起的，但實際上根本原因是缺乏正確的環境變數配置。</strong><br>要使 Azure Function 能夠正常運作並獲得所需的權限，我們需要在 Function 的環境設置中正確配置相應的環境變數。<br>這些環境變數包括關鍵的憑證和授權信息，它們使得 Azure Function 能夠在執行過程中獲取必要的存取權限，從而能夠正常與 Azure 資源進行交互。<br>如果環境變數配置不當或缺失，Azure Function 將無法獲得所需的授權，從而導致權限不足的錯誤。<br>確保這些環境變數被正確設置和管理，是解決此類問題的關鍵步驟</p><p>配置的方式有三種</p><h4 id="如果要使用-Service-Principal-的-Client-Secret，配置"><a href="#如果要使用-Service-Principal-的-Client-Secret，配置" class="headerlink" title="如果要使用 Service Principal 的 Client Secret，配置"></a>如果要使用 Service Principal 的 Client Secret，配置</h4><ul><li>AZURE_CLIENT_ID</li><li>AZURE_TENANT_ID</li><li>AZURE_CLIENT_SECRET</li></ul><h4 id="如果要使用-Service-Principal-的-Certificate-驗證，配置"><a href="#如果要使用-Service-Principal-的-Certificate-驗證，配置" class="headerlink" title="如果要使用 Service Principal 的　Certificate 驗證，配置"></a>如果要使用 Service Principal 的　Certificate 驗證，配置</h4><ul><li>AZURE_CLIENT_ID</li><li>AZURE_TENANT_ID</li><li>AZURE_CLIENT_CERTIFICATE_PATH</li><li>AZURE_CLIENT_CERTIFICATE_PASSWORD (Optional)</li></ul><h4 id="若要使用密碼進行用戶身份驗證，配置"><a href="#若要使用密碼進行用戶身份驗證，配置" class="headerlink" title="若要使用密碼進行用戶身份驗證，配置"></a>若要使用密碼進行用戶身份驗證，配置</h4><ul><li>AZURE_USERNAME</li><li>AZURE_PASSWORD</li></ul><p>我選擇第一種配置，需要先加上 App registrations<br>具體流程如下：</p><ul><li>在 Azure Portal 上建立一個新的 Azure Registration。  </li><li>選擇 Certificates &amp; secrets，建立一組 Certificates &amp; secrets。  </li><li>到 Azure Function　Apps 設定環境變數 AZURE_CLIENT_ID 與　AZURE_CLIENT_SECRET,  </li><li>Tenant_ID 可以在透過 Azure Portal 找 Tenant Properties 查詢，一樣設定到環境變數。  </li><li>接下來將 Registration 設定為 Virtual Machine 的 Contributor<br>(待確認開關機是不是有更小的權限？ex:Virtual Machine Contributor、Virtual Machine Operator：)</li></ul><p>如此一來在開關機時就能有足夠的權限。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://aka.ms/azsdk/python/identity/environmentcredential/troubleshoot">https://aka.ms/azsdk/python/identity/environmentcredential/troubleshoot</a></li><li><a href="https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/identity/azure-identity/TROUBLESHOOTING.md#troubleshoot-environmentcredential-authentication-issues">https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/identity/azure-identity/TROUBLESHOOTING.md#troubleshoot-environmentcredential-authentication-issues</a></li><li><a href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-overview?pivots=programming-language-csharp">https://learn.microsoft.com/en-us/azure/azure-functions/functions-overview?pivots=programming-language-csharp</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在 Azure Functions 和 Queue 的架構下，我們試圖通過自動化開關虛擬機器來節省成本。　　&lt;br&gt;這是因為</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [學習筆記] SQL 軟刪除與索引 (MySQL/MSSQL/PostgreSQL)</title>
    <link href="https://blog.marsen.me/2024/08/05/2024/mysql_partial_index_and_soft_delete/"/>
    <id>https://blog.marsen.me/2024/08/05/2024/mysql_partial_index_and_soft_delete/</id>
    <published>2024-08-05T05:53:10.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近需要實現軟刪除功能，但在設計索引時遇到了一些問題。<br>商務情境如下，<br>有效的 ACCOUNT 必須是唯一的。<br>然而，帳戶有可能會被軟刪除，所以被刪除的 Account 可能會有多筆相同的資料。  </p><h3 id="表格設計"><a href="#表格設計" class="headerlink" title="表格設計"></a>表格設計</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">User</span> (</span><br><span class="line">    Id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Username <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    IsDeleted <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>簡化設計的用戶表格包含 Id、Username 和 IsDeleted 欄位。<br>依商業需求，當 IsDeleted 為 0 時，Username 必須唯一。<br>而且很有可能會有多筆相同的帳號被刪除，當 IsDeleted 為 1 時，Account 不會限制只有一筆（允許多筆）</p><p>後端工程師建議使用觸發器（Trigger）或在應用層（Backend）實現這個約束，<br>根據我的記憶，在微軟的 SQL Server 中，有一種稱為「條件約束」的設定，能夠針對特定條件創建索引。<br>可以大幅節省開發成本，我認為這類的功能不應該只有微軟專有，故作了一些搜尋後，特別以此篇記錄。</p><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>我找到一個測試的<a href="https://sqlfiddle.com/">網站</a>，你可以直接在這裡測試，不需要花費額外心力建立 SQL Server</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 創建表格</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Users (</span><br><span class="line">    Id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Username <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    IsDeleted <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 設置 AUTO_INCREMENT 起始值為 1000</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Users AUTO_INCREMENT <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 創建唯一索引，只針對 IsDeleted = FALSE 的行</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX unique_active_account <span class="keyword">ON</span> Users ((<span class="keyword">CASE</span> <span class="keyword">WHEN</span> IsDeleted <span class="keyword">THEN</span> Username <span class="keyword">END</span>));</span><br><span class="line"><span class="comment">-- 插入數據</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="literal">FALSE</span>);  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user2&#x27;</span>, <span class="literal">FALSE</span>);  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user3&#x27;</span>, <span class="literal">TRUE</span>);   <span class="comment">-- 成功，因為 IsDeleted = TRUE 不受唯一索引限制</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user4&#x27;</span>, <span class="literal">FALSE</span>);  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user5&#x27;</span>, <span class="literal">TRUE</span>);   <span class="comment">-- 成功，因為 IsDeleted = TRUE 不受唯一索引限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 測試重複的 Username 插入，應該失敗</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="literal">FALSE</span>);  <span class="comment">-- 失敗，因為 user1 已經存在且 IsDeleted = FALSE</span></span><br><span class="line"><span class="comment">-- 測試重複的 Username 插入，但 IsDeleted = TRUE，應該成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="literal">TRUE</span>);   <span class="comment">-- 成功，因為 IsDeleted = TRUE 不受唯一索引限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 檢查插入結果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Users;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 創建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Users (</span><br><span class="line">    Id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Username <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    IsDeleted <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> SEQUENCE users_id_seq RESTART <span class="keyword">WITH</span> <span class="number">1000</span>;</span><br><span class="line"><span class="comment">-- 創建部分索引，只針對 IsDeleted = FALSE 的行</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX unique_active_username <span class="keyword">ON</span> Users (Username)</span><br><span class="line"><span class="keyword">WHERE</span> IsDeleted <span class="operator">=</span> <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入範例數據</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="literal">FALSE</span>);  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user2&#x27;</span>, <span class="literal">FALSE</span>);  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user3&#x27;</span>, <span class="literal">TRUE</span>);   <span class="comment">-- 成功，因為 IsDeleted = TRUE 不受唯一索引限制</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user4&#x27;</span>, <span class="literal">FALSE</span>);  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user5&#x27;</span>, <span class="literal">TRUE</span>);   <span class="comment">-- 成功，因為 IsDeleted = TRUE 不受唯一索引限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 測試重複的 Username 插入，應該失敗</span></span><br><span class="line"><span class="comment">-- INSERT INTO Users (Username, IsDeleted) VALUES (&#x27;user1&#x27;, FALSE);  -- 失敗，因為 user1 已經存在且 IsDeleted = FALSE</span></span><br><span class="line"><span class="comment">-- 測試重複的 Username 插入，但 IsDeleted = TRUE，應該成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Users (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="literal">TRUE</span>);   <span class="comment">-- 成功，因為 IsDeleted = TRUE 不受唯一索引限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 檢查插入結果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Users;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MSSQL"><a href="#MSSQL" class="headerlink" title="MSSQL"></a>MSSQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 設置正確的 SET 選項</span></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">SET</span> ANSI_NULLS <span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 創建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">User</span>] (</span><br><span class="line">    Id <span class="type">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1000</span>, <span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Username <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    IsDeleted BIT <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 創建篩選唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX unique_active_account <span class="keyword">ON</span> [<span class="keyword">User</span>](Username)</span><br><span class="line"><span class="keyword">WHERE</span> IsDeleted <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入範例數據</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">User</span>] (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="number">0</span>);  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">User</span>] (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user2&#x27;</span>, <span class="number">0</span>);  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">User</span>] (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user3&#x27;</span>, <span class="number">1</span>);  <span class="comment">-- 成功，因為 IsDeleted = 1 不受唯一索引限制</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">User</span>] (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user4&#x27;</span>, <span class="number">0</span>);  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">User</span>] (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user5&#x27;</span>, <span class="number">1</span>);  <span class="comment">-- 成功，因為 IsDeleted = 1 不受唯一索引限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 測試重複的 Username 插入，應該失敗</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">User</span>] (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="number">0</span>);  <span class="comment">-- 失敗，因為 user1 已經存在且 IsDeleted = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 測試重複的 Username 插入，但 IsDeleted = 1，應該成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">User</span>] (Username, IsDeleted) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="number">1</span>);  <span class="comment">-- 成功，因為 IsDeleted = 1 不受唯一索引限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 檢查插入結果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> [<span class="keyword">User</span>];</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>不太需要複雜的後端程式或是 DB Trigger，只需要在建立索引時加上條件，<br>特別注意 MySQL 的語法是使用 CASE WHEN，其他 DB 是使用 WHERE，<br>這與 DB 版本也有關係，使用前應該進一步去查詢官方文件。</p><p>另外關於遞增欄位，在不同的 DB 也有不同的實作方式。<br>實務上通常不用了解這麼多 DB 的差異，僅僅是我個人的好奇補充罷了,<br>業界主推還是 PostgreSQL，我個人不夠專業，但三種都略有碰過，最熟的還是 MSSQL。<br>僅為個人學習記錄，如果要在三者中擇一還是需要多方考慮自身的 Context 再作決定。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://learn.microsoft.com/zh-tw/sql/relational-databases/tables/unique-constraints-and-check-constraints?view=sql-server-ver16">MSSQL 唯一條件約束及檢查條件約束</a></li><li><a href="https://sqlfiddle.com/">SQL Fiddle</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近需要實現軟刪除功能，但在設計索引時遇到了一些問題。&lt;br&gt;商務情境如下，&lt;br&gt;有效的 ACCOUNT 必須是唯一的。&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [實作筆記] Bash 輸出彩色技巧</title>
    <link href="https://blog.marsen.me/2024/08/01/2024/bash_color/"/>
    <id>https://blog.marsen.me/2024/08/01/2024/bash_color/</id>
    <published>2024-08-01T02:25:21.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在 Bash 腳本中，有時我需要以提高日誌的可讀性或突顯重要資訊。<br>通過 ANSI escape codes 改變文本的顏色、背景顏色和樣式。<br>可以讓腳本的輸出更加直觀且友善。</p><h2 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h2><p>在 Bash 中，我們可以使用 ANSI escape codes 來實現文本的高亮顯示和顏色選擇。<br>以下是一些常見的 ANSI 顏色碼：</p><h3 id="前景顏色"><a href="#前景顏色" class="headerlink" title="前景顏色"></a>前景顏色</h3><ul><li><strong>黑色</strong>： <code>\033[30m</code></li><li><strong>紅色</strong>： <code>\033[31m</code></li><li><strong>綠色</strong>： <code>\033[32m</code></li><li><strong>黃色</strong>： <code>\033[33m</code></li><li><strong>藍色</strong>： <code>\033[34m</code></li><li><strong>洋紅色</strong>： <code>\033[35m</code></li><li><strong>青色</strong>： <code>\033[36m</code></li><li><strong>白色</strong>： <code>\033[37m</code></li></ul><h3 id="背景顏色"><a href="#背景顏色" class="headerlink" title="背景顏色"></a>背景顏色</h3><ul><li><strong>黑色</strong>： <code>\033[40m</code></li><li><strong>紅色</strong>： <code>\033[41m</code></li><li><strong>綠色</strong>： <code>\033[42m</code></li><li><strong>黃色</strong>： <code>\033[43m</code></li><li><strong>藍色</strong>： <code>\033[44m</code></li><li><strong>洋紅色</strong>： <code>\033[45m</code></li><li><strong>青色</strong>： <code>\033[46m</code></li><li><strong>白色</strong>： <code>\033[47m</code></li></ul><h3 id="樣式"><a href="#樣式" class="headerlink" title="樣式"></a>樣式</h3><ul><li><strong>粗體</strong>： <code>\033[1m</code></li><li><strong>下劃線</strong>： <code>\033[4m</code></li><li><strong>反向</strong>： <code>\033[7m</code></li><li><strong>重置</strong>： <code>\033[0m</code></li></ul><p>透過這些代碼，你可以靈活地控制文本的外觀。例如，使用 <code>\033[1;31m</code> 可以讓文本變為紅色粗體，使用 <code>\033[0m</code> 可以重置樣式回到預設。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面是如何使用這些顏色碼來高亮顯示 <code>echo</code> 輸出的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[1;31m這是一段紅色粗體文本\033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32m這是一段綠色粗體文本\033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[1;33m這是一段黃色粗體文本\033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[1;34m這是一段藍色粗體文本\033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[1;35m這是一段洋紅色粗體文本\033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[1;36m這是一段青色粗體文本\033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[1;37m這是一段白色粗體文本\033[0m&quot;</span></span><br></pre></td></tr></table></figure><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes - Wikipedia</a></p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在 Bash 腳本中，有時我需要以提高日誌的可讀性或突顯重要資訊。&lt;br&gt;通過 ANSI escape codes 改變文本</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] 初體驗設定 Nvidia GPU 的 Azure VM -- 錯誤排除</title>
    <link href="https://blog.marsen.me/2024/07/30/2024/azure_virtual_machine_for_nvidia_error_records/"/>
    <id>https://blog.marsen.me/2024/07/30/2024/azure_virtual_machine_for_nvidia_error_records/</id>
    <published>2024-07-30T09:10:59.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>RD 們反應因為 Driver 更新導致服務異常，停止運作。<br>重新安裝時又遇到一些奇怪的問題，例如：<br>錯誤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y linux-modules-nvidia-550-azure nvidia-driver-550</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package linux-modules-nvidia-550-azure</span><br></pre></td></tr></table></figure><p>或是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Failed to initialize NVML: Driver/library version mismatch</span><br><span class="line">NVML library version: 535.183</span><br></pre></td></tr></table></figure><p>依實際狀況與 RD 討論，發現他們沒有一個標準的作業程序，調研時也沒有任何記錄，<br>東作一塊，西作一塊，沒有辦法很清楚了交互的作用關係。<br>故由我重新實作一遍，記錄並排除相關錯誤。  </p><h2 id="實作記錄"><a href="#實作記錄" class="headerlink" title="實作記錄"></a>實作記錄</h2><ol><li><p>Azure 開機，指定作業系統為 Ubuntu 22.04，並且需注意 A100 系列機器只在特定的 Zone 才有資源開機，本次使用東日本 zone2 的資源</p></li><li><p>安裝 CUDA,　<a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#ubuntu">參考官方文件 <strong>3.9. Ubuntu</strong></a></p></li><li><p>安裝 ubuntu-drivers-common</p><ul><li><code>sudo apt install ubuntu-drivers-common</code></li><li><code>sudo apt install alsa-utils</code> #音效相關，不一定要裝，但是可以減少指令時的錯誤訊息</li><li><code>ubuntu-drivers device</code></li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ubuntu-drivers devices</span><br><span class="line">== /sys/devices/LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/VMBUS:00/00000041-0001-0000-3130-444532304235/pci0001:00/0001:00:00.0 ==</span><br><span class="line">modalias : pci:v000010DEd000020B5sv000010DEsd00001533bc03sc02i00</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">driver   : nvidia-driver-555-open - third-party non-free</span><br><span class="line">driver   : nvidia-driver-470-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-535-server-open - distro non-free</span><br><span class="line">driver   : nvidia-driver-555 - third-party non-free recommended</span><br><span class="line">driver   : nvidia-driver-535-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-470 - distro non-free</span><br><span class="line">driver   : nvidia-driver-550 - third-party non-free</span><br><span class="line">driver   : nvidia-driver-550-open - third-party non-free</span><br><span class="line">driver   : nvidia-driver-535-open - distro non-free</span><br><span class="line">driver   : nvidia-driver-545-open - third-party non-free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure></li><li><p>更新套件</p><ol><li>加上drivers的 repo 路徑<blockquote><p><code>sudo add-apt-repository ppa:graphics-drivers/ppa</code></p></blockquote></li><li>更新<blockquote><p><code>sudo apt update</code></p></blockquote></li><li>安裝趨動, 讓系統自已判斷安裝什麼版本, 參考 <a href="https://ubuntu.com/server/docs/nvidia-drivers-installation">NVIDIA drivers installation | Ubuntu</a><blockquote><p><code>sudo ubuntu-drivers install</code></p></blockquote></li><li>重開機<blockquote><p><code>sudo reboot</code></p></blockquote></li><li>查一下，他幫你裝哪個版本<blockquote><p><code>dpkg -l | grep nvidia-driver</code></p></blockquote></li><li>再安裝指定版本的 Ubuntu Azure Package，也可以至 <a href="https://packages.ubuntu.com/focal/kernel/">Ubuntu 網站</a> 搜尋確認<blockquote><p><code>sudo apt install -y linux-modules-nvidia-&lt;version&gt;-azure</code></p></blockquote></li></ol></li></ol><h3 id="確認是否成功"><a href="#確認是否成功" class="headerlink" title="確認是否成功"></a>確認是否成功</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>　看到下面的畫面就是成功</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ nvidia-smi</span><br><span class="line">Tue Jul 30 08:07:18 2024</span><br><span class="line">+-----------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 550.90.07              Driver Version: 550.90.07      CUDA Version: 12.4     |</span><br><span class="line">|-----------------------------------------+------------------------+----------------------+</span><br><span class="line">| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                                         |                        |               MIG M. |</span><br><span class="line">|=========================================+========================+======================|</span><br><span class="line">|   0  NVIDIA A100 80GB PCIe          Off |   00000001:00:00.0 Off |                    0 |</span><br><span class="line">| N/A   32C    P0             43W /  300W |       1MiB /  81920MiB |      0%      Default |</span><br><span class="line">|                                         |                        |             Disabled |</span><br><span class="line">+-----------------------------------------+------------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                              |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |</span><br><span class="line">|        ID   ID                                                               Usage      |</span><br><span class="line">|=========================================================================================|</span><br><span class="line">|  No running processes found                                                             |</span><br><span class="line">+-----------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://packages.ubuntu.com/focal/kernel/">Ubuntu 網站</a></li><li><a href="https://ubuntu.com/server/docs/nvidia-drivers-installation">NVIDIA drivers installation | Ubuntu</a></li><li><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#ubuntu">參考官方文件 <strong>3.9. Ubuntu</strong></a></li><li><a href="https://blog.marsen.me/2024/07/03/2024/azure_vm_for_nvidia/">前篇Blog</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;RD 們反應因為 Driver 更新導致服務異常，停止運作。&lt;br&gt;重新安裝時又遇到一些奇怪的問題，例如：&lt;br&gt;錯誤：&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [實作筆記] 初體驗設定 Nvidia GPU 的 Azure VM</title>
    <link href="https://blog.marsen.me/2024/07/03/2024/azure_virtual_machine_for_nvidia/"/>
    <id>https://blog.marsen.me/2024/07/03/2024/azure_virtual_machine_for_nvidia/</id>
    <published>2024-07-03T07:59:02.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>隨著深度學習和 AI 的普及，許多工作和研究需要強大的運算能力，<br>而 GPU 提供了相較於傳統 CPU 更高效的計算能力。<br>因此，我選擇在 Azure 上設定 Nvidia GPU 虛擬機來滿足這些需求。<br>這篇文章將分享我在 Azure 上設定 Nvidia GPU 虛擬機的初體驗，並記錄實作過程中的一些重點。</p><h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><p>在開始設定 GPU 虛擬機之前，需要先完成以下準備工作：</p><ol><li><strong>Azure 帳戶</strong>：確保你已經擁有 Azure 的帳戶，並且帳戶中有足夠的配額來創建 GPU 虛擬機。</li><li><strong>選擇適合的虛擬機規格</strong>：Azure 提供多種 GPU 虛擬機型號，如 NV 系列和 NC 系列，根據需求選擇合適的型號。</li><li><strong>安裝 Azure CLI</strong>：透過 Azure CLI 可以更方便地管理和配置虛擬機，可以在本地環境中安裝並配置 Azure CLI。</li><li><strong>創建資源群組與虛擬機</strong>：</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az group create --name &lt;myResourceGroup&gt; --location eastus</span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">az vm create \</span><br><span class="line">  --resource-group myResourceGroup \</span><br><span class="line">  --name myT4VM \</span><br><span class="line">  --image UbuntuLTS \</span><br><span class="line">  --size Standard_NC6s_v3 \</span><br><span class="line">  --admin-username azureuser \</span><br><span class="line">  --generate-ssh-keys</span><br></pre></td></tr></table></figure><h2 id="實作步驟"><a href="#實作步驟" class="headerlink" title="實作步驟"></a>實作步驟</h2><p>可以參考<a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#local-repo-installation-for-ubuntu">官方手冊</a>)，<br>本文大量引用 3. Package Manager Installation 中 3.9 的篇幅</p><h3 id="登入到虛擬機後，安裝-Nvidia-驅動程式"><a href="#登入到虛擬機後，安裝-Nvidia-驅動程式" class="headerlink" title="登入到虛擬機後，安裝 Nvidia 驅動程式"></a>登入到虛擬機後，安裝 Nvidia 驅動程式</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y nvidia-driver-470</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="安裝當前運行的內核版本所需的-Linux-標頭文件"><a href="#安裝當前運行的內核版本所需的-Linux-標頭文件" class="headerlink" title="安裝當前運行的內核版本所需的 Linux 標頭文件"></a>安裝當前運行的內核版本所需的 Linux 標頭文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-headers-$(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure><h3 id="刪除過時的金鑰-實作上，跟本沒有這個金鑰，所以跳過也沒關係"><a href="#刪除過時的金鑰-實作上，跟本沒有這個金鑰，所以跳過也沒關係" class="headerlink" title="刪除過時的金鑰(實作上，跟本沒有這個金鑰，所以跳過也沒關係)"></a>刪除過時的金鑰(實作上，跟本沒有這個金鑰，所以跳過也沒關係)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key del 7fa2af80</span><br></pre></td></tr></table></figure><h3 id="查詢作業系統與晶片架構"><a href="#查詢作業系統與晶片架構" class="headerlink" title="查詢作業系統與晶片架構"></a>查詢作業系統與晶片架構</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Ubuntu</span><br><span class="line">Description:Ubuntu 22.04.4 LTS</span><br><span class="line">Release:22.04</span><br><span class="line">Codename:jammy</span><br><span class="line">&gt; <span class="built_in">uname</span> -m</span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure><h3 id="安裝-CUDA-Keyring"><a href="#安裝-CUDA-Keyring" class="headerlink" title="安裝 CUDA-Keyring"></a>安裝 CUDA-Keyring</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/<span class="variable">$distro</span>/<span class="variable">$arch</span>/cuda-keyring_1.1-1_all.deb</span><br></pre></td></tr></table></figure><p>參考前一步驟將 <code>$distro</code> 換成 <code>ubuntu2204</code>，<code>$arch</code> 換成 <code>x86-64</code>,<br>也可以直接到此 <a href="https://developer.download.nvidia.com/compute/cuda/repos">https://developer.download.nvidia.com/compute/cuda/repos</a> 找到你合適的 deb 檔<br>下載:  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86-64/cuda-keyring_1.1-1_all.deb</span><br></pre></td></tr></table></figure><p>安裝:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i cuda-keyring_1.1-1_all.deb</span><br></pre></td></tr></table></figure><h3 id="安裝-CUDA-SDK"><a href="#安裝-CUDA-SDK" class="headerlink" title="安裝 CUDA SDK"></a>安裝 CUDA SDK</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cuda-toolkit</span><br></pre></td></tr></table></figure><h3 id="安裝-Nvidia-GDS-驅動，提升-GPU-和存儲間的高效數據傳輸性能"><a href="#安裝-Nvidia-GDS-驅動，提升-GPU-和存儲間的高效數據傳輸性能" class="headerlink" title="安裝 Nvidia GDS 驅動，提升 GPU 和存儲間的高效數據傳輸性能"></a>安裝 Nvidia GDS 驅動，提升 GPU 和存儲間的高效數據傳輸性能</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-gds</span><br></pre></td></tr></table></figure><h3 id="重啟主機"><a href="#重啟主機" class="headerlink" title="重啟主機"></a>重啟主機</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="確認是否安裝成功"><a href="#確認是否安裝成功" class="headerlink" title="確認是否安裝成功"></a>確認是否安裝成功</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>　看到下面的畫面就是成功</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; nvidia-smi</span><br><span class="line">Mon Jul  1 09:21:24 2024</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 535.183.01             Driver Version: 535.183.01   CUDA Version: 12.2     |</span><br><span class="line">|-----------------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                                         |                      |               MIG M. |</span><br><span class="line">|=========================================+======================+======================|</span><br><span class="line">|   0  Tesla T4                       Off | 00000001:00:00.0 Off |                  Off |</span><br><span class="line">| N/A   31C    P8               9W /  70W |    140MiB / 16384MiB |      0%      Default |</span><br><span class="line">|                                         |                      |                  N/A |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                            |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |</span><br><span class="line">|        ID   ID                                                             Usage      |</span><br><span class="line">|=======================================================================================|</span><br><span class="line">|    0   N/A  N/A      1095      G   /usr/lib/xorg/Xorg                          130MiB |</span><br><span class="line">|    0   N/A  N/A      1356      G   /usr/bin/gnome-shell                          7MiB |</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="20240730-更新"><a href="#20240730-更新" class="headerlink" title="20240730 更新"></a>20240730 更新</h2><p>追加<a href="https://blog.marsen.me/2024/07/30/2024/azure_vm_for_nvidia_error_records/">異常記錄</a></p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://learn.microsoft.com/en-us/azure/virtual-machines/sizes/overview">Sizes for virtual machines in Azure</a></li><li><a href="https://learn.microsoft.com/en-us/azure/virtual-machines/linux/n-series-driver-setup">Install NVIDIA GPU drivers on N-series VMs running Linux</a></li><li><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#prepare-ubuntu">NVIDIA CUDA Installation Guide for Linux</a></li><li><a href="https://learn.microsoft.com/en-us/azure/virtual-machines/sizes/overview?tabs=breakdownseries,generalsizelist,computesizelist,memorysizelist,storagesizelist,gpu-nc-fam,fpgasizelist,hpcsizelist#gpu-accelerated">Sizes for virtual machines in Azure</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;隨著深度學習和 AI 的普及，許多工作和研究需要強大的運算能力，&lt;br&gt;而 GPU 提供了相較於傳統 CPU 更高效的計算能</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [實作筆記] 建立 Azure VM 的快照(Snapshot)</title>
    <link href="https://blog.marsen.me/2024/07/01/2024/azure_virtual_machine_snapshot/"/>
    <id>https://blog.marsen.me/2024/07/01/2024/azure_virtual_machine_snapshot/</id>
    <published>2024-07-01T05:02:14.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>這次記錄實作 Azure VM 的快照(Snapshot)與還原，與 VM images 不同，<br>快照是針對磁碟的即時捕捉，而不是整個虛擬機器的範本。<br>VM images 用於創建新的虛擬機器，是在固定的狀態下保存整個 VM，<br>包括操作系統、應用程式和所有配置。  </p><p>相比之下，快照則僅保存特定磁碟的狀態，適合於快速還原或備份目前正在運行的 VM。<br>選擇快照主要因為它的快速性和簡便性，可以在短時間內恢復 VM 到指定狀態，<br>以我的例子來說，我因為 AI 需求建了昂貴的 Azure VM ，使用 Image 會會佔用我們的 Quotas。<br>所以 Snapshot 會是較好的還擇</p><h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><p>在開始建立快照之前，請確保以下條件已經準備妥當：</p><ol><li>已經擁有一個可操作的 Azure 帳戶並能夠登入 Azure 入口網站。</li><li>目標 VM 已經啟動並運行正常，且確定需要為其建立快照。</li><li>已經分配足夠的儲存空間來保存快照數據。</li></ol><h2 id="實作步驟"><a href="#實作步驟" class="headerlink" title="實作步驟"></a>實作步驟</h2><h3 id="建立-Snapshot"><a href="#建立-Snapshot" class="headerlink" title="建立 Snapshot"></a>建立 Snapshot</h3><ol><li>登入 <a href="https://portal.azure.com/">Azure 入口網站</a> 並進入虛擬機器(Virtual Machines)頁面。</li><li>從虛擬機器列表中，選擇您想要建立快照的 VM。</li><li>在左側導航欄中，找到並點擊 “磁碟(Disks)”。</li><li>在磁碟頁面中，選擇想要建立快照的磁碟(通常是 OS Disk)。</li><li>點擊上方的 “快照(Snapshot)” 按鈕，進入快照配置頁面。</li><li>在快照配置頁面中，輸入快照名稱，並選擇儲存帳戶和資源群組。</li><li>檢查所有設定無誤後，點擊 “建立(Create)” 按鈕，開始建立快照。這個過程可能需要幾分鐘。</li><li>快照建立完成後，就可以在資源群組或儲存帳戶中找到該快照，並隨時使用它來還原 VM 的狀態。</li></ol><h3 id="從-Snapshot-到-OS-Disk-到-VM"><a href="#從-Snapshot-到-OS-Disk-到-VM" class="headerlink" title="從 Snapshot 到 OS Disk 到 VM"></a>從 Snapshot 到 OS Disk 到 VM</h3><ol><li>在 Azure 入口網站中，進入 “快照(Snapshots)” 頁面，選擇您之前建立的快照。</li><li>點擊快照名稱進入詳細資訊頁面，然後選擇 “建立磁碟(Create Disk)”。</li><li>在磁碟配置頁面中，輸入磁碟名稱，並選擇合適的儲存帳戶和資源群組。</li><li>檢查所有設定無誤後，點擊 “建立(Create)” 按鈕，開始將快照轉換為磁碟。</li><li>磁碟建立完成後，進入 “磁碟(Disks)” 頁面，選擇您剛建立的磁碟。　　</li><li>在磁碟詳細資訊頁面中，點擊上方的 “建立 VM(Create VM)” 按鈕。</li><li>在虛擬機器配置頁面中，完成其他配置，如名稱、大小、網路設定等，然後點擊 “檢閱 + 建立(Review + create)” 按鈕。　　</li><li>檢查所有設定無誤後，點擊 “建立(Create)” 按鈕，開始建立新的虛擬機器。　　</li><li>新的虛擬機器建立完成後，登入並驗證其狀態是否與快照拍攝時一致。</li></ol><p>　　</p><h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>我發現使用 Security Type 為 Trusted Launch 的 VM 所建立的 Snapshot；　　<br>與其建立的 Disk 與 VM 其 Security Type 也會是 Trusted Launch。　　<br>但是當我嚐試透過　SSH using Azure CLI 連線 VM，<br>會遇到無法連線的問題，同樣的步驟，Security Type 為 Standard 就不會有問題。　　<br>待確認原因…　　</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ol><li><a href="https://learn.microsoft.com/zh-tw/azure/virtual-machines/windows/snapshot-copy-managed-disk">Microsoft 官方文件: 建立和管理虛擬機器磁碟的快照</a></li><li><a href="https://docs.microsoft.com/zh-tw/azure/azure-portal/">Azure 入口網站指南</a></li><li><a href="https://docs.microsoft.com/zh-tw/azure/virtual-machines/">Azure 虛擬機器文檔</a></li></ol><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;這次記錄實作 Azure VM 的快照(Snapshot)與還原，與 VM images 不同，&lt;br&gt;快照是針對磁碟的即時</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [生活筆記] 2024 常用工具整理</title>
    <link href="https://blog.marsen.me/2024/06/14/2024/my_tools_2024/"/>
    <id>https://blog.marsen.me/2024/06/14/2024/my_tools_2024/</id>
    <published>2024-06-14T08:51:41.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="輸入法"><a href="#輸入法" class="headerlink" title="輸入法"></a>輸入法</h2><ul><li>無蝦米 (加速打字，未來不太看好，考慮更換中…)</li></ul><h2 id="網站"><a href="#網站" class="headerlink" title="網站"></a>網站</h2><ul><li><a href="https://trends.google.com/trends/">Google Trends 技術趨勢比較</a></li><li>JSON 相關處理工具<ul><li><a href="https://jsonformatter.curiousconcept.com/">用來除錯：找到 JSON 格式不合的地方</a></li><li><a href="https://jsonformatter.org/">美化、壓縮、轉換、編碼</a></li><li><a href="https://json2csharp.com/">轉換成不同語言或格式</a></li><li><a href="https://www.jsonquerytool.com/">測試 JSON Query 怎麼寫</a></li><li><a href="https://www.jsondiff.com/">比較 JSON</a></li></ul></li><li><a href="https://www.yamllint.com/">Yaml 格式檢查器</a></li><li><a href="https://sqlformat.org/">SQL Format 檢查器</a></li><li>假文產生器<ul><li><a href="http://www.richyli.com/tool/loremipsum/">中文</a></li><li><a href="https://www.lipsum.com/feed/html">英文</a></li></ul></li><li><a href="https://comparetext.io/">文字比較</a></li><li>AI　文生文<ul><li><a href="https://chat.openai.com/">ChatGPT</a></li><li><a href="https://claude.ai/">Claude</a></li><li><a href="https://www.bing.com/images/create">Bing Image Create</a></li></ul></li><li>電子白板<ul><li><a href="https://miro.com/">Miro</a></li></ul></li><li>心智圖<ul><li><a href="https://whimsical.com/">whimsical</a></li></ul></li></ul><h2 id="資訊收集-廢文發佈-社群媒體"><a href="#資訊收集-廢文發佈-社群媒體" class="headerlink" title="資訊收集&#x2F;廢文發佈&#x2F;社群媒體"></a>資訊收集&#x2F;廢文發佈&#x2F;社群媒體</h2><ul><li><a href="https://zh-tw.facebook.com/">Facebook</a></li><li><a href="https://www.explainthis.io/zh-hant">Explain this</a></li></ul><h3 id="觀察名單-待汰換"><a href="#觀察名單-待汰換" class="headerlink" title="觀察名單(待汰換)"></a>觀察名單(待汰換)</h3><ul><li><a href="https://www.slant.co/">Slant 工具比較</a></li><li>文字比較工具 - Win Merge(Window限定)</li><li>Evernote<ul><li>專案分類</li><li>職涯規劃</li><li>已完成的項目</li></ul></li></ul><h2 id="Macbook-工具"><a href="#Macbook-工具" class="headerlink" title="Macbook 工具"></a>Macbook 工具</h2><ul><li>Git GUI<ul><li>Fork</li></ul></li><li>KeyCastr<ul><li>顯示鍵盤點擊歷程</li></ul></li><li>跨 PC 存放檔案<ul><li>Dropbox</li></ul></li><li>截圖錄影工具<ul><li>QuickTime</li></ul></li><li>Terminal<ul><li>iTerm</li><li><a href="https://www.warp.dev/">Warp</a></li></ul></li></ul><h2 id="筆記工具"><a href="#筆記工具" class="headerlink" title="筆記工具"></a>筆記工具</h2><ul><li><a href="https://www.notion.so/">Notion</a><ul><li>GTD</li><li>周記劃</li></ul></li><li><a href="https://hackmd.io/">HackMD</a><ul><li>暫存的記錄</li><li>會議&#x2F;社群活動即時記錄</li><li>Blog 草稿</li><li>共筆</li></ul></li><li><a href="https://marsen.me/">Blog</a><ul><li>技術實作記錄</li><li>社群活動記錄</li></ul></li><li><a href="https://notebooklm.google.com/">NotebookLM</a><ul><li>RAG AI 整合筆記</li></ul></li></ul><h2 id="瀏覽器-外掛"><a href="#瀏覽器-外掛" class="headerlink" title="瀏覽器 &amp; 外掛"></a>瀏覽器 &amp; 外掛</h2><p>都使用 Chromium 內核相關</p><ul><li>Brave</li><li>Chrome</li><li>Edge</li><li>FireFox</li><li>Arc 觀察中</li></ul><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><ul><li>tampermonkey<ul><li>撰寫網頁小工具</li></ul></li><li>One Tab<ul><li>快速收攏大量分頁，常用在特殊主題搜尋的暫存</li></ul></li><li>Trancy<ul><li>沉浸式翻譯與影片翻譯</li></ul></li><li>Bitbucket Diff Tree<ul><li>Bitbucket PR 差異比較</li></ul></li><li>JSONView<ul><li>當 response 為 json 時更為好讀</li></ul></li><li>Bitwarden<ul><li>密碼管理</li></ul></li><li>Wappalyzer<ul><li>分析網站使用的框架與技術</li></ul></li><li>cVim<ul><li>使用 Vim 的習慣操作網頁</li></ul></li></ul><h2 id="開發工具"><a href="#開發工具" class="headerlink" title="開發工具"></a>開發工具</h2><ul><li>Vim</li><li>VSCode</li><li>JetBrain 全系列</li><li>Docker Desktop</li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;輸入法&quot;&gt;&lt;a href=&quot;#輸入法&quot; class=&quot;headerlink&quot; title=&quot;輸入法&quot;&gt;&lt;/a&gt;輸入法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;無蝦米 (加速打字，未來不太看好，考慮更換中…)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;網站&quot;&gt;&lt;a href=&quot;#網站</summary>
      
    
    
    
    
    <category term="生活筆記" scheme="https://blog.marsen.me/tags/%E7%94%9F%E6%B4%BB%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] Azure Communication Services email</title>
    <link href="https://blog.marsen.me/2024/06/07/2024/azure_email_communication_service/"/>
    <id>https://blog.marsen.me/2024/06/07/2024/azure_email_communication_service/</id>
    <published>2024-06-07T09:58:53.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>隨著現代企業在數位轉型中的步伐加快，電子郵件仍然是最重要的溝通工具之一。<br>公司現在的寄信服務採取了一個特別的解決方案，透過 App registrations 進行郵件發送。<br>實作的細節不展開，但這樣作有幾個問題:  </p><ul><li>App registrations 首次需人工授權取得 refresh_token</li><li>有了 refresh_token 仍需交換到 access_token 才能寄信</li><li>更新 refresh_token 失敗時，就需要人工重新介入</li></ul><p>而 Microsoft Azure 提供了強大的 Email Communication Service，可以幫助企業輕鬆、有效地發送大量電子郵件。<br>優點有整合簡單、高可擴展、安全性高、可靠性強等等優點…  </p><p>本篇文章將記錄我如何在 Azure 中實作 Email Communication Service。</p><h2 id="實作步驟"><a href="#實作步驟" class="headerlink" title="實作步驟"></a>實作步驟</h2><ol><li><p>建立 Azure Communication Services 資源<br>  首先，登入 Azure 入口網站，然後依序進行以下步驟：<br>  點選「建立資源」按鈕，搜尋並選擇「Communication Services」。<br>  點選「建立」按鈕，填寫必要的資訊如資源名稱、訂閱和資源群組等。<br>  選擇地區並設定其餘選項後，點選「檢閱 + 建立」，檢查設定並點選「建立」。  </p></li><li><p>配置電子郵件通道<br>  在 Communication Services 資源建立完成後，需要進行電子郵件通道的配置：<br>  在資源概覽頁面中，找到並點選「Email」。<br>  點選「新增郵件域」，並按照提示設定 SMTP 資訊及其他相關設定。<br>  驗證郵件域並完成配置。<br>  <em>這裡你需要有 domain 管理者的權限，用來在 DNS Records 建立相關的記錄(CNAME、TXT)</em></p></li><li><p>生成 API 金鑰<br>  接下來，我們需要生成 API 金鑰，以便應用程式能夠通過此金鑰進行認證和發送電子郵件：<br>  在 Communication Services 資源頁面中，找到並點選「密鑰」。<br>  點選「生成&#x2F;管理密鑰」，生成新的 API 金鑰並保存。</p></li><li><p>發送電子郵件<br>  有了 API 金鑰和配置好的電子郵件通道，現在可以使用 Azure 提供的 SDK 或 REST API 發送電子郵件。<br>  以下範例展示了如何使用 Nodejs 發送郵件：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">EmailClient</span>, type <span class="title class_">EmailMessage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@azure/communication-email&#x27;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sendMail = <span class="keyword">async</span> (<span class="attr">req</span>: <span class="title class_">Request</span>, <span class="attr">res</span>: <span class="title class_">Response</span>): <span class="title class_">Promise</span>&lt;<span class="keyword">void</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> connectionString = <span class="title function_">env</span>(<span class="string">&#x27;COMMUNICATION_SERVICES_CONNECTION_STRING&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> senderAddress = <span class="title function_">env</span>(<span class="string">&#x27;EMAIL_SENDER_ADDRESS&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">EmailClient</span>(connectionString)</span><br><span class="line">  <span class="keyword">const</span> &#123; to, subject, html &#125; = req.<span class="property">body</span></span><br><span class="line">  <span class="keyword">const</span> attachments = (req.<span class="property">files</span> != <span class="literal">null</span>)</span><br><span class="line">    ? (req.<span class="property">files</span> <span class="keyword">as</span> <span class="title class_">Express</span>.<span class="property">Multer</span>.<span class="property">File</span>[]).<span class="title function_">map</span>(<span class="function"><span class="params">file</span> =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">name</span>: file.<span class="property">originalname</span>,</span><br><span class="line">        <span class="attr">contentType</span>: file.<span class="property">mimetype</span>,</span><br><span class="line">        <span class="attr">contentInBase64</span>: file.<span class="property">buffer</span>.<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line">      &#125;))</span><br><span class="line">    : []</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">emailMessage</span>: <span class="title class_">EmailMessage</span> = &#123;</span><br><span class="line">    senderAddress,</span><br><span class="line">    <span class="attr">content</span>: &#123;</span><br><span class="line">      subject,</span><br><span class="line">      html</span><br><span class="line">    &#125;,</span><br><span class="line">    attachments,</span><br><span class="line">    <span class="attr">recipients</span>: &#123;</span><br><span class="line">      <span class="attr">to</span>: [&#123; <span class="attr">address</span>: to &#125;],</span><br><span class="line">      <span class="attr">bcc</span>: [&#123; <span class="attr">address</span>: <span class="string">&#x27;noreply@marsen.me&#x27;</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> poller = <span class="keyword">await</span> client.<span class="title function_">beginSend</span>(emailMessage)</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> poller.<span class="title function_">pollUntilDone</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result:&#x27;</span>, result)</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(&#123; <span class="attr">message</span>: <span class="string">`Email <span class="subst">$&#123;subject&#125;</span> Sent!`</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-Azure-Portal-執行整合測試"><a href="#在-Azure-Portal-執行整合測試" class="headerlink" title="在 Azure Portal 執行整合測試"></a>在 Azure Portal 執行整合測試</h3><p>在 Azure Portal &gt; Communication Service &gt; Email &gt; Try Email，<br>非常貼心的提供了 C#、JavaScript、Java、Python、cUrl　的範本，<br>也可以取得連線字串。</p><h3 id="使用上限與新增寄件帳號"><a href="#使用上限與新增寄件帳號" class="headerlink" title="使用上限與新增寄件帳號"></a>使用上限與新增寄件帳號</h3><p>原則上預設的使用量對開發人員來說，是非常足夠的<br>但是如果想增加上限，或是新增其它的寄件者帳號，需要開 support ticket 進行升級，<br>這是為了避免郵件的濫用，另外需新增 MX Record 可以避免當成垃圾郵件。<br>升級後就可以在 Azure Portal &gt; Email Communication Service &gt; Provision domains &gt; MailFrom addresses<br>新增寄件者，實際上 Azure Communication Service 只會寄件無法收件，<br>即使在 O365 有相同的帳號，在寄件備份中也看不到透過 ECS 寄出的郵件。　　</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>實作上比較有風險大概是 DNS Records 的設定，最久大約需等到 1 小時生效。<br>而開發上非常的容易，甚至程式範例都整合到 Portal，非常方便。 　<br>但是其它方面需要開票等待 Azure 協力升級與設定，就會比較麻煩。 　</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://learn.microsoft.com/en-us/azure/communication-services/concepts/email/email-overview">Overview of Azure Communication Services email</a></li><li><a href="https://learn.microsoft.com/en-us/azure/communication-services/quickstarts/create-communication-resource?tabs=windows&pivots=platform-azp">Quickstart: Create and manage Communication Services resources</a></li><li><a href="https://learn.microsoft.com/en-us/azure/communication-services/concepts/email/email-quota-increase">Quota increase for email domains</a></li><li><a href="https://azure.microsoft.com/en-us/support/create-ticket/">Create Support Ticket</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;隨著現代企業在數位轉型中的步伐加快，電子郵件仍然是最重要的溝通工具之一。&lt;br&gt;公司現在的寄信服務採取了一個特別的解決方案，</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [踩雷筆記] Gitlab CI/CD 與 GCP - 靜態網站部署整合 404 與 `/`</title>
    <link href="https://blog.marsen.me/2024/05/14/2024/gitlab_ci_and_gcs_as_static_site/"/>
    <id>https://blog.marsen.me/2024/05/14/2024/gitlab_ci_and_gcs_as_static_site/</id>
    <published>2024-05-14T03:42:53.000Z</published>
    <updated>2024-11-08T05:02:30.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近將公司的所有靜態網站轉換到 GCS 上了，遇到一些情境，特此記錄<br>這篇會以 Vue 與 Nuxt 的角度出發。<br>在前後端分離的情況下，SEO 變成一個問題，SSR 可以解決這個問題，<br>我們可以使用 Nuxt 建立我們的專案，並透過 <code>generate</code> 生成靜態檔案。</p><p>再進一步來說，我們可以整合 <a href="https://cloud.google.com/storage/docs/hosting-static-website">GCS 進行靜態網站的部署</a></p><h3 id="題外話"><a href="#題外話" class="headerlink" title="題外話"></a>題外話</h3><p>Nuxt 的幾種建置方式</p><ol><li><p><code>npx nuxt build</code><br>  The build command creates a .output directory with all your application, server and dependencies ready for production.<br>  這個命令會建立一個 .output 目錄，裡面包含了你的應用程式、伺服器和所有必要的依賴，準備好用於生產環境。<br>  預設的行為，可以實作 SSR(Server Side Render)，適用有 SEO 需求，且變化快速的網站，Ex: 電商產品頁</p></li><li><p><code>npx nuxt build --prerender</code><br>  –prerenderfalsePre-render every route of your application. (note: This is an experimental flag. The behavior might be changed.) .<br>  –prerender false 會對應用程式的每個路由進行預渲染。（注意：這是一個實驗性的標誌。行為可能會更改。）；<br>  它會先產生好 HTML，適合 SSG 網站(內容不常改動，但有 SEO 需求）。Ex: BLOG</p></li><li><p><code>npx nuxt generate </code></p></li></ol><p>  The generate command pre-renders every route of your application and stores the result in plain HTML files that you can deploy on any static hosting services. The command triggers the nuxi build command with the prerender argument set to true<br>  這個命令會對你的應用程式的每個路由進行預渲染，並將結果存儲在普通的 HTML 文件中，你可以部署到任何靜態托管服務上。　　<br>  該命令會觸發 nuxi build 命令，並將 prerender 參數設置為 true。<br>  它適合純靜態的網頁(SPA)。Ex: Landing Page.　與前者最大的差異是，前者會建置成不同的 HTML，</p><h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>當我們在建置好靜態網站並部署到 GCS 上時，我遇到了一個異常的問題，<br>當我複製貼上網址時會發生 404 Not Found，主因是當我的網址結尾不是<code>/</code>時，<br>瀏覽器會轉導到 <code>/index.html</code>。<br>舉例說明:</p><p><code>https://marsen.me/sample</code> 複製貼上，會轉導到 <code>https://marsen.me/sample/index.html</code><br>而這頁不存在，導致產生 404 的錯誤</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>採取升級 Nuxt 到 <a href="https://github.com/nuxt/nuxt/releases/tag/v3.8.0">v3.8.0</a> 以上，<br>這是實驗性的功能，雖然目前有效，仍需觀注未來更新的狀況。<br>若不打算升級，另外有用 <code>middleware</code> 處理重定向，<br>可參考此 <a href="https://github.com/nuxt/nuxt/issues/15462#issuecomment-1407374859">issue</a> 的討論串，<br>要寫比較多，而且留言者在部署到 vercel 有遇到其他問題。故採升級的方式解決此題。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://blog.marsen.me/2022/03/09/2022/gcp_static_site_with_cloud_storage_and_loading_balancing/">靜態網站部署整合 GCP - Load Balancing &amp; Cloud Storage</a></li><li>[實作筆記] Gitlab CI&#x2F;CD 與 GCP 相關文章<ul><li><a href="https://blog.marsen.me/2023/04/13/2023/gitlab_ci_and_gcp_vm/">架構全貌</a></li><li><a href="https://blog.marsen.me/2023/04/14/2023/gitlab_ci_and_gcp_vm_create_server/">建立 Web Server VM</a></li><li><a href="https://blog.marsen.me/2023/04/14/2023/gitlab_ci_and_gcp_vm_cretae_runner/">建立 Gitlab Runner VM</a></li><li><a href="https://blog.marsen.me/2023/04/14/2023/gitlab_ci_and_gcp_vm_firewall/">防火牆設定</a></li><li><a href="https://blog.marsen.me/2023/04/24/2023/gitlab_ci_and_gcp_vm_account/">Linux User 與資料夾權限</a></li><li><a href="https://blog.marsen.me/2023/05/29/2023/gitlab_ci_and_gcp_vm_secret_config/">機敏資料的處理</a></li><li><a href="https://blog.marsen.me/2023/11/16/2023/gitlab_ci_error_handle/">錯誤處理</a></li><li><a href="https://blog.marsen.me/2024/03/13/2024/gitlab_ci_and_gcp_workload_federation/">Workload Identity Federation</a></li><li><a href="https://blog.marsen.me/2024/04/17/2024/gitlab_ci_and_gcp_cloud_run/">Cloud Run</a></li></ul></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近將公司的所有靜態網站轉換到 GCS 上了，遇到一些情境，特此記錄&lt;br&gt;這篇會以 Vue 與 Nuxt 的角度出發。&lt;b</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
</feed>
