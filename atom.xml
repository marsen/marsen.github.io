<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marsen&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c2458ad941ad5f8ca05b12c705fd4912</icon>
  <subtitle>waiting to load</subtitle>
  <link href="https://blog.marsen.me/atom.xml" rel="self"/>
  
  <link href="https://blog.marsen.me/"/>
  <updated>2025-11-18T02:49:50.286Z</updated>
  <id>https://blog.marsen.me/</id>
  
  <author>
    <name>Marsen L.</name>
    <email>admin@marsen.me</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[SDD 與 Spec Kit]敏捷開發（2000-Now）</title>
    <link href="https://blog.marsen.me/2025/11/03/2025/sdd_spec_agile/"/>
    <id>https://blog.marsen.me/2025/11/03/2025/sdd_spec_agile/</id>
    <published>2025-11-03T03:02:36.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="輕量級方法百花齊放"><a href="#輕量級方法百花齊放" class="headerlink" title="輕量級方法百花齊放"></a>輕量級方法百花齊放</h2><p>由於原始工程的冗長沉重，各式輕量的方法被提出，</p><p>XP&#x2F;Scrum&#x2F;RAD(Rapid Application Development)&#x2F;DSDM（Dynamic Systems Development Method&#x2F;Crystal 等等…</p><p><a href="https://zh.wikipedia.org/zh-tw/Scrum">Scrum</a> 更是自 1986 就提出，雖然到 1995 才整理成為完整的方法論。</p><p>XP 則是 Kent Beck 於 1996 年在克萊斯勒專案開始的第一個完整實驗案例。</p><h2 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h2><p>2001年2月11-13日，17位軟體開發者在猶他州雪鳥滑雪場寫下敏捷宣言。</p><p>這不是隨便17個人——他們每一位都是當時軟體開發方法論的領導者。</p><p>這17位是：</p><table><thead><tr><th>分類</th><th>代表人物</th><th>主要著作／理念</th><th>切入角度</th><th>貢獻重點</th></tr></thead><tbody><tr><td><strong>一、極限編程（XP）與工匠精神</strong></td><td><strong>Kent Beck</strong></td><td>《Extreme Programming Explained》 (1999)</td><td>技術實踐</td><td>以測試驅動（TDD）、重構、持續整合為核心，建立可持續變更的技術文化</td></tr><tr><td></td><td><strong>Ron Jeffries</strong></td><td>「You Aren’t Gonna Need It」(YAGNI)</td><td>極簡哲學</td><td>實踐 XP 原則於 C3 專案，推廣極簡與實用的設計理念</td></tr><tr><td></td><td><strong>Martin Fowler</strong></td><td>《Refactoring》(1999)、〈Continuous Integration〉</td><td>軟體架構</td><td>推動可演化架構、自動化測試與持續整合文化</td></tr><tr><td></td><td><strong>Robert C. Martin (Uncle Bob)</strong></td><td>《Clean Code》系列、SOLID 原則</td><td>工匠精神</td><td>提倡程式專業紀律、代碼品質與職業倫理</td></tr><tr><td></td><td><strong>James Grenning</strong></td><td>嵌入式 TDD 推廣者</td><td>硬體開發</td><td>將 XP 精神帶入嵌入式與硬體領域，重視可靠性與可測性</td></tr><tr><td></td><td><strong>Andrew Hunt &amp; Dave Thomas</strong></td><td>《The Pragmatic Programmer》(1999)</td><td>實用主義</td><td>提倡開發者自我改進與實用思維，落實工匠式開發文化</td></tr><tr><td><strong>二、Scrum 與組織敏捷管理</strong></td><td><strong>Ken Schwaber</strong></td><td>《Agile Software Development with Scrum》(2001)</td><td>流程管理</td><td>建立 Scrum 框架，確立三角色與三工件</td></tr><tr><td></td><td><strong>Jeff Sutherland</strong></td><td>Scrum 共同創始人、「Inspect &amp; Adapt」理念</td><td>組織文化</td><td>建立迭代循環與回饋節奏，強調可視化管理與持續改進</td></tr><tr><td></td><td><strong>Mike Beedle</strong></td><td>Scrum 實踐推廣者</td><td>企業轉型</td><td>將 Scrum 落地於企業場景，推動組織敏捷轉型</td></tr><tr><td><strong>三、人本導向與情境化方法</strong></td><td><strong>Alistair Cockburn</strong></td><td>Crystal 方法、《Writing Effective Use Cases》(2000)</td><td>人際互動</td><td>從人與溝通出發，倡導情境化與最小可行流程</td></tr><tr><td></td><td><strong>Jim Highsmith</strong></td><td>《Adaptive Software Development》(1999)</td><td>學習導向</td><td>將開發視為學習與演化過程，重視適應性與協作</td></tr><tr><td></td><td><strong>Brian Marick</strong></td><td>Context-Driven Testing 理念</td><td>測試文化</td><td>測試應依專案情境調整，反對僵化流程與統一標準</td></tr><tr><td><strong>四、模型導向與架構思維</strong></td><td><strong>Steve Mellor</strong></td><td>《Object-Oriented Systems Analysis》(1988)、Executable UML</td><td>模型驅動</td><td>面向物件分析先驅，後期推動模型驅動架構（MDA）與可執行模型概念</td></tr><tr><td><strong>五、組織級與治理導向方法</strong></td><td><strong>Arie van Bennekum</strong></td><td>DSDM 方法共同創始人</td><td>專案治理</td><td>從企業治理與預算控制出發，平衡交付靈活性</td></tr><tr><td></td><td><strong>Jon Kern</strong></td><td>Feature-Driven Development (FDD) 實踐者</td><td>大型專案</td><td>以功能特徵為單位規劃開發，適用大型分散式團隊</td></tr><tr><td><strong>（補充人物）</strong></td><td><strong>Ward Cunningham</strong></td><td>Wiki、Pattern Repository</td><td>團隊學習</td><td>推動知識共享、模式化思維與團隊學習，是 XP 精神的早期基礎</td></tr></tbody></table><h3 id="簽署內容"><a href="#簽署內容" class="headerlink" title="簽署內容"></a>簽署內容</h3><blockquote><p>Individuals and interactions over processes and tools</p><p>Working software over comprehensive documentation</p><p>Customer collaboration over contract negotiation</p><p>Responding to change over following a plan</p></blockquote><h2 id="敏捷的變質：從理想到現實"><a href="#敏捷的變質：從理想到現實" class="headerlink" title="敏捷的變質：從理想到現實"></a>敏捷的變質：從理想到現實</h2><p>簽署宣言20多年後，敏捷已經成為主流，但也出現了嚴重的變質。</p><p>有一些問題，我先列在這著，其他的下一篇再說明</p><ul><li>儀式化的敏捷</li><li>認證機類與產業鏈的興起</li><li>工程實踐的缺／消失</li><li>文化衝突與假敏捷</li></ul><h3 id="結果是各種「偽敏捷」"><a href="#結果是各種「偽敏捷」" class="headerlink" title="結果是各種「偽敏捷」"></a>結果是各種「偽敏捷」</h3><p>小瀑布式 Scrum：兩週一個瀑布，需求分析→設計→開發→測試，只是週期變短</p><p>命令式敏捷：「我們要敏捷！」但所有決定還是老闆說了算</p><p>報告式敏捷：Jira 票開得很勤，但主要是為了產生報表給管理層看</p><p>自得其樂的 Scrum But：守破離本身的概念沒錯，但是守得人少，離的人多，沒見過什麼有效的破</p><h3 id="簽署者們的反思"><a href="#簽署者們的反思" class="headerlink" title="簽署者們的反思"></a>簽署者們的反思</h3><ul><li>Ron Jeffries 在2018年的文章《Developers Should Abandon Agile》中寫道：「如果你的組織扭曲了敏捷，讓它變成壓迫開發者的工具，那就放棄它，專注於寫好程式。」</li><li>Dave Thomas 在2014年的演講《Agile is Dead》中說：「敏捷應該是形容詞（Agile），不是名詞（Agile）。你應該追求敏捷性，而不是實施大寫的Agile。」</li><li>Robert Martin 在《Clean Agile》(2019)書中直言：「敏捷工業複合體（Agile Industrial Complex）已經形成，充斥著證照、教練、顧問，但失去了原始精神。」</li><li>Kent Beck在2019年的訪談中提到，XP的核心是五個價值觀：溝通、簡單、回饋、勇氣、尊重。這些價值觀驅動實踐，而不是反過來。</li></ul><p>這些先驅者從來不是教條主義者，他們一直在實驗、調整、演化。</p><p>台灣軟體業面對的不只是方法論的選擇，還有文化適應的挑戰。</p><p>沒有銀彈，正如 Alistair Cockburn 在 Crystal 方法中強調的：每個專案都是獨特的，需要調整方法來適應團隊和環境。</p><p>重要的不是完美複製矽谷的敏捷，而是找到適合我們的方式。</p><p>理解這 17 位先驅者的初衷——更好的軟體開發方式 —— 比死守任何框架都重要。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://agilemanifesto.org/">敏捷宣言 Agile Manifesto</a></li><li><a href="https://www.youtube.com/watch?v=a-BOSpxYJ9M">敏捷已死 Agile is Dead • Pragmatic Dave Thomas • GOTO 2015</a></li><li><a href="https://www.youtube.com/watch?v=vJGoQigiXAE">我们都只是在假装着做Agile【让编程再次伟大#43】</a></li><li><a href="https://martinfowler.com/bliki/FlaccidScrum.html">軟爛的 Scrum Flaccid Scrum</a></li><li><a href="/assets/RE-SA-17th-Annual-State-Of-Agile-Report.pdf">敏捷報告 The 17th State of Agile Report</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;輕量級方法百花齊放&quot;&gt;&lt;a href=&quot;#輕量級方法百花齊放&quot; class=&quot;headerlink&quot; title=&quot;輕量級方法百花齊放&quot;&gt;&lt;/a&gt;輕量級方法百花齊放&lt;/h2&gt;&lt;p&gt;由於原始工程的冗長沉重，各式輕量的方法被提出，&lt;/p&gt;
&lt;p&gt;XP&amp;#x2F;Scr</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[SDD 與 Spec Kit]傳統瀑布式開發（1975-2000）</title>
    <link href="https://blog.marsen.me/2025/10/30/2025/sdd_spec_kit_water_fall/"/>
    <id>https://blog.marsen.me/2025/10/30/2025/sdd_spec_kit_water_fall/</id>
    <published>2025-10-30T08:36:06.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<p>TL;DR</p><h2 id="當軟體開發還是一門工程學"><a href="#當軟體開發還是一門工程學" class="headerlink" title="當軟體開發還是一門工程學"></a>當軟體開發還是一門工程學</h2><p>1970 年代，當軟體開發還是一門新興學科時，人們自然地從傳統工程領域借鑒經驗。</p><p>蓋房子需要藍圖、造橋需要設計圖，那麼開發軟體當然也需要完整的規格文件——這個看似合理的類比，開啟了長達數十年的瀑布式開發時代。</p><p>有趣的是，<a href="/assets/royce1970.pdf">瀑布式開發 - Waterfall</a> 這個名詞首次出現在1970年 Winston Royce 的論文中</p><p>但 Royce 其實只是點名在當時的主流方法，並且給這種方法一些批評與建議。</p><p>只是產業界選擇性地抓住了 Buzz Word ”Waterfall” 並將其奉為圭臬，而忽略了他的警告。</p><p>當然這也不是第一次業界扭曲軟體工程理論的原意。</p><h2 id="瀑布模式的黃金年代"><a href="#瀑布模式的黃金年代" class="headerlink" title="瀑布模式的黃金年代"></a>瀑布模式的黃金年代</h2><p>流程的確立</p><p>瀑布式建立起一套看似完美的流程：</p><h3 id="需求分析-→-系統設計-→-實作-→-測試-→-部署-→-維護"><a href="#需求分析-→-系統設計-→-實作-→-測試-→-部署-→-維護" class="headerlink" title="需求分析 → 系統設計 → 實作 → 測試 → 部署 → 維護"></a>需求分析 → 系統設計 → 實作 → 測試 → 部署 → 維護</h3><p>就像接力賽跑，一棒接一棒，每個階段都有明確的交付物和把關者。</p><p>需求分析階段產出厚達數百頁的需求規格書（SRS, Software Requirements Specification），</p><p>系統設計階段則有高階設計（HLD, High-Level Design）和低階設計（LLD, Low-Level Design）文件。</p><p>這些文件不只是參考，而是具有合約效力的承諾。</p><p>當時的人相信，只要文件夠詳細，開發就是照著做而已。</p><p>甚至 UML 也在那個時代應運而生。</p><h3 id="角色分工的確立"><a href="#角色分工的確立" class="headerlink" title="角色分工的確立"></a>角色分工的確立</h3><p>這個時期也確立了軟體開發的專業分工：</p><ul><li>PM（專案經理）負責管理時程與資源，通常不懂技術</li><li>SA（系統分析師）負責理解業務需求，把業務語言翻譯成技術語言</li><li>SD（系統設計師）負責技術架構，畫一堆UML圖</li><li>PG（程式設計師）負責編碼實作，被視為「碼農」</li><li>QA（品質保證工程師）負責測試驗證，專門找碴</li></ul><p>這種分工暗示著「思考」和「執行」是可以分離的。</p><p>會思考的人負責設計，會打字的人負責coding。</p><p>這種階級觀念到今天都還沒完全消失。</p><h2 id="為什麼瀑布式曾經如此成功？"><a href="#為什麼瀑布式曾經如此成功？" class="headerlink" title="為什麼瀑布式曾經如此成功？"></a>為什麼瀑布式曾經如此成功？</h2><h3 id="無法失敗的時代背景"><a href="#無法失敗的時代背景" class="headerlink" title="無法失敗的時代背景"></a>無法失敗的時代背景</h3><p>在1980年代，一套企業系統可能要價數百萬美元，開發週期動輒2-3年。</p><p>IBM的System&#x2F;360開發耗資50億美元（相當於今天的400億），這種規模的投資容不得失敗。</p><p>瀑布式提供了管理層最需要的東西：控制力(或許只是幻覺)。</p><p>每個階段都有文件、有簽核、有人負責。出事了可以調出文件來看是誰的錯。</p><p>這種「可究責性」讓高層睡得安心。</p><h3 id="適合當時的技術限制"><a href="#適合當時的技術限制" class="headerlink" title="適合當時的技術限制"></a>適合當時的技術限制</h3><p>當時的開發環境是什麼樣子？</p><ul><li>沒有 Git，版本控制用 CVS&#x2F;RCS 等集中式系統，或原始的複製資料夾</li><li>早期沒有 IDE，主要用 vi 或 Emacs，90年代才有原始的 IDE</li><li>編譯大型專案可能要等數小時</li><li>測試主要靠人工，自動化測試工具原始且昂貴</li><li>部署要半夜停機，通過實體媒介發布</li></ul><p>在這種環境下，改一行code的成本可能是現在的100倍。</p><p>「想清楚再動手」不只是最佳實踐，而是唯一選擇。</p><p>[個人經驗補充區]</p><h2 id="瀑布式的內在矛盾"><a href="#瀑布式的內在矛盾" class="headerlink" title="瀑布式的內在矛盾"></a>瀑布式的內在矛盾</h2><h3 id="文件與現實的落差"><a href="#文件與現實的落差" class="headerlink" title="文件與現實的落差"></a>文件與現實的落差</h3><p>最大的問題在於：軟體是看不見、摸不著的。</p><p>建築師可以做模型，讓客戶看到未來的大樓長什麼樣子。</p><p>但軟體呢？畫了100張UML圖，客戶還是不知道系統用起來是什麼感覺。</p><p>更慘的是，需求文件寫著「系統應支援多使用者同時操作」，但什麼叫「多」？</p><p>10個？1000個？每個人心中都有不同的數字，直到系統上線當機才發現認知落差。</p><h3 id="溝通的斷層"><a href="#溝通的斷層" class="headerlink" title="溝通的斷層"></a>溝通的斷層</h3><p>瀑布式假設資訊可以無損地傳遞，但現實是每一次傳遞都會失真，每一層次轉換都是風險：</p><blockquote><p>客戶說：「我要一個簡單的購物網站」</p><p>PM聽成：「要有會員系統、商品管理、訂單處理、金流串接…」</p><p>SA寫成：「系統應提供使用者友善的介面以利商品選購」</p><p>SD設計成：「採用三層式架構搭配MVC模式」</p><p>PG實作成：「if-else地獄加上全域變數」</p></blockquote><p>最後客戶看到成品：「這不是我要的！」</p><h3 id="變更的成本"><a href="#變更的成本" class="headerlink" title="變更的成本"></a>變更的成本</h3><p>瀑布式最致命的假設是：<strong>需求是可以預先確定且不會改變的。</strong></p><p>但現實是，<strong>客戶看到系統之前，根本不知道自己要什麼。</strong></p><h3 id="網路時代的衝擊"><a href="#網路時代的衝擊" class="headerlink" title="網路時代的衝擊"></a>網路時代的衝擊</h3><p>指 dot com 泡沫到 web 2.0 的時代。</p><p>產品生命週期從年變成月</p><p>競爭對手不是隔壁公司，而是地球另一端的車庫創業</p><p>當你的競爭對手每週更新，而你還在等三個月後的UAT（使用者驗收測試），市場早就不見了。</p><p>搶佔市場的思維，改變了軟體工程，敏捷成為主流，我們之後再說。</p><p>但某些領域仍然需要瀑布式：</p><ul><li>醫療設備軟體：FDA要求完整的文件追蹤，一個bug可能害死人</li><li>航太系統：NASA的軟體開發依然遵循嚴格的階段審查</li><li>金融核心系統：當你處理的是別人的錢，「快速失敗」不是選項</li></ul><p>這些領域的共同點是：錯誤的成本遠大於延遲的成本。</p><p>更深層的影響是，瀑布式留下的不只是流程，更是一種思維模式。</p><p>即使號稱敏捷的團隊，實際上仍在執行小瀑布</p><p>下一篇，我們將探討敏捷如何試圖解決這些問題，以及為什麼「敏捷」為什麼也失敗。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://www.youtube.com/watch?v=RyGA6zBHcJg">以前的程序员，除了敲代码，还得会画画【让编程再次伟大#42】</a></li><li><a href="https://zh.wikipedia.org/zh-tw/%E7%BB%9F%E4%B8%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B">RUP 統一軟體開發過程</a></li><li><a href="https://docs.mermaidchart.com/blog/posts/sequence-diagrams-the-good-thing-uml-brought-to-software-development">序列圖，UML 給軟體開發帶來的唯一好處</a></li><li><a href="https://www.youtube.com/watch?v=vJGoQigiXAE">我们都只是在假装着做Agile【让编程再次伟大#43】</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TL;DR&lt;/p&gt;
&lt;h2 id=&quot;當軟體開發還是一門工程學&quot;&gt;&lt;a href=&quot;#當軟體開發還是一門工程學&quot; class=&quot;headerlink&quot; title=&quot;當軟體開發還是一門工程學&quot;&gt;&lt;/a&gt;當軟體開發還是一門工程學&lt;/h2&gt;&lt;p&gt;1970 年代，當軟體開發還是一門</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[學習筆記] SDD 與 Spec Kit - 前言</title>
    <link href="https://blog.marsen.me/2025/10/29/2025/sdd_spec_kit/"/>
    <id>https://blog.marsen.me/2025/10/29/2025/sdd_spec_kit/</id>
    <published>2025-10-29T05:06:15.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<p>TL;DR</p><h2 id="簡介-SDD"><a href="#簡介-SDD" class="headerlink" title="簡介 SDD"></a>簡介 SDD</h2><blockquote><p>What is Spec-Driven Development?<br>  Spec-Driven Development flips the script on traditional software development.<br>  For decades, code has been king — specifications were just scaffolding we built and discarded once the “real work” of coding began<br>  Spec-Driven Development changes this: specifications become executable, directly generating working implementations rather than jus<br>  guiding them.  – spec-kit</p></blockquote><p>什麼是規格驅動開發 ???<br>跟過往的開放方式什麼不同???<br>什麼原因讓它興起 ???  </p><h2 id="傳統開發流程-1990之前"><a href="#傳統開發流程-1990之前" class="headerlink" title="傳統開發流程(1990之前)"></a><a href="https://blog.marsen.me/2025/10/30/2025/sdd_spec_kit_water_fall/">傳統開發流程(1990之前)</a></h2><h2 id="敏捷開發流程-1990-至今"><a href="#敏捷開發流程-1990-至今" class="headerlink" title="敏捷開發流程(1990~至今)"></a>敏捷開發流程(1990~至今)</h2><p>敏捷開發（Agile）的出現，是對瀑布式開發的反思。它強調：</p><ul><li>個人與互動 &gt; 流程與工具</li><li>可用的軟體 &gt; 詳盡的文件</li><li>客戶合作 &gt; 合約協商</li><li>回應變化 &gt; 遵循計劃</li></ul><p>敏捷的典型流程（以 Scrum 為例）：</p><h3 id="Product-Backlog-→-Sprint-Planning-→-Daily-Standup-→-Sprint-Review-→-Sprint-Retrospective"><a href="#Product-Backlog-→-Sprint-Planning-→-Daily-Standup-→-Sprint-Review-→-Sprint-Retrospective" class="headerlink" title="Product Backlog → Sprint Planning → Daily Standup → Sprint Review → Sprint Retrospective"></a>Product Backlog → Sprint Planning → Daily Standup → Sprint Review → Sprint Retrospective</h3><p>這是一個迭代循環，每個 Sprint（通常 2-4 週）都會產出可用的軟體增量。</p><ul><li>Product Backlog: 對齊高層期望，主要角色 Stackholder&#x2F;Product Owner</li><li>Sprint Planning: 對齊實作時程與方式，主要角色 Product Owner&#x2F;Team</li><li>Daily Standup: 對齊每日進度，全角色參與</li><li>Sprint Review: 對齊結果，全角色參與</li><li>Sprint Retrospective: 對齊改善，全角色參與</li></ul><h3 id="雖然實施部分的Scrum-是可能的，但結果就不是Scrum-了"><a href="#雖然實施部分的Scrum-是可能的，但結果就不是Scrum-了" class="headerlink" title="雖然實施部分的Scrum 是可能的，但結果就不是Scrum 了"></a>雖然實施部分的Scrum 是可能的，但結果就不是Scrum 了</h3><p>敏捷的特點：</p><ul><li>迭代且增量 - 小步快跑，頻繁交付</li><li>溝通導向 - 強調面對面溝通勝過文件</li><li>早期且持續交付 - 每個 Sprint 都有可展示的成果</li><li>擁抱變化 - 將變更視為常態而非例外</li></ul><p>在敏捷模式下，規格文件的角色變成了溝通工具和備忘錄。  </p><p>User Story、Acceptance Criteria 這些輕量級的規格，主要是為了確保團隊理解一致。</p><p>程式碼本身成為了真相的來源 - “Code is the truth”。</p><p>在迭代過後，這些文件不再有意義。</p><p>這解決了瀑布式的一些問題，但也帶來新的挑戰：</p><ul><li>知識容易流失（口頭溝通沒有記錄，使用團隊記憶）</li><li>技術債累積（快速迭代可能犧牲品質）</li><li>規格與實作的差距依然存在</li><li>實際上團隊&#x2F;文化等因素，在跑的只是 Scurm-but&#x2F;小瀑布&#x2F;隕石</li><li>商業化的行為已經扭曲原意，甚至作為 KOL 老王賣瓜的神主牌 (看看”敏捷社群”)</li><li>在大型產品&#x2F;專案仍然不足夠，因而衍生 SAFe&#x2F;LeSS 等方法論</li><li>淪為表面功夫</li></ul><h2 id="隕石開發流程-Alpha-Omega"><a href="#隕石開發流程-Alpha-Omega" class="headerlink" title="隕石開發流程(Alpha~Omega)"></a>隕石開發流程(Alpha~Omega)</h2><p>典型流程</p><h3 id="老闆一句話-→-隨便硬幹出來-→-夠奴就加班-→-交付疊加態-→-塊逃啊"><a href="#老闆一句話-→-隨便硬幹出來-→-夠奴就加班-→-交付疊加態-→-塊逃啊" class="headerlink" title="老闆一句話 → 隨便硬幹出來 → 夠奴就加班 → 交付疊加態 → 塊逃啊"></a>老闆一句話 → 隨便硬幹出來 → 夠奴就加班 → 交付疊加態 → 塊逃啊</h3><ul><li>老闆一句話：靈感一來就開幹，需求模糊。</li><li>隨便硬幹出來：原型被誤當產品，直接上線。</li><li>夠奴就加班：團隊燃燒工時與理智，一次衝到底。</li><li>交付疊加態：交付內容沒人知，時程沒人知，測沒測沒人知。</li><li>塊逃啊：事後檢討變成批鬥大會，成功不在你，但失敗一定有份。</li></ul><h3 id="特點與本質"><a href="#特點與本質" class="headerlink" title="特點與本質"></a>特點與本質</h3><p>高壓短命、方向即興、溝通崩壞、文件失效、驗收模糊。<br>看似混亂，其實是一種生存策略(實用主義)：</p><ul><li>PM 可保命：有 Demo、有交付，能交差。</li><li>行銷能吹噓：原型當 MVP，上媒體先贏聲量。</li><li>市場能行（騙）銷：先開賣、後補齊。</li><li>老闆能交代：有成果、有故事，股東就安心。</li><li>RD 隨便作，洗個經驗跳糟加薪比較快</li></ul><p>隕石開發不是技術問題，而是組織文化的選擇。</p><h2 id="這些流程的異同、優劣與困境"><a href="#這些流程的異同、優劣與困境" class="headerlink" title="這些流程的異同、優劣與困境"></a>這些流程的異同、優劣與困境</h2><p>瀑布、敏捷與隕石開發的差別，反映的是組織文化與生存策略。</p><p>瀑布式重規劃與控制，適合穩定需求與高風險專案，但變更成本高、回饋慢。</p><p>敏捷式重回饋與溝通，能快速交付並擁抱變化。</p><p>隕石式則靠爆發力求生存，短期有成效，不考慮長期品質與維運。</p><p>我的看法是新創成長到高原期時，就會從隕石走而敏捷，再大規模就會考慮瀑布&#x2F;LeSS&#x2F;SAFe，</p><p>而市場大部份都是中小企業，真的能成長成巨人者(amazon&#x2F;spotify&#x2F;netfilx)，</p><p>一定有它的原因，開發流程應該隨著公司業務成長，形成自已的文化，沒有一定的好壞，也不是可以輕易模仿的。</p><h2 id="工程師的自我要求"><a href="#工程師的自我要求" class="headerlink" title="工程師的自我要求"></a>工程師的自我要求</h2><p>我個人是傾向 XP 的開發模式，但是它的缺點是學習門檻高，  </p><p>對面試沒幫助，更多的公司寧願你寫白板題或刷 LeetCode。</p><p>團隊不願意投入，相關的 TDD&#x2F;ATDD&#x2F;BDD 或是測試左移更難導入小團隊之中。</p><p>高層如果沒有技術能力，無法識別好壞，就容易被唬弄，導致需求與實作有落差</p><h2 id="AI-SDD-流程-2024-未來"><a href="#AI-SDD-流程-2024-未來" class="headerlink" title="AI SDD 流程(2024~未來?)"></a>AI SDD 流程(2024~未來?)</h2><p>AI Agent 或 SDD 出現後能不能帶來改變?</p><p>或是可以帶來什麼幫助呢?</p><p>對工程師而言</p><ul><li>內建 TDD，但是工程師仍要學習其觀念</li><li>降低學習門檻，可以用更 Clean 的方式實作代碼</li><li>全權委託，但是工程師要對架構負責(變得更像 SA ?)</li><li>淘汰劣質工程師，ex 轉職班、就業班、刷題仔，但是有的很會行銷自已，會被唬弄過去</li></ul><p>對產品而言</p><ul><li>可以縮短想法到實作的距離</li><li>保持一定的品質，特別是你的工程師都是來自x成、x匠時…</li><li>自已開發，更高的回饋</li></ul><p>問題，認知的差距，人只能賺到自已認知能力內的錢</p><p>之前有一個網紅行銷使用 Agent 開發賣課，犯了最低級的錯誤</p><p>這是因為他缺乏資安的認知; 所以原本不是開發的人員會需要快速的學習相關的知識(但是 AI 可以將門檻降低)</p><p>另外一些反思，那種工程師看不上眼的程式(普遍社群上的工程師都在嘲諷)，</p><p>人家已經拿來行銷賣錢，或許工程師應該反向思考怎麼朝行銷&#x2F;產品靠攏</p><p>也或許這個低級錯誤也是行銷手段的一環?</p><p>接下來， 我將會用一系列的文章來試作 SDD 並分享我的看法</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://eiki.hatenablog.jp/entry/meteo_fall">隕石開發流程</a></li><li><a href="https://bclin.tw/2018/06/01/meteo-fall/">隕石開發流程-中文版</a></li><li><a href="https://martinfowler.com/articles/agile-aus-2018.html">Martin Fowler 澳洲演講筆記-變質的敏捷，回歸初衷。</a></li><li><a href="https://blog.cleancoder.com/uncle-bob/2018/08/28/CraftsmanshipMovement.html">軟體工匠的悲歌 The Tragedy of Craftsmanship.</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TL;DR&lt;/p&gt;
&lt;h2 id=&quot;簡介-SDD&quot;&gt;&lt;a href=&quot;#簡介-SDD&quot; class=&quot;headerlink&quot; title=&quot;簡介 SDD&quot;&gt;&lt;/a&gt;簡介 SDD&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;What is Spec-Driven Developm</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] 命令式程式碼重構到函數式 Pipe 流水線</title>
    <link href="https://blog.marsen.me/2025/09/17/2025/ai-refactor-rule-apply-dp/"/>
    <id>https://blog.marsen.me/2025/09/17/2025/ai-refactor-rule-apply-dp/</id>
    <published>2025-09-17T08:53:43.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有位小朋友在進行中文轉換規則的開發時，遇到了一些典型的程式碼異味。</p><p>這些異味提示著我們需要重構，你可以先挑戰看一下有沒有辦法識別。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重構前的程式碼</span></span><br><span class="line"><span class="title function_">apply</span>(<span class="attr">text</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> protectedChars = [<span class="string">&#x27;台&#x27;</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 標記階段</span></span><br><span class="line">  <span class="keyword">let</span> protectedText = text</span><br><span class="line">  protectedChars.<span class="title function_">forEach</span>(<span class="function">(<span class="params">char</span>) =&gt;</span> &#123;</span><br><span class="line">    protectedText = protectedText.<span class="title function_">replaceAll</span>(char, <span class="string">`&lt;&lt;&lt;<span class="subst">$&#123;char&#125;</span>&gt;&gt;&gt;`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 轉換階段</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="variable language_">this</span>.<span class="title function_">baseConverter</span>(protectedText)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 還原階段</span></span><br><span class="line">  protectedChars.<span class="title function_">forEach</span>(<span class="function">(<span class="params">char</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> convertedChar = <span class="variable language_">this</span>.<span class="title function_">baseConverter</span>(char)</span><br><span class="line">    result = result.<span class="title function_">replaceAll</span>(<span class="string">`&lt;&lt;&lt;<span class="subst">$&#123;convertedChar&#125;</span>&gt;&gt;&gt;`</span>, char)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 自訂轉換</span></span><br><span class="line">  result = <span class="variable language_">this</span>.<span class="title function_">customConverter</span>(result)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這篇文章記錄重構的過程，讓程式碼變得更加簡潔和易讀。</p><p>當然，這只是其中一種可能的重構方式，可能有別的解法，或是單純的接受它。</p><h2 id="壞味道"><a href="#壞味道" class="headerlink" title="壞味道"></a>壞味道</h2><p>原始的 <code>ChineseConversionRule</code> 中的 <code>apply</code> 方法存在以下問題：</p><ol><li><strong>過多中間變數</strong>：<code>text</code> → <code>protectedText</code> → <code>result</code></li><li><strong>命令式寫法</strong>：透過變數重新賦值來處理資料流</li><li><strong>邏輯分散</strong>：標記保護字符和還原的邏輯內嵌在主方法中</li></ol><p>過多的中間變數和命令式的寫法讓程式碼顯得冗長且不夠優雅。</p><p>protectedText、result、text　都是。</p><p>這裡的挑戰是要對原始的字串加工</p><p>在不破壞原本邏輯的情況下，保留擴充的彈性，並保持程式結構清晰、可維護。</p><p>可能有很多模式可以解決(Decorator &#x2F; Template Method &#x2F; Pipeline)</p><p>小朋友寫得也不差了，我們來試著讓它更好</p><h2 id="重構過程"><a href="#重構過程" class="headerlink" title="重構過程"></a>重構過程</h2><h3 id="階段一：消除中間變數"><a href="#階段一：消除中間變數" class="headerlink" title="階段一：消除中間變數"></a>階段一：消除中間變數</h3><p>第一步是消除不必要的中間變數，直接在同一個變數上操作：</p><p>可以看到修改後，只有 text 一個變數，還是傳入了的</p><p>越少變數，越不用花心思思考命名，減少認知負擔，而本質上這些冗餘的變數的確是同質可以刪除的</p><p>這是一種隱性的重複壞味道。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">apply</span>(<span class="attr">text</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> protectedChars = [<span class="string">&#x27;台&#x27;</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 直接操作 text 變數，消除 protectedText 和 result</span></span><br><span class="line">  protectedChars.<span class="title function_">forEach</span>(<span class="function">(<span class="params">char</span>) =&gt;</span> &#123;</span><br><span class="line">    text = text.<span class="title function_">replaceAll</span>(char, <span class="string">`&lt;&lt;&lt;<span class="subst">$&#123;char&#125;</span>&gt;&gt;&gt;`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  text = <span class="variable language_">this</span>.<span class="title function_">baseConverter</span>(text)</span><br><span class="line"></span><br><span class="line">  protectedChars.<span class="title function_">forEach</span>(<span class="function">(<span class="params">char</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> convertedChar = <span class="variable language_">this</span>.<span class="title function_">baseConverter</span>(char)</span><br><span class="line">    text = text.<span class="title function_">replaceAll</span>(<span class="string">`&lt;&lt;&lt;<span class="subst">$&#123;convertedChar&#125;</span>&gt;&gt;&gt;`</span>, char)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">customConverter</span>(text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="階段二：引入-Functional-Programming"><a href="#階段二：引入-Functional-Programming" class="headerlink" title="階段二：引入 Functional Programming"></a>階段二：引入 Functional Programming</h3><p>接下來導入函數式程式設計的概念，使用 pipe 模式來處理資料流：</p><p>這裡要先看懂 <code>pipe</code>，簡單理解它把一個初始值依序丟進多個函數，前一個輸出就是下一個的輸入。</p><p>可以看到一些明顯的壞味道，<strong>重複的 protectedChars</strong>，1 跟 3 本身是匿名函數，讀起來也沒那麼好理解，</p><p>這是重構必經之路，我們再往下走</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">apply</span>(<span class="attr">text</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> protectedChars = [<span class="string">&#x27;台&#x27;</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">pipe</span>(</span><br><span class="line">    text,</span><br><span class="line">    <span class="comment">// 1. 標記階段：將需要保護的字符標記為不轉換</span></span><br><span class="line">    <span class="function">(<span class="params">input</span>) =&gt;</span> protectedChars.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, char</span>) =&gt;</span></span><br><span class="line">      acc.<span class="title function_">replaceAll</span>(char, <span class="string">`&lt;&lt;&lt;<span class="subst">$&#123;char&#125;</span>&gt;&gt;&gt;`</span>), input),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 轉換階段：使用 OpenCC 進行轉換</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">baseConverter</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 還原階段：將標記的字符還原為原始字符</span></span><br><span class="line">    <span class="function">(<span class="params">input</span>) =&gt;</span> protectedChars.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, char</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> convertedChar = <span class="variable language_">this</span>.<span class="title function_">baseConverter</span>(char)</span><br><span class="line">      <span class="keyword">return</span> acc.<span class="title function_">replaceAll</span>(<span class="string">`&lt;&lt;&lt;<span class="subst">$&#123;convertedChar&#125;</span>&gt;&gt;&gt;`</span>, char)</span><br><span class="line">    &#125;, input),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 使用自訂轉換器進行模糊字詞的修正</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">customConverter</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自製的 pipe 函數</span></span><br><span class="line"><span class="keyword">private</span> pipe&lt;T&gt;(<span class="attr">value</span>: T, ...<span class="attr">fns</span>: <span class="title class_">Array</span>&lt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T&gt;): T &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span> <span class="title function_">fn</span>(acc), value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="階段三：職責分離"><a href="#階段三：職責分離" class="headerlink" title="階段三：職責分離"></a>階段三：職責分離</h3><p>將標記和還原邏輯抽取成獨立的私有方法：</p><p>將重複出現的 <code>protectedChars</code> 提升為類別屬性：</p><p>也不需要把匿名函數寫一坨在 pipe 裡面，這時要煩惱的只有方法的名字要怎麼才達意</p><p>但至少我們還有註解。</p><p>更進一步可以簡化方法內的參數名，因為 scope 很小，不會有認知負擔</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ChineseConversionRule</span> <span class="keyword">implements</span> <span class="title class_">IRule</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">baseConverter</span>: <span class="title class_">ConvertText</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">customConverter</span>: <span class="title class_">ConvertText</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> protectedChars = [<span class="string">&#x27;台&#x27;</span>]  <span class="comment">// 統一管理</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">apply</span>(<span class="attr">text</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">pipe</span>(</span><br><span class="line">    text,</span><br><span class="line">    <span class="comment">// 1. 標記階段：將需要保護的字符標記為不轉換</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">markProtectedChars</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 轉換階段：使用 OpenCC 進行轉換</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">baseConverter</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 還原階段：將標記的字符還原為原始字符</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">restoreProtectedChars</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 使用自訂轉換器進行模糊字詞的修正</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">customConverter</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 標記需要保護的字符</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> markProtectedChars = (<span class="attr">input</span>: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">protectedChars</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, c</span>) =&gt;</span> acc.<span class="title function_">replaceAll</span>(c, <span class="string">`&lt;&lt;&lt;<span class="subst">$&#123;c&#125;</span>&gt;&gt;&gt;`</span>), input)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 還原被標記的保護字符</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> restoreProtectedChars = (<span class="attr">input</span>: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">protectedChars</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, c</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> convertedChar = <span class="variable language_">this</span>.<span class="title function_">baseConverter</span>(c) <span class="comment">// 例如：&#x27;台&#x27; -&gt; &#x27;臺&#x27;</span></span><br><span class="line">      <span class="keyword">return</span> acc.<span class="title function_">replaceAll</span>(<span class="string">`&lt;&lt;&lt;<span class="subst">$&#123;convertedChar&#125;</span>&gt;&gt;&gt;`</span>, c)</span><br><span class="line">    &#125;, input)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="重構成果"><a href="#重構成果" class="headerlink" title="重構成果"></a>重構成果</h2><ol><li><strong>簡潔性</strong>：主方法從 20 行縮減到 8 行</li><li><strong>可讀性</strong>：資料流向清晰，從上到下一目了然</li><li><strong>可測試性</strong>：每個步驟都是純函數，可以獨立測試</li><li><strong>可維護性</strong>：職責分離，邏輯集中管理</li><li><strong>函數式</strong>：無副作用，符合 FP 原則</li></ol><h3 id="效能考量"><a href="#效能考量" class="headerlink" title="效能考量"></a>效能考量</h3><ul><li>測試結果顯示功能完全正常，262 個測試案例全數通過，這是個大前提，沒有測試沒有重構</li><li>重構過程中沒有改變演算法複雜度</li><li>Pipe 函數本身的開銷微乎其微</li></ul><h2 id="關於-Pipe-的選擇"><a href="#關於-Pipe-的選擇" class="headerlink" title="關於 Pipe 的選擇"></a>關於 Pipe 的選擇</h2><p>在重構過程中考慮過使用現成的函式庫：</p><ul><li><strong>Ramda</strong>：功能最完整的 FP 函式庫</li><li><strong>Lodash&#x2F;fp</strong>：輕量級選擇</li><li><strong>fp-ts</strong>：型別安全的 FP 函式庫</li></ul><p>最終選擇自製 pipe 函數的理由：</p><p>兩行程式碼，沒有多餘依賴，寫法完全貼合專案需求。</p><p>團隊看了就能用，不用再去學新的函式庫。</p><p>邏輯也很單純，後續維護起來相對輕鬆。</p><p>除非更大範圍的重複發生，不然不需要額外引用套件突增學習成本</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> pipe&lt;T&gt;(<span class="attr">value</span>: T, ...<span class="attr">fns</span>: <span class="title class_">Array</span>&lt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T&gt;): T &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span> <span class="title function_">fn</span>(acc), value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RD-反饋"><a href="#RD-反饋" class="headerlink" title="RD 反饋"></a>RD 反饋</h2><p>這次重構讓我深刻體會到函數式程式設計的優雅之處：</p><ol><li><strong>資料即流水線</strong>：透過 pipe 讓資料在各個函數間流動</li><li><strong>純函數的威力</strong>：每個步驟都可預測、可測試</li><li><strong>組合勝過繼承</strong>：透過函數組合建構複雜邏輯</li><li><strong>漸進式重構</strong>：一步步改善，降低風險</li></ol><p>從命令式到函數式的重構不僅讓程式碼變得更優雅，也提升了整體的可維護性。</p><p>雖然函數式程式設計有一定的學習曲線，但一旦掌握了基本概念，就能寫出更簡潔、更易懂的程式碼。</p><p>重構的關鍵在於：<strong>小步快跑，持續改善</strong>。每一次小的改進都讓程式碼朝著更好的方向發展，這正是軟體工藝精神的體現。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>嗯，小朋友很會用 AI 寫作文呢。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近有位小朋友在進行中文轉換規則的開發時，遇到了一些典型的程式碼異味。&lt;/p&gt;
&lt;p&gt;這些異味提示著我們需要重構，你可以先挑戰看一下有沒有辦</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] Clean Architecture 思考：避免過度設計</title>
    <link href="https://blog.marsen.me/2025/09/11/2025/clean-architecture-avoid-type-hell/"/>
    <id>https://blog.marsen.me/2025/09/11/2025/clean-architecture-avoid-type-hell/</id>
    <published>2025-09-11T07:23:42.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在實作強型別語言，經常會遇到一些僅次於命名的問題：</p><p>到底要建立多少層級的 DTO&#x2F;型別？</p><p>什麼時候該抽象，什麼時候該保持簡單？</p><p>這篇文章記錄一個前端要求帶來的反思，如何在「架構純粹性」與「實用主義」之間找到平衡點？</p><h2 id="問題場景"><a href="#問題場景" class="headerlink" title="問題場景"></a>問題場景</h2><p>系統架構為 TypeScript 並實作 Clean Architecture。</p><p>我們有一個比對系統，Domain Entity 中的 <code>statusCode</code> 定義為 <code>string | null</code>，</p><p>但前端要求 API 必須回傳 <code>string</code> 型別，允許空字串而不處理 null。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Domain Entity</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Comparison</span> &#123;</span><br><span class="line">  <span class="attr">statusCode</span>: <span class="built_in">string</span> | <span class="literal">null</span>  <span class="comment">// 業務邏輯：可能為空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端期望的 API 回應</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;statusCode&quot;</span>: <span class="string">&quot;&quot;</span>  <span class="comment">// 必須是 string，不能是 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解決方案演進"><a href="#解決方案演進" class="headerlink" title="解決方案演進"></a>解決方案演進</h2><h3 id="第一版：UseCase-層建立完整-DTO"><a href="#第一版：UseCase-層建立完整-DTO" class="headerlink" title="第一版：UseCase 層建立完整 DTO"></a>第一版：UseCase 層建立完整 DTO</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立回應 DTO</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ComparisonResponseDTO</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">statusCode</span>: <span class="built_in">string</span>  <span class="comment">// 轉換為 string</span></span><br><span class="line">  <span class="comment">// ... 其他欄位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 UseCase 回應型別</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">GetComparisonListResDTO</span> = <span class="title class_">IDataAndCount</span>&lt;<span class="title class_">ComparisonResponseDTO</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UseCase 中處理轉換</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">toResponseDTO</span>(<span class="attr">comparison</span>: <span class="title class_">Comparison</span>): <span class="title class_">ComparisonResponseDTO</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">statusCode</span>: comparison.<span class="property">statusCode</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起來很「Clean Architecture」，但真的有必要嗎？</p><p>關鍵觀點，有沒有可能過度設計了？</p><h3 id="最終方案：Controller-邊界處理"><a href="#最終方案：Controller-邊界處理" class="headerlink" title="最終方案：Controller 邊界處理"></a>最終方案：Controller 邊界處理</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller 直接處理轉換</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getComparisonList</span>(<span class="attr">req</span>: <span class="title class_">Request</span>, <span class="attr">res</span>: <span class="title class_">Response</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, count &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">getComparisonListUseCase</span>.<span class="title function_">execute</span>(input)</span><br><span class="line">  </span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: data.<span class="title function_">map</span>(<span class="function"><span class="params">comparison</span> =&gt;</span> (&#123;</span><br><span class="line">      ...comparison,</span><br><span class="line">      <span class="attr">statusCode</span>: comparison.<span class="property">statusCode</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;)),</span><br><span class="line">    pagination</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免型別地獄的原則"><a href="#避免型別地獄的原則" class="headerlink" title="避免型別地獄的原則"></a>避免型別地獄的原則</h2><h3 id="1-YAGNI-原則-You-Aren’t-Gonna-Need-It"><a href="#1-YAGNI-原則-You-Aren’t-Gonna-Need-It" class="headerlink" title="1. YAGNI 原則 (You Aren’t Gonna Need It)"></a>1. YAGNI 原則 (You Aren’t Gonna Need It)</h3><p>不要為了「完整性」而建立無意義的型別包裝</p><p>或是建立過多的 Mapper 類別</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 過度抽象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">GetComparisonListResDTO</span> = <span class="title class_">IDataAndCount</span>&lt;<span class="title class_">ComparisonResponseDTO</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 直接使用泛型</span></span><br><span class="line"><span class="title class_">IUseCase</span>&lt;<span class="title class_">GetComparisonListReqDTO</span>, <span class="title class_">IDataAndCount</span>&lt;<span class="title class_">ComparisonResponseDTO</span>&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-什麼時候需要抽象化？"><a href="#2-什麼時候需要抽象化？" class="headerlink" title="2. 什麼時候需要抽象化？"></a>2. 什麼時候需要抽象化？</h3><p>我的判斷，重複的時候，例如，當 2 個以上的 API 需要相同的型別時，才考慮抽象</p><p>也不排除可以能轉換極度複雜，這時有一個 Mapper 的導入反而可以減輕負擔時才導入。</p><p>架構／Design Pattern 應該服務 RD 而不是折摩 RD</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果只有一個 API 使用，直接 inline</span></span><br><span class="line">data.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (&#123; ...item, <span class="attr">statusCode</span>: item.<span class="property">statusCode</span> || <span class="string">&#x27;&#x27;</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果多個 API 都需要，才建立共用函數或型別</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">transformComparison</span> = (<span class="params">item: Comparison</span>) =&gt; (&#123;</span><br><span class="line">  ...item,</span><br><span class="line">  <span class="attr">statusCode</span>: item.<span class="property">statusCode</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-複雜度評估"><a href="#3-複雜度評估" class="headerlink" title="3. 複雜度評估"></a>3. 複雜度評估</h3><p>簡單的轉換邏輯不需要額外抽象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 簡單轉換，直接處理</span></span><br><span class="line"><span class="attr">statusCode</span>: comparison.<span class="property">statusCode</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 為簡單邏輯建立複雜抽象</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">transformStatusCode</span>(<span class="attr">statusCode</span>: <span class="built_in">string</span> | <span class="literal">null</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> statusCode || <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="實用主義-vs-理論完美"><a href="#實用主義-vs-理論完美" class="headerlink" title="實用主義 vs 理論完美"></a>實用主義 vs 理論完美</h2><h3 id="現代-TypeScript-最佳實踐"><a href="#現代-TypeScript-最佳實踐" class="headerlink" title="現代 TypeScript 最佳實踐"></a>現代 TypeScript 最佳實踐</h3><ol><li><strong>直接使用泛型</strong> - 避免不必要的 type alias</li><li><strong>減少型別層級</strong> - 除非有明確的業務意義</li><li><strong>保持簡潔</strong> - 不為了「完整性」而建立無意義的包裝</li></ol><h3 id="架構決策的平衡點"><a href="#架構決策的平衡點" class="headerlink" title="架構決策的平衡點"></a>架構決策的平衡點</h3><table><thead><tr><th>考量因素</th><th>過度設計</th><th>適度設計</th><th>設計不足</th></tr></thead><tbody><tr><td>型別數量</td><td>為每個 UseCase 建專屬 DTO</td><td>共用 + 泛型</td><td>沒有型別安全</td></tr><tr><td>轉換位置</td><td>每層都轉換</td><td>邊界處理</td><td>隨意放置</td></tr><tr><td>複雜度</td><td>型別地獄</td><td>恰到好處</td><td>難以維護</td></tr></tbody></table><h2 id="進階判斷：何時需要抽象，何時保持簡單？"><a href="#進階判斷：何時需要抽象，何時保持簡單？" class="headerlink" title="進階判斷：何時需要抽象，何時保持簡單？"></a>進階判斷：何時需要抽象，何時保持簡單？</h2><table><thead><tr><th>判斷角度</th><th>適合抽象化的情境</th><th>適合保持簡單的情境</th></tr></thead><tbody><tr><td><strong>使用頻率</strong></td><td>多個 UseCase 或 API 重複出現 → 建立共用型別&#x2F;函數</td><td>僅在單一 Controller 出現一次 → inline 即可</td></tr><tr><td><strong>業務語意</strong></td><td>欄位轉換具有業務意義（例：狀態機的一環） → 抽象進 Domain&#x2F;UseCase</td><td>純展示需求（例：<code>null → &quot;&quot;</code>） → 邊界層處理</td></tr><tr><td><strong>團隊規模與可讀性</strong></td><td>大團隊、專案壽命長 → 適度抽象，降低未來重構風險</td><td>小團隊、短期專案 → 保持簡單，降低溝通成本</td></tr><tr><td><strong>錯誤影響範圍</strong></td><td>錯誤會影響商業邏輯（例：金額精度） → 上升到 UseCase&#x2F;Domain</td><td>只影響 API 輸出表現（例：空字串 vs. null） → Controller 處理</td></tr><tr><td><strong>演進空間</strong></td><td>需求可能持續變化（欄位規則增多&#x2F;不同前端需求） → 抽象留彈性</td><td>需求相對穩定 → inline 保持簡潔</td></tr></tbody></table><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>Clean Architecture 的精神是<strong>將商業邏輯集中在核心，邊界負責格式適配</strong>。</p><p>不要被「層級完整性」綁架，重點是：</p><ol><li><strong>Domain 保持純粹</strong> - 反映真實的業務狀態</li><li><strong>UseCase 專注邏輯</strong> - 編排業務流程，不處理格式</li><li><strong>Controller 處理邊界</strong> - HTTP 格式轉換在此進行</li><li><strong>實用主義優先</strong> - 簡單的需求用簡單的方法</li></ol><p>記住：<strong>改動越少越好，沒有必要就不要建一大堆型別</strong>。</p><p>架構是為了解決問題，不是為了展示理論知識。當實用主義與理論衝突時，選擇能讓團隊更有生產力的方案。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在實作強型別語言，經常會遇到一些僅次於命名的問題：&lt;/p&gt;
&lt;p&gt;到底要建立多少層級的 DTO&amp;#x2F;型別？&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] PaddleOCR ONNX 模型發布到 Hugging Face Hub</title>
    <link href="https://blog.marsen.me/2025/09/05/2025/ai-hf-open-model-upload/"/>
    <id>https://blog.marsen.me/2025/09/05/2025/ai-hf-open-model-upload/</id>
    <published>2025-09-05T09:43:51.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>專案需要使用 PaddleOCR 進行文字辨識，但原始模型檔案需要從 PaddlePaddle 框架轉換成 ONNX 格式才能在不同環境中使用。</p><p>轉換完成後，面臨一個選擇：這些模型檔案要怎麼發布？放在專案內部？還是公開分享？</p><p>經過一番討論，決定將轉換後的 ONNX 模型公開發布到 Hugging Face Hub，一方面解決內部使用需求，另一方面也讓社群受益。</p><p>這篇記錄整個發布流程的實作過程與踩雷經驗。</p><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ul><li>將 5 個 PaddleOCR ONNX 模型檔案 (208MB) 發布到 Hugging Face</li><li>建立完整的使用文檔與授權聲明  </li><li>提供簡單的下載方式給其他開發者</li><li>確保版權合規 (原始模型為 Apache 2.0 授權)</li></ul><h2 id="模型檔案清單"><a href="#模型檔案清單" class="headerlink" title="模型檔案清單"></a>模型檔案清單</h2><p>轉換完成的檔案包含：</p><ul><li><code>PP-OCRv5_server_det_infer.onnx</code> (84MB) - 文字檢測</li><li><code>PP-OCRv5_server_rec_infer.onnx</code> (81MB) - 文字識別  </li><li><code>UVDoc_infer.onnx</code> (30MB) - 文檔矯正</li><li><code>PP-LCNet_x1_0_doc_ori_infer.onnx</code> (6.5MB) - 文檔方向</li><li><code>PP-LCNet_x1_0_textline_ori_infer.onnx</code> (6.5MB) - 文字方向</li><li><code>PP-OCRv5_server_rec_infer.yml</code> (145KB) - 配置檔案</li></ul><h2 id="平台選擇：為什麼是-Hugging-Face？"><a href="#平台選擇：為什麼是-Hugging-Face？" class="headerlink" title="平台選擇：為什麼是 Hugging Face？"></a>平台選擇：為什麼是 Hugging Face？</h2><p>本來考慮幾個選項：</p><ul><li><strong>GitLab</strong>：現有平台，整合容易</li><li><strong>GitHub</strong>：開發者友好，但大檔案處理麻煩  </li><li><strong>Hugging Face</strong>：AI 模型專業平台</li></ul><p>最終選擇 Hugging Face 的原因：</p><ul><li>✅ 完全免費，50GB 額度綽綽有餘</li><li>✅ 原生支援 ONNX 格式</li><li>✅ 內建 Git LFS，大檔案處理無痛</li><li>✅ 全球 CDN，下載速度快</li><li>✅ 社群友好，可能吸引貢獻者</li></ul><h2 id="實作過程"><a href="#實作過程" class="headerlink" title="實作過程"></a>實作過程</h2><h3 id="Phase-1-準備階段"><a href="#Phase-1-準備階段" class="headerlink" title="Phase 1: 準備階段"></a>Phase 1: 準備階段</h3><p>首先建立 Hugging Face 帳號並設定環境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝 HF CLI</span></span><br><span class="line">uv add huggingface_hub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 Token (需要 Write 權限)</span></span><br><span class="line"><span class="built_in">export</span> HF_TOKEN=<span class="string">&quot;your_token_here&quot;</span></span><br></pre></td></tr></table></figure><p>建立模型 Repository：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> huggingface_hub <span class="keyword">import</span> create_repo, whoami</span><br><span class="line"></span><br><span class="line"><span class="comment"># 驗證登入</span></span><br><span class="line">user = whoami()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;登入用戶: <span class="subst">&#123;user[<span class="string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 repository  </span></span><br><span class="line">repo_url = create_repo(</span><br><span class="line">    repo_id=<span class="string">&quot;paddleocr-test&quot;</span>,</span><br><span class="line">    repo_type=<span class="string">&quot;model&quot;</span>,</span><br><span class="line">    private=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Repository 建立成功: <span class="subst">&#123;repo_url&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="Phase-2-上傳模型檔案"><a href="#Phase-2-上傳模型檔案" class="headerlink" title="Phase 2: 上傳模型檔案"></a>Phase 2: 上傳模型檔案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HF_TOKEN=your_token</span><br><span class="line">hf upload marsena/paddleocr-test ./model_cache/paddleocr_onnx/ --repo-type=model</span><br></pre></td></tr></table></figure><p>實際上傳時間約 3 分鐘，比預期快很多。</p><h3 id="Phase-3-撰寫文檔"><a href="#Phase-3-撰寫文檔" class="headerlink" title="Phase 3: 撰寫文檔"></a>Phase 3: 撰寫文檔</h3><p>Hugging Face 的 README.md 比一般 GitHub 專案更重要，因為它就是模型的門面。</p><p>撰寫重點：</p><ol><li><strong>清晰的模型說明</strong>：每個檔案的用途</li><li><strong>具體的使用範例</strong>：Python 程式碼示範</li><li><strong>完整的授權聲明</strong>：避免版權爭議</li><li><strong>技術細節</strong>：系統需求、相容性</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># PaddleOCR ONNX Models</span></span><br><span class="line"></span><br><span class="line">本倉庫提供 PaddleOCR v5 的 ONNX 格式模型檔案...</span><br><span class="line"></span><br><span class="line"><span class="section">## 快速開始</span></span><br><span class="line"></span><br><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">from huggingface_hub import hf_hub_download</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 下載檢測模型</span></span><br><span class="line"><span class="code">det_model = hf_hub_download(</span></span><br><span class="line"><span class="code">    repo_id=&quot;marsena/paddleocr-test&quot;,</span></span><br><span class="line"><span class="code">    filename=&quot;PP-OCRv5_server_det_infer.onnx&quot;</span></span><br><span class="line"><span class="code">)</span></span><br></pre></td></tr></table></figure><p>需要注意 YAML metadata 的格式問題，HF 會檢查語法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">onnx</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ocr</span>  </span><br><span class="line"><span class="bullet">-</span> <span class="string">paddleocr</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">computer-vision</span></span><br><span class="line"><span class="attr">license:</span> <span class="string">apache-2.0</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="Phase-4-測試驗證"><a href="#Phase-4-測試驗證" class="headerlink" title="Phase 4: 測試驗證"></a>Phase 4: 測試驗證</h3><p>上傳完成後務必測試下載功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 測試單檔下載</span></span><br><span class="line">hf download marsena/paddleocr-test PP-OCRv5_server_det_infer.onnx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試整包下載</span></span><br><span class="line">hf download marsena/paddleocr-test --local-dir ./test_download \</span><br><span class="line">  --exclude <span class="string">&quot;README.md&quot;</span> --exclude <span class="string">&quot;.gitattributes&quot;</span></span><br></pre></td></tr></table></figure><h2 id="一些要注意的小問題"><a href="#一些要注意的小問題" class="headerlink" title="一些要注意的小問題"></a>一些要注意的小問題</h2><h3 id="HF-Token-權限設定"><a href="#HF-Token-權限設定" class="headerlink" title="HF Token 權限設定"></a>HF Token 權限設定</h3><ul><li><strong>Read</strong>：只能下載</li><li><strong>Write</strong>：可以上傳模型  </li><li><strong>Admin</strong>：可以刪除 repo</li></ul><p>建立 token 時記得選擇 <strong>Write</strong> 權限。</p><h3 id="Git-LFS-檔案大小限制"><a href="#Git-LFS-檔案大小限制" class="headerlink" title="Git LFS 檔案大小限制"></a>Git LFS 檔案大小限制</h3><p>Hugging Face 對單檔大小有限制：</p><ul><li>一般檔案：&lt; 10MB</li><li>LFS 檔案：&lt; 50GB</li></ul><p>我們的最大檔案 84MB，自動走 LFS 沒問題。</p><h3 id="背景上傳的重要性"><a href="#背景上傳的重要性" class="headerlink" title="背景上傳的重要性"></a>背景上傳的重要性</h3><p>大檔案上傳可能需要 10-30 分鐘，SSH 連線容易斷開。務必使用 <code>nohup</code> 或 <code>screen</code>。</p><h3 id="README-的-YAML-語法檢查"><a href="#README-的-YAML-語法檢查" class="headerlink" title="README 的 YAML 語法檢查"></a>README 的 YAML 語法檢查</h3><p>Hugging Face 會檢查 YAML metadata 語法，格式錯誤會有警告（但不影響功能）。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>發布完成後，其他開發者可以這樣使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下載所有模型到專案目錄</span></span><br><span class="line">hf download marsena/paddleocr-test \</span><br><span class="line">  --local-dir ./model_cache/paddleocr_onnx \</span><br><span class="line">  --exclude <span class="string">&quot;README.md&quot;</span> \</span><br><span class="line">  --exclude <span class="string">&quot;.gitattributes&quot;</span></span><br></pre></td></tr></table></figure><p>或在 Python 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> huggingface_hub <span class="keyword">import</span> hf_hub_download</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">model_files = [</span><br><span class="line">    <span class="string">&quot;PP-OCRv5_server_det_infer.onnx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PP-OCRv5_server_rec_infer.onnx&quot;</span>, </span><br><span class="line">    <span class="string">&quot;UVDoc_infer.onnx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PP-LCNet_x1_0_doc_ori_infer.onnx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PP-LCNet_x1_0_textline_ori_infer.onnx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PP-OCRv5_server_rec_infer.yml&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">cache_dir = <span class="string">&quot;model_cache/paddleocr_onnx&quot;</span></span><br><span class="line">os.makedirs(cache_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> model_files:</span><br><span class="line">    hf_hub_download(</span><br><span class="line">        repo_id=<span class="string">&quot;marsena/paddleocr-test&quot;</span>,</span><br><span class="line">        filename=file,</span><br><span class="line">        local_dir=cache_dir</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>整個發布流程花費約 5-8 小時：</p><ul><li><strong>準備和上傳</strong>：2 小時</li><li><strong>文檔撰寫</strong>：3 小時  </li><li><strong>系統整合</strong>：2 小時</li><li><strong>測試驗證</strong>：1 小時</li></ul><p>Hugging Face Hub 確實是發布 AI 模型的好選擇，特別是：</p><ol><li><strong>無痛 LFS</strong>：大檔案處理完全自動化</li><li><strong>全球加速</strong>：下載速度比自建服務快</li><li><strong>社群生態</strong>：容易被發現和使用</li><li><strong>版本控制</strong>：Git-based，開發者熟悉</li></ol><p>如果你也有 ONNX 模型需要分享，不妨考慮 Hugging Face Hub。畢竟專業的事交給專業的平台來做，我們專注在模型本身就好。</p><h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ul><li><a href="https://huggingface.co/marsena/paddleocr-test">發布的模型</a></li><li><a href="https://huggingface.co/docs">Hugging Face 文檔</a></li><li><a href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR 原始專案</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;專案需要使用 PaddleOCR 進行文字辨識，但原始模型檔案需要從 PaddlePaddle 框架轉換成 ONNX 格式才</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] 建立私有 Python Package Registry - 以 ONNX Runtime 為例</title>
    <link href="https://blog.marsen.me/2025/09/02/2025/gitlab-python-package-registry/"/>
    <id>https://blog.marsen.me/2025/09/02/2025/gitlab-python-package-registry/</id>
    <published>2025-09-02T06:42:42.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在開發 AI 應用時，我們遇到一些特殊的依賴管理需求，需要私有 Registry</p><p>在這個專案中，我們遇到了幾個挑戰：</p><ol><li><strong>平台特化需求</strong>：Jetson 平台需要特製的 <code>onnxruntime-gpu</code> 版本，PyPI 上沒有現成的</li><li><strong>版本一致性</strong>：確保所有環境（開發、測試、生產）使用完全相同的依賴版本</li><li><strong>安全性考量</strong>：避免依賴外部不穩定的來源，降低供應鏈攻擊風險</li><li><strong>內部套件分發</strong>：團隊開發的內部工具需要有管道分發</li></ol><h2 id="私有-Registry-運作流程"><a href="#私有-Registry-運作流程" class="headerlink" title="私有 Registry 運作流程"></a>私有 Registry 運作流程</h2><p>私有 Package Registry 的運作包含三個階段：</p><ol><li><p><strong>套件發布階段</strong><br>開發者 → 推送程式碼 → GitLab CI&#x2F;CD → 構建套件 → 推送至 Package Registry</p></li><li><p><strong>套件管理階段</strong><br>Package Registry ← 特製版本套件（如 onnxruntime-gpu for Jetson）<br>　　　　　　　　　← 內部工具套件<br>　　　　　　　　　← 安全審核過的第三方套件</p></li><li><p><strong>套件使用階段</strong><br>專案 pyproject.toml → 指定私有來源 → 安裝依賴 → 取得正確版本</p></li></ol><p>這樣確保所有環境都使用一致且可控的套件版本。</p><h2 id="實作步驟"><a href="#實作步驟" class="headerlink" title="實作步驟"></a>實作步驟</h2><h3 id="發佈套件到-GitLab-Package-Registry"><a href="#發佈套件到-GitLab-Package-Registry" class="headerlink" title="發佈套件到 GitLab Package Registry"></a>發佈套件到 GitLab Package Registry</h3><p>在設定和使用私有 Registry 之前，我們需要先將套件上傳到 GitLab Package Registry。</p><h4 id="使用-twine-上傳套件"><a href="#使用-twine-上傳套件" class="headerlink" title="使用 twine 上傳套件"></a>使用 twine 上傳套件</h4><p>twine 是 Python 官方推薦的套件上傳工具，會自動從 wheel 檔案中提取 metadata：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝 twine</span></span><br><span class="line">pip install twine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上傳到 GitLab PyPI registry</span></span><br><span class="line">twine upload --repository-url https://gitlab.com/api/v4/projects/&#123;PROJECT_ID&#125;/packages/pypi \</span><br><span class="line">             --username gitlab+deploy-token-&#123;TOKEN_ID&#125; \</span><br><span class="line">             --password &#123;TOKEN&#125; \</span><br><span class="line">             your_package.whl</span><br></pre></td></tr></table></figure><p>實際範例（以 ONNX Runtime 為例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">twine upload --repository-url https://gitlab.com/api/v4/projects/70410750/packages/pypi \</span><br><span class="line">             --username gitlab+deploy-token-9097451 \</span><br><span class="line">             --password gldt-tQVwLxzydZBhn3WWnwtt \</span><br><span class="line">             onnxruntime_gpu-1.23.0-cp310-cp310-linux_aarch64.whl</span><br></pre></td></tr></table></figure><h3 id="設定-GitLab-Package-Registry"><a href="#設定-GitLab-Package-Registry" class="headerlink" title="設定 GitLab Package Registry"></a>設定 GitLab Package Registry</h3><p>首先，在 GitLab 專案中啟用 Package Registry，並建立 Deploy Token：</p><p>在 GitLab 專案設定中建立 Deploy Token, Settings → Repository → Deploy Tokens</p><p>權限：read_package_registry, write_package_registry</p><p>記下 token ID 和 token 值，格式如下：</p><ul><li><p>Token ID: deploy-token-{ID}</p></li><li><p>Token: {TOKEN}</p></li></ul><h3 id="取得-Project-ID"><a href="#取得-Project-ID" class="headerlink" title="取得 Project ID"></a>取得 Project ID</h3><p>有三種方式可以找到 GitLab Project ID：</p><p>從專案首頁：</p><p>進入你的 GitLab 專案首頁<br>Project ID 會顯示在專案名稱下方<br>例如：Project ID: 12345678</p><p>從專案設定頁面：</p><p>進入 Settings → General<br>在最上方的 “General project settings” 區塊<br>可以看到 Project ID</p><p>從 GitLab API：</p><p>如果你在 CI&#x2F;CD pipeline 中，可以直接使用環境變數 $CI_PROJECT_ID<br>這個變數會自動帶入當前專案的 ID</p><h3 id="配置專案的依賴管理"><a href="#配置專案的依賴管理" class="headerlink" title="配置專案的依賴管理"></a>配置專案的依賴管理</h3><p>在 <code>pyproject.toml</code> 中設定私有 registry：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定義私有 index</span></span><br><span class="line"><span class="section">[[tool.uv.index]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;onnx&quot;</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">&quot;https://gitlab+deploy-token-&#123;TOKEN_ID&#125;:&#123;TOKEN&#125;@gitlab.com/api/v4/projects/&#123;PROJECT_ID&#125;/packages/pypi/simple&quot;</span></span><br><span class="line"><span class="attr">default</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定套件來源</span></span><br><span class="line"><span class="section">[tool.uv.sources]</span></span><br><span class="line"><span class="attr">onnxruntime-gpu</span> = &#123; index = <span class="string">&quot;onnx&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多平台依賴策略</span></span><br><span class="line"><span class="attr">dependencies</span> = [</span><br><span class="line">    <span class="comment"># macOS ARM64 使用 CPU 版本</span></span><br><span class="line">    <span class="string">&quot;onnxruntime==1.19.0; sys_platform == &#x27;darwin&#x27; and platform_machine == &#x27;arm64&#x27;&quot;</span>,</span><br><span class="line">    <span class="comment"># Jetson 使用私有倉庫的 GPU 版本</span></span><br><span class="line">    <span class="string">&quot;onnxruntime-gpu; sys_platform == &#x27;linux&#x27; and platform_machine == &#x27;aarch64&#x27;&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這裡的關鍵是使用條件依賴，根據不同平台安裝不同版本的套件。</p><h3 id="開發者使用私有-Registry"><a href="#開發者使用私有-Registry" class="headerlink" title="開發者使用私有 Registry"></a>開發者使用私有 Registry</h3><p>根據專案的安全策略，RD 有幾種方式存取私有 registry：</p><h4 id="選項-1：Token-內嵌在-pyproject-toml（簡單但不安全）"><a href="#選項-1：Token-內嵌在-pyproject-toml（簡單但不安全）" class="headerlink" title="選項 1：Token 內嵌在 pyproject.toml（簡單但不安全）"></a>選項 1：Token 內嵌在 pyproject.toml（簡單但不安全）</h4><p>如果 <code>pyproject.toml</code> 中已經包含完整的認證 URL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接安裝依賴</span></span><br><span class="line">uv <span class="built_in">sync</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 pip</span></span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><h4 id="選項-2：使用環境變數（推薦）"><a href="#選項-2：使用環境變數（推薦）" class="headerlink" title="選項 2：使用環境變數（推薦）"></a>選項 2：使用環境變數（推薦）</h4><p>在 <code>pyproject.toml</code> 中使用佔位符：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span> = <span class="string">&quot;https://deploy-token-&#123;TOKEN_ID&#125;:$&#123;GITLAB_TOKEN&#125;@gitlab.com/api/v4/projects/&#123;PROJECT_ID&#125;/packages/pypi/simple&quot;</span></span><br></pre></td></tr></table></figure><p>RD 需要設定環境變數：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GITLAB_TOKEN=your_deploy_token</span><br><span class="line">uv <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><h4 id="選項-3：使用認證檔案"><a href="#選項-3：使用認證檔案" class="headerlink" title="選項 3：使用認證檔案"></a>選項 3：使用認證檔案</h4><p>設定 pip 或 uv 的認證檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 pip 配置</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ~/.pip/pip.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[global]</span></span><br><span class="line"><span class="string">extra-index-url = https://deploy-token-&#123;TOKEN_ID&#125;:&#123;TOKEN&#125;@gitlab.com/api/v4/projects/&#123;PROJECT_ID&#125;/packages/pypi/simple</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h4 id="選項-4：企業內網存取"><a href="#選項-4：企業內網存取" class="headerlink" title="選項 4：企業內網存取"></a>選項 4：企業內網存取</h4><p>如果使用企業內網或 VPN：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 連接 VPN 後直接使用</span></span><br><span class="line">uv <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><h3 id="CI-CD-中存取私有-Registry"><a href="#CI-CD-中存取私有-Registry" class="headerlink" title="CI&#x2F;CD 中存取私有 Registry"></a>CI&#x2F;CD 中存取私有 Registry</h3><p>專案在 GitLab CI&#x2F;CD 中需要存取私有 Registry 時，有以下幾種方式：</p><h4 id="方法-1：使用-CI-JOB-TOKEN（推薦）"><a href="#方法-1：使用-CI-JOB-TOKEN（推薦）" class="headerlink" title="方法 1：使用 CI_JOB_TOKEN（推薦）"></a>方法 1：使用 CI_JOB_TOKEN（推薦）</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitlab-ci.yml</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">PIP_INDEX_URL:</span> <span class="string">https://gitlab-ci-token:$&#123;CI_JOB_TOKEN&#125;@gitlab.com/api/v4/projects/$&#123;REGISTRY_PROJECT_ID&#125;/packages/pypi/simple</span></span><br><span class="line">  <span class="attr">PIP_EXTRA_INDEX_URL:</span> <span class="string">https://pypi.org/simple</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-e</span> <span class="string">.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="comment"># 其他構建步驟</span></span><br></pre></td></tr></table></figure><h4 id="方法-2：使用-Deploy-Token"><a href="#方法-2：使用-Deploy-Token" class="headerlink" title="方法 2：使用 Deploy Token"></a>方法 2：使用 Deploy Token</h4><p>在 CI&#x2F;CD 變數中設定 <code>GITLAB_DEPLOY_TOKEN</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">export</span> <span class="string">PIP_INDEX_URL=&quot;https://deploy-token-&#123;TOKEN_ID&#125;:$&#123;GITLAB_DEPLOY_TOKEN&#125;@gitlab.com/api/v4/projects/$&#123;REGISTRY_PROJECT_ID&#125;/packages/pypi/simple&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-e</span> <span class="string">.</span></span><br></pre></td></tr></table></figure><h4 id="方法-3：配合-uv-使用"><a href="#方法-3：配合-uv-使用" class="headerlink" title="方法 3：配合 uv 使用"></a>方法 3：配合 uv 使用</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">before_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">export</span> <span class="string">GITLAB_TOKEN=$&#123;CI_JOB_TOKEN&#125;</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">uv</span> <span class="string">sync</span></span><br><span class="line">    <span class="bullet">-</span> <span class="comment"># 其他構建步驟</span></span><br></pre></td></tr></table></figure><h2 id="常見問題與解決方案"><a href="#常見問題與解決方案" class="headerlink" title="常見問題與解決方案"></a>常見問題與解決方案</h2><h3 id="Deploy-Token-權限不足？"><a href="#Deploy-Token-權限不足？" class="headerlink" title="Deploy Token 權限不足？"></a>Deploy Token 權限不足？</h3><p>確保 Deploy Token 有 <code>read_package_registry</code> 和 <code>write_package_registry</code> 權限。</p><h3 id="套件版本衝突？"><a href="#套件版本衝突？" class="headerlink" title="套件版本衝突？"></a>套件版本衝突？</h3><p>使用 <code>uv</code> 的 resolution markers 功能，明確指定版本解析策略。</p><h3 id="Registry-URL-格式錯誤？"><a href="#Registry-URL-格式錯誤？" class="headerlink" title="Registry URL 格式錯誤？"></a>Registry URL 格式錯誤？</h3><p>GitLab PyPI registry URL 格式為：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitlab.com/api/v4/projects/&#123;PROJECT_ID&#125;/packages/pypi/simple</span><br></pre></td></tr></table></figure><p>注意將 <code>{PROJECT_ID}</code> 替換為實際的專案 ID。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過建立私有 Package Registry，我們成功解決了：</p><ul><li><strong>特製版本管理</strong>：Jetson 平台的特殊 ONNX Runtime 版本需求</li><li><strong>依賴一致性</strong>：所有環境使用相同版本的套件</li><li><strong>安全性提升</strong>：減少對外部來源的依賴</li><li><strong>存取便利性</strong>：開發者和 CI&#x2F;CD 都能輕鬆存取私有套件</li></ul><p>這個架構不僅適用於 ONNX Runtime，也可以擴展到其他需要特殊管理的依賴套件。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在開發 AI 應用時，我們遇到一些特殊的依賴管理需求，需要私有 Registry&lt;/p&gt;
&lt;p&gt;在這個專案中，我們遇到了幾個</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] 怎麼建立一個網站？(四) - 自訂網域 EMail 收寄信(使用 Cloudflare 與 Brevo)</title>
    <link href="https://blog.marsen.me/2025/08/27/2025/brevo_smtp/"/>
    <id>https://blog.marsen.me/2025/08/27/2025/brevo_smtp/</id>
    <published>2025-08-27T14:19:02.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>四年前「<a href="https://blog.marsen.me/2020/10/22/2020/google_domain_forward_mail/">怎麼建立一個網站？(四) - 自訂網域 EMail</a>」已過時了，<br>當時透過 Google Domain 設定了自己的網域信箱，那種擁有 <code>admin@marsen.me</code> 的專業度真的是滿到溢出來。</p><p>但是，現實總是殘酷的。</p><p>2023 年 Google Domain 宣布停止營運，我選擇轉移到了 Cloudflare。</p><p>更悲劇的是，Gmail 的應用程式密碼也在安全性考量下越來越不被推薦使用。</p><p>Google 對 Gmail SMTP 的使用限制越來越嚴格。</p><p>在開啟 2FA 的情況下，只能使用應用程式密碼，但是 Google 本身也不推薦這樣使用密碼。</p><h2 id="問題分析"><a href="#問題分析" class="headerlink" title="問題分析"></a>問題分析</h2><p>現有問題：</p><ul><li>Google Domain 停止服務，Cloudflare 雖然接管了域名，但沒有提供類似的信箱轉發服務</li><li>Gmail 無法繼續使用 Email Forwarding 的密碼方式不再被推薦使用，我也沒有查到替代方案</li></ul><p>需求：</p><ul><li>能夠使用 <code>admin@marsen.me</code> 收信，已完成(在 Cloudflare 設定 Email Forwarding)</li><li>能夠以 <code>admin@marsen.me</code> 寄信，而且不會被標記為可疑郵件</li><li>免費或便宜的解決方案</li><li>設定要簡單快速</li></ul><h2 id="技術選擇的思考"><a href="#技術選擇的思考" class="headerlink" title="技術選擇的思考"></a>技術選擇的思考</h2><p>經過一番調研，我把目標鎖定在幾個主流的 SMTP 服務：</p><ol><li><strong>Brevo (原 Sendinblue)</strong>：免費額度每天 300 封信，付費方案 $25&#x2F;月</li><li><strong>Mailjet</strong>：免費額度每天 200 封信，付費方案 $17&#x2F;月</li><li><strong>SendGrid</strong>：免費額度每天 100 封信</li><li><strong>Amazon SES</strong>：按量計費，超便宜但設定複雜</li></ol><p>綜合考量下，我選擇 <strong>Brevo</strong> 的理由：</p><ul><li><strong>價格最划算</strong>：免費額度最高（300封&#x2F;天），對個人使用綽綽有餘</li><li><strong>功能完整</strong>：不只是 SMTP，還有完整的郵件行銷功能</li><li><strong>設定超快</strong>：API 整合簡單，文件齊全</li><li><strong>信譽良好</strong>：歐洲公司，GDPR 合規，信件到達率高</li></ul><p>備案是 Mailjet，但既然 Brevo 實際使用很順利，我就沒有去試了。</p><h2 id="實作過程"><a href="#實作過程" class="headerlink" title="實作過程"></a>實作過程</h2><h3 id="Step-1-註冊-Brevo-帳號"><a href="#Step-1-註冊-Brevo-帳號" class="headerlink" title="Step 1: 註冊 Brevo 帳號"></a>Step 1: 註冊 Brevo 帳號</h3><p>前往 <a href="https://brevo.com/">Brevo 官網</a> 註冊免費帳號，過程很簡單，不需要信用卡。</p><p>可以用 Google 帳號註冊，但是填寫一些資料，總體來說並不冗長繁瑣。</p><h3 id="Step-2-設定-Sending-Domain"><a href="#Step-2-設定-Sending-Domain" class="headerlink" title="Step 2: 設定 Sending Domain"></a>Step 2: 設定 Sending Domain</h3><p>登入後台，進入「Senders &amp; IP」→「Domains」，添加你的域名（如 <code>marsen.me</code>）。</p><p>Brevo 會要求你在 DNS 域名設定中添加幾筆記錄(我是使用 Cloudflare)來驗證域名擁有權：</p><p>設定過程也很傻瓜點擊跟著操作就會引導你登入 Cloudflare 的後台，不保証其他域名商有這麼方便，</p><p>會在 Cloudflare DNS 管理中添加：2 筆 CNAME 與 2 筆 TXT 記錄，應該是讓 Brevo 驗証網域所有權的。</p><p>DNS 生效後，Brevo 就會驗證通過。</p><h3 id="Step-3-設定收信"><a href="#Step-3-設定收信" class="headerlink" title="Step 3: 設定收信"></a>Step 3: 設定收信</h3><p>設定 Email Forwarding 這部分我直接在 Cloudflare 設定：</p><p>「Email」→「Email Routing」→「Routes」</p><p>添加轉發規則：</p><p>從：<code>admin@marsen.me</code> 到我的 gmail</p><p>這樣就能收到寄往自訂域名的信了。</p><h3 id="Step-4-設定-Gmail-使用-Brevo-SMTP"><a href="#Step-4-設定-Gmail-使用-Brevo-SMTP" class="headerlink" title="Step 4: 設定 Gmail 使用 Brevo SMTP"></a>Step 4: 設定 Gmail 使用 Brevo SMTP</h3><p>進入 Gmail 設定 &gt; 帳戶和匯入 &gt; 新增另一個電子郵件地址：</p><ul><li>名稱：Marsen</li><li>電子郵件地址：<code>admin@marsen.me</code></li><li>SMTP 伺服器：<code>smtp-relay.brevo.com</code></li><li>通訊埠：587</li><li>使用者名稱：你的 Brevo 帳號 email</li><li>密碼：去 Brevo 後台「Account Settings」→「SMTP &amp; API」生成的 SMTP Key</li><li>設定完成後，Gmail 會寄驗證信，確認後收到的信才不會有警告。</li></ul><h2 id="實測結果"><a href="#實測結果" class="headerlink" title="實測結果"></a>實測結果</h2><p>設定完成實測：</p><ul><li>✅ 收信正常：寄到 <code>admin@marsen.me</code> 的信都能在 Gmail 收到</li><li>✅ 寄信正常：從 Gmail 可以選擇用 <code>admin@marsen.me</code> 寄信</li><li>✅ 信譽良好：收件者不會看到「未驗證」警告</li></ul><p>整個設定過程不到 20 分鐘。</p><h2 id="一些要注意的小問題"><a href="#一些要注意的小問題" class="headerlink" title="一些要注意的小問題"></a>一些要注意的小問題</h2><p><strong>DNS 生效時間</strong><br>SPF、DKIM 記錄可能需要幾個小時才會完全生效，不要急著測試。</p><p>但是我實測約幾分鐘就生效了。</p><p><strong>SMTP Key 不是密碼</strong><br>Brevo 的 SMTP Key 是專門給 API 和 SMTP 用的，不是你登入密碼。</p><p><strong>免費額度限制</strong><br>每天 300 封信對我個人使用很夠，但如果你要大量寄信，記得升級付費方案。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://brevo.com/">Brevo 官方網站</a></li><li><a href="https://support.google.com/accounts/answer/185833">重要事項：我們不建議使用應用程式密碼</a></li><li><a href="https://blog.marsen.me/2020/10/22/2020/google_domain_forward_mail/">怎麼建立一個網站？(四) - 自訂網域 EMail</a> (2020年舊文)</li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="https://blog.marsen.me/2016/08/21/2016/setting_DNS_with_google/">怎麼建立一個網站？(一)</a></li><li><a href="https://blog.marsen.me/2016/08/28/2016/how_to_use_github_page/">怎麼建立一個網站？(二)</a></li><li><a href="https://blog.marsen.me/2016/09/04/2016/http2_by_cloudflare/">怎麼建立一個網站？(三)</a></li><li><del><a href="https://blog.marsen.me/2020/10/22/2020/google_domain_forward_mail/">怎麼建立一個網站？(四)</a></del></li><li><a href="https://blog.marsen.me/2025/08/27/2025/brevo_smtp/">怎麼建立一個網站？(四)</a></li><li><a href="https://blog.marsen.me/2021/04/06/2021/create_404/">怎麼建立一個網站？(五)</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;四年前「&lt;a href=&quot;https://blog.marsen.me/2020/10/22/2020/google_dom</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [架構筆記] Clean Architecture 分層職責的反思</title>
    <link href="https://blog.marsen.me/2025/08/12/2025/backend-architecture-layer-design-principles/"/>
    <id>https://blog.marsen.me/2025/08/12/2025/backend-architecture-layer-design-principles/</id>
    <published>2025-08-12T05:29:15.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近在 Code Review 時遇到一個有趣的題目：</p><p>檔案上傳功能中，檔案編碼修復應該放在 Middleware 還是 UseCase？</p><p>這個問題引發了我對 Clean Architecture 分層職責的重新思考，與團隊背後的設計哲學。</p><h2 id="問題背景"><a href="#問題背景" class="headerlink" title="問題背景"></a>問題背景</h2><p>在一個採用 Clean Architecture 的專案中，我們有兩個檔案上傳功能：</p><ul><li><strong>知識庫檔案上傳</strong> - 支援 PDF、Word、圖片等多種格式</li><li><strong>合約檔案上傳</strong> - 原始合約支援 PDF&#x2F;Word，簽署後合約只支援 PDF</li></ul><p>當前系統架構包含：</p><ul><li><strong>Middleware</strong> - Express 中介軟體層</li><li><strong>Controller</strong> - HTTP 請求處理層  </li><li><strong>UseCase</strong> - 業務邏輯層</li><li><strong>Service</strong> - 基礎設施服務層</li></ul><h2 id="核心問題：分層職責如何劃分？"><a href="#核心問題：分層職責如何劃分？" class="headerlink" title="核心問題：分層職責如何劃分？"></a>核心問題：分層職責如何劃分？</h2><p>以下邏輯應該放在哪一層？</p><ol><li><strong>檔案編碼修復</strong> - 解決中文檔名亂碼問題 (latin1 → utf8)</li><li><strong>檔案類型驗證</strong> - 檢查 MIME type 是否符合業務需求  </li><li><strong>檔案大小限制</strong> - 根據不同業務場景設定不同大小限制</li><li><strong>JWT Token 驗證</strong> - 檢查使用者身份</li><li><strong>檔案內容解析</strong> - 提取 PDF&#x2F;Word 文件內容</li></ol><p>分析思路 — 職責角度</p><h3 id="Middleware-的職責：偏向基礎設施"><a href="#Middleware-的職責：偏向基礎設施" class="headerlink" title="Middleware 的職責：偏向基礎設施"></a>Middleware 的職責：偏向基礎設施</h3><p>控制進出流程 → 例：API 請求進來先檢查 Token</p><p>過濾與轉換資料 → 例：將日期字串轉成標準格式</p><p>保護系統邊界 → 例：攔截未授權的存取</p><p>以下不舉例:</p><ul><li><strong>跨領域技術問題</strong> (認證、編碼、錯誤處理)</li><li><strong>HTTP 協議相關</strong> (請求解析、回應格式)  </li><li><strong>基礎設施關注點</strong> (日誌、監控、安全)</li><li><strong>與業務無關的技術細節</strong></li></ul><h3 id="Use-Case-的職責：偏向商業邏輯"><a href="#Use-Case-的職責：偏向商業邏輯" class="headerlink" title="Use Case 的職責：偏向商業邏輯"></a>Use Case 的職責：偏向商業邏輯</h3><p>驅動核心行為 → 例：建立一筆訂單流程</p><p>執行業務規則 → 例：檢查庫存是否足夠</p><p>協調內外資源 → 例：呼叫付款服務並更新資料庫</p><p>以下不舉例:</p><ul><li><strong>特定業務場景的規則</strong> (不同業務有不同檔案限制)</li><li><strong>領域知識驗證</strong> (合約標題、內容檢查)</li><li><strong>業務流程邏輯</strong> (檔案處理、資料儲存)</li><li><strong>動態配置的業務參數</strong> (從環境變數讀取的業務限制)</li></ul><h2 id="實際案例分析"><a href="#實際案例分析" class="headerlink" title="實際案例分析"></a>實際案例分析</h2><h3 id="檔案編碼問題"><a href="#檔案編碼問題" class="headerlink" title="檔案編碼問題"></a>檔案編碼問題</h3><p>技術問題 → 整個系統一體適用，選 Middleware ✅</p><p>細節分析:</p><ul><li>這是 HTTP 上傳過程中的技術問題，不是業務邏輯</li><li>所有檔案上傳都需要這個處理，跨多個 UseCase</li><li>屬於請求處理層面的責任</li></ul><h3 id="檔案類型限制"><a href="#檔案類型限制" class="headerlink" title="檔案類型限制"></a>檔案類型限制</h3><p>業務邏輯 → 不同的上傳任務有不同限制，屬商業邏輯，選 UseCase ✅</p><p>細節分析:</p><ul><li>不同業務場景有不同的檔案類型限制</li><li>這是領域知識，需要業務邏輯判斷</li><li>可能隨著業務需求變化而調整</li></ul><h3 id="這頭給你想"><a href="#這頭給你想" class="headerlink" title="這頭給你想"></a>這頭給你想</h3><p>如果檔案大小限制要動態調整呢？</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>好的架構設計不是憑感覺，而是要有明確的原則：</p><ul><li><strong>Middleware</strong> &#x3D; 技術基礎設施，處理 HTTP 層面的問題</li><li><strong>UseCase</strong> &#x3D; 業務邏輯驗證，處理領域相關的規則</li></ul><p>這種分層不只讓程式碼更好維護，也讓測試更容易撰寫，更符合單一職責原則。</p><p>下次在設計架構時，不妨問問自己：</p><ul><li>這個邏輯是技術問題還是業務問題？</li><li>這個規則會因為業務需求變化嗎？</li><li>這個處理邏輯需要在多個地方重複嗎？</li></ul><p>Clean Architecture 的精神就在於：<strong>讓業務邏輯獨立於技術細節</strong>。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近在 Code Review 時遇到一個有趣的題目：&lt;/p&gt;
&lt;p&gt;檔案上傳功能中，檔案編碼修復應該放在 Middlewa</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [學習筆記] Node.js 檔案操作 mkdir 的正確姿勢</title>
    <link href="https://blog.marsen.me/2025/08/07/2025/race-condition-in-file-storage/"/>
    <id>https://blog.marsen.me/2025/08/07/2025/race-condition-in-file-storage/</id>
    <published>2025-08-07T05:15:41.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在 code review 中 RD 寫了以下的程式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">exists</span>(fullPath)) &#123;</span><br><span class="line">  <span class="keyword">await</span> fs.<span class="property">promises</span>.<span class="title function_">mkdir</span>(fullPath, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似合理的「檢查然後執行」（Check-Then-Act）模式可能導致的併發問題。</p><p>假設兩個請求同時上傳檔案到同一個不存在的目錄：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">時間線：</span><br><span class="line">T1: 請求A 執行 this.exists(fullPath) → 返回 false (目錄不存在)</span><br><span class="line">T2: 請求B 執行 this.exists(fullPath) → 返回 false (目錄不存在)</span><br><span class="line">T3: 請求A 執行 mkdir(fullPath) → 成功建立目錄</span><br><span class="line">T4: 請求B 執行 mkdir(fullPath) → 可能拋出 EEXIST 錯誤(fs.promises.mkdir 已在底層排除這個問題)</span><br></pre></td></tr></table></figure><p>雖然使用了 <code>recursive: true</code>，那前面的檢查很可能是不必要的行為。</p><h3 id="為什麼會這樣？"><a href="#為什麼會這樣？" class="headerlink" title="為什麼會這樣？"></a>為什麼會這樣？</h3><p>問題的根源在於<strong>時間窗口</strong>。兩個步驟之間存在時間差，而這個時間差就是競態條件的溫床：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 有時間窗口的寫法</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">exists</span>(fullPath)) &#123;  <span class="comment">// 步驟1: 檢查</span></span><br><span class="line">  <span class="comment">// 👆 這裡到下面之間就是危險的時間窗口</span></span><br><span class="line">  <span class="keyword">await</span> fs.<span class="property">promises</span>.<span class="title function_">mkdir</span>(fullPath, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;)  <span class="comment">// 步驟2: 執行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h2><h3 id="方法1-直接使用-mkdir（推薦）"><a href="#方法1-直接使用-mkdir（推薦）" class="headerlink" title="方法1: 直接使用 mkdir（推薦）"></a>方法1: 直接使用 mkdir（推薦）</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">uploadFile</span>(<span class="attr">file</span>: <span class="title class_">UploadedFile</span>, pathToStore?: <span class="string">`/<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fullPath = <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.uploadDir&#125;</span><span class="subst">$&#123;pathToStore ?? <span class="string">&#x27;&#x27;</span>&#125;</span>`</span></span><br><span class="line">  <span class="comment">// 直接建立目錄，recursive: true 會自動處理已存在的情況</span></span><br><span class="line">  <span class="keyword">await</span> fs.<span class="property">promises</span>.<span class="title function_">mkdir</span>(fullPath, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> uploadPath = path.<span class="title function_">join</span>(fullPath, file.<span class="property">originalName</span>)</span><br><span class="line">  <span class="keyword">await</span> fs.<span class="property">promises</span>.<span class="title function_">writeFile</span>(uploadPath, file.<span class="property">buffer</span>)</span><br><span class="line">  <span class="keyword">return</span> uploadPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="為什麼-recursive-true-已經足夠"><a href="#為什麼-recursive-true-已經足夠" class="headerlink" title="為什麼 recursive: true 已經足夠"></a>為什麼 recursive: true 已經足夠</h2><p>根據 Node.js 官方文件，<code>fs.promises.mkdir(path, { recursive: true })</code> 具有以下特性：</p><ol><li><strong>自動建立父目錄</strong>：如果父目錄不存在會自動建立</li><li><strong>處理已存在目錄</strong>：當 <code>recursive</code> 為 <code>true</code> 時，如果目錄已存在不會拋出錯誤</li><li><strong>簡化錯誤處理</strong>：避免了手動檢查目錄是否存在的需要</li></ol><p>官方範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mkdir &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create ./tmp/a/apple, regardless of whether ./tmp and ./tmp/a exist.</span></span><br><span class="line"><span class="title function_">mkdir</span>(<span class="string">&#x27;./tmp/a/apple&#x27;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">這就像餐廳點餐的差別：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`typescript</span></span><br><span class="line"><span class="string">// ❌ 競態條件版本（不好的做法）</span></span><br><span class="line"><span class="string">if (餐廳沒有準備我要的餐) &#123;  // 檢查</span></span><br><span class="line"><span class="string">  請廚師準備這道餐        // 執行</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 問題：兩個客人可能同時檢查到「沒有」，然後都要求準備</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// ✅ 直接執行版本（好的做法）</span></span><br><span class="line"><span class="string">請廚師準備這道餐，如果已經有了就不用重複準備</span></span><br><span class="line"><span class="string">// 廚師會自己判斷是否需要準備，避免重複工作</span></span><br></pre></td></tr></table></figure><h2 id="效能優勢"><a href="#效能優勢" class="headerlink" title="效能優勢"></a>效能優勢</h2><p>修復後還有意外的效能提升：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修復前：2次系統調用</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">exists</span>(fullPath)  <span class="comment">// 系統調用1: stat()</span></span><br><span class="line"><span class="keyword">await</span> fs.<span class="property">promises</span>.<span class="title function_">mkdir</span>()    <span class="comment">// 系統調用2: mkdir()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修復後：1次系統調用  </span></span><br><span class="line"><span class="keyword">await</span> fs.<span class="property">promises</span>.<span class="title function_">mkdir</span>(fullPath, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;)  <span class="comment">// 系統調用1: mkdir()</span></span><br></pre></td></tr></table></figure><h2 id="經驗教訓"><a href="#經驗教訓" class="headerlink" title="經驗教訓"></a>經驗教訓</h2><ol><li><strong>避免 Check-Then-Act 模式</strong>：這是併發程式設計的經典陷阱，不過這次案例，執行的底層實作已處理好，所以不會有問題</li><li><strong>信任系統調用</strong>：現代 API 通常已經考慮了併發場景</li><li><strong>簡單就是美</strong>：移除不必要的檢查邏輯，程式碼更簡潔也更安全</li></ol><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://nodejs.org/api/fs.html#fsmkdirpath-options-callback">Nodejs - fsPromises.mkdir(path[, options])</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在 code review 中 RD 寫了以下的程式&lt;/p&gt;
&lt;figure class=&quot;highlight typesc</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] AI Agent 實作 Web Search API：從設計到部署的完整記錄</title>
    <link href="https://blog.marsen.me/2025/07/31/2025/ai_google_search_api/"/>
    <id>https://blog.marsen.me/2025/07/31/2025/ai_google_search_api/</id>
    <published>2025-07-31T08:51:10.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近購買 Claude Code，在此同時也有試用 Github Copilot &#x2F; Gitlab Duo &#x2F; Gemini &#x2F; Amazon Q</p><p>剛好手上有需求，是簡單的 API 串接，但是我們的系統架構有一些只有團隊知道的 Know How。</p><p>我想試試用 AI Agent 來協助我處理這些開發，需求簡單明確，但是技術細節並不少，</p><p>如果是新進 RD(即使有開發經驗)也不見得能掌握得很好，我來試試看 AI Agent 能作什麼程度。</p><p>這篇文章記錄我在基於 Clean Architecture 的 Node.js API 系統中實作 Web Search 功能的完整過程，包含架構設計、權限管理、錯誤處理等細節。</p><h2 id="系統架構背景"><a href="#系統架構背景" class="headerlink" title="系統架構背景"></a>系統架構背景</h2><p>專案採用 <strong>Clean Architecture</strong> 搭配 <strong>依賴注入 (Inversify)</strong>，技術棧包含：</p><ul><li>TypeScript + Express.js</li><li>TypeORM (資料庫 ORM)</li><li>Inversify (依賴注入容器)</li><li>JWT (身份驗證)</li><li>Zod (參數驗證)</li></ul><p>架構分為四個主要層級：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── adapters/          # 外部介面層 - 控制器</span><br><span class="line">├── domain/           # 領域層 - 核心業務邏輯  </span><br><span class="line">├── infrastructure/   # 基礎設施層 - 外部依賴實作  </span><br><span class="line">└── useCases/        # 應用層 - 業務用例</span><br></pre></td></tr></table></figure><h2 id="需求分析與設計決策"><a href="#需求分析與設計決策" class="headerlink" title="需求分析與設計決策"></a>需求分析與設計決策</h2><h3 id="API-規格定義"><a href="#API-規格定義" class="headerlink" title="API 規格定義"></a>API 規格定義</h3><ul><li><strong>端點</strong>: <code>GET /api/v1/websearch?keyword=關鍵字</code></li><li><strong>輸入</strong>: Query 參數 <code>{ keyword: string }</code></li><li><strong>輸出</strong>: <code>{ data: [{ title: string, url: string, description: string }] }</code></li><li><strong>結果數</strong>: 10 筆</li><li><strong>權限</strong>: 所有 API 都需要權限檢查(我們之前開發好的 RBAC 權限系統 )，一個功能對應一個權限，為此我需要新增 <code>web_search</code> 權限</li></ul><h3 id="關鍵設計決策"><a href="#關鍵設計決策" class="headerlink" title="關鍵設計決策"></a>關鍵設計決策</h3><p><strong>1. 控制器選擇</strong>  </p><p>決定將功能放在 <code>BasicController</code> 而非 <code>ProjController</code>，因為這是通用功能而非特定業務邏輯。</p><p>| 這裡我在需求上有明確告知 AI，實作上也沒有問題</p><p><strong>2. 依賴關係</strong><br>嚴格遵循 Clean Architecture 的依賴規則：</p><p>| 也有寫入 CLAUDE.md 的開發準則中，但 AI 會常常忘記這件事</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Controller → UseCase → Service → External API</span><br></pre></td></tr></table></figure><p><strong>3. 環境變數策略</strong>  </p><p>將 Google API 設定為非必要欄位，未設定時警告但不中斷其他服務。</p><p>| AI 提供很好的建議並快速完成開發</p><p><strong>4. 錯誤處理設計</strong>  </p><ul><li>503: API 未設定</li><li>502: API 呼叫失敗  </li><li>400: 參數錯誤 (Zod 驗證)</li></ul><h2 id="實作步驟詳解"><a href="#實作步驟詳解" class="headerlink" title="實作步驟詳解"></a>實作步驟詳解</h2><h3 id="Phase-1-環境設定擴充"><a href="#Phase-1-環境設定擴充" class="headerlink" title="Phase 1: 環境設定擴充"></a>Phase 1: 環境設定擴充</h3><p>首先擴充環境變數設定，新增 Google Search API 相關設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .env.example</span></span><br><span class="line"><span class="comment"># Google Search API Configuration</span></span><br><span class="line">GOOGLE_API_KEY=your_google_api_key</span><br><span class="line">GOOGLE_SEARCH_ENGINE_ID=your_search_engine_id  </span><br><span class="line">GOOGLE_SEARCH_API_URL=https://www.googleapis.com/customsearch/v1</span><br><span class="line">GOOGLE_SEARCH_RESULTS_COUNT=10</span><br></pre></td></tr></table></figure><p><strong>修改 envConfigService.ts</strong><br>新增 <code>getOptional()</code> 方法支援可選配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">getOptional</span>(<span class="attr">key</span>: <span class="built_in">string</span>): <span class="built_in">string</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> process.<span class="property">env</span>[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Phase-2-權限系統整合"><a href="#Phase-2-權限系統整合" class="headerlink" title="Phase 2: 權限系統整合"></a>Phase 2: 權限系統整合</h3><p>建立資料庫遷移檔案，新增 <code>web_search</code> 權限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> permissions (name, description) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;web_search&#x27;</span>, <span class="string">&#x27;Web Search API access permission&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分配給 admin 和 member 角色</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> role_permissions (role_id, permission_id) </span><br><span class="line"><span class="keyword">SELECT</span> r.id, p.id <span class="keyword">FROM</span> roles r, permissions p </span><br><span class="line"><span class="keyword">WHERE</span> r.name <span class="keyword">IN</span> (<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;member&#x27;</span>) <span class="keyword">AND</span> p.name <span class="operator">=</span> <span class="string">&#x27;web_search&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="Phase-3-核心架構實作"><a href="#Phase-3-核心架構實作" class="headerlink" title="Phase 3: 核心架構實作"></a>Phase 3: 核心架構實作</h3><h4 id="1-定義領域介面"><a href="#1-定義領域介面" class="headerlink" title="1. 定義領域介面"></a>1. 定義領域介面</h4><p><strong>src&#x2F;domain&#x2F;interfaces&#x2F;webSearchService.ts</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WebSearchService</span> &#123;</span><br><span class="line">  <span class="title function_">search</span>(<span class="attr">keyword</span>: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">WebSearchResult</span>[]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WebSearchResult</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span>  </span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Google-Search-Service-實作"><a href="#2-Google-Search-Service-實作" class="headerlink" title="2. Google Search Service 實作"></a>2. Google Search Service 實作</h4><p><strong>src&#x2F;infrastructure&#x2F;services&#x2F;googleSearchService.ts</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">GoogleSearchService</span> <span class="keyword">implements</span> <span class="title class_">WebSearchService</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@inject</span>(TYPES.HttpClient) <span class="keyword">private</span> <span class="keyword">readonly</span> httpClient: IHttpClient,</span></span><br><span class="line"><span class="params">    <span class="meta">@inject</span>(TYPES.EnvConfigService) <span class="keyword">private</span> <span class="keyword">readonly</span> envConfig: IEnvConfigService</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">search</span>(<span class="attr">keyword</span>: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">WebSearchResult</span>[]&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> apiKey = <span class="variable language_">this</span>.<span class="property">envConfig</span>.<span class="title function_">getOptional</span>(<span class="string">&#x27;GOOGLE_API_KEY&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> searchEngineId = <span class="variable language_">this</span>.<span class="property">envConfig</span>.<span class="title function_">getOptional</span>(<span class="string">&#x27;GOOGLE_SEARCH_ENGINE_ID&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!apiKey || !searchEngineId) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppError</span>(<span class="string">&#x27;Google Search API 未設定&#x27;</span>, <span class="number">503</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">      <span class="attr">key</span>: apiKey,</span><br><span class="line">      <span class="attr">cx</span>: searchEngineId, </span><br><span class="line">      <span class="attr">q</span>: keyword,</span><br><span class="line">      <span class="attr">num</span>: <span class="variable language_">this</span>.<span class="property">envConfig</span>.<span class="title function_">get</span>(<span class="string">&#x27;GOOGLE_SEARCH_RESULTS_COUNT&#x27;</span>, <span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">httpClient</span>.<span class="title function_">get</span>(</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">envConfig</span>.<span class="title function_">get</span>(<span class="string">&#x27;GOOGLE_SEARCH_API_URL&#x27;</span>), </span><br><span class="line">        &#123; params &#125;</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">transformGoogleResponse</span>(response.<span class="property">data</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppError</span>(<span class="string">&#x27;搜尋服務暫時無法使用&#x27;</span>, <span class="number">502</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">transformGoogleResponse</span>(<span class="attr">data</span>: <span class="built_in">any</span>): <span class="title class_">WebSearchResult</span>[] &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data.<span class="property">items</span>) <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data.<span class="property">items</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item: <span class="built_in">any</span></span>) =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">title</span>: item.<span class="property">title</span>,</span><br><span class="line">      <span class="attr">url</span>: item.<span class="property">link</span>,</span><br><span class="line">      <span class="attr">description</span>: item.<span class="property">snippet</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-UseCase-層實作"><a href="#3-UseCase-層實作" class="headerlink" title="3. UseCase 層實作"></a>3. UseCase 層實作</h4><p><strong>src&#x2F;useCases&#x2F;ExecuteWebSearch.ts</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ExecuteWebSearch</span> <span class="keyword">implements</span> <span class="title class_">IUseCase</span>&lt;<span class="title class_">ExecuteWebSearchDTO</span>, <span class="title class_">WebSearchResponseDTO</span>&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@inject</span>(TYPES.WebSearchService) <span class="keyword">private</span> <span class="keyword">readonly</span> webSearchService: WebSearchService</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">execute</span>(<span class="attr">input</span>: <span class="title class_">ExecuteWebSearchDTO</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">WebSearchResponseDTO</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> results = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">webSearchService</span>.<span class="title function_">search</span>(input.<span class="property">keyword</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">data</span>: results &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DTO 定義</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ExecuteWebSearchDTO</span> &#123;</span><br><span class="line">  <span class="attr">keyword</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WebSearchResponseDTO</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">WebSearchResult</span>[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Controller-層實作"><a href="#4-Controller-層實作" class="headerlink" title="4. Controller 層實作"></a>4. Controller 層實作</h4><p><strong>src&#x2F;adapters&#x2F;controllers&#x2F;basicController.ts</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">&#x27;zod&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Zod 驗證 schema</span></span><br><span class="line"><span class="keyword">const</span> webSearchQuerySchema = z.<span class="title function_">object</span>(&#123;</span><br><span class="line">  <span class="attr">keyword</span>: z.<span class="title function_">string</span>().<span class="title function_">min</span>(<span class="number">1</span>, <span class="string">&#x27;keyword 參數為必填且不能為空字串&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">webSearch</span>(<span class="attr">req</span>: <span class="title class_">Request</span>, <span class="attr">res</span>: <span class="title class_">Response</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 使用 Zod 進行參數驗證</span></span><br><span class="line">  <span class="keyword">const</span> &#123; keyword &#125; = webSearchQuerySchema.<span class="title function_">parse</span>(req.<span class="property">query</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="attr">input</span>: <span class="title class_">ExecuteWebSearchDTO</span> = &#123; keyword &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">executeWebSearch</span>.<span class="title function_">execute</span>(input)</span><br><span class="line">  </span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-路由設定"><a href="#5-路由設定" class="headerlink" title="5. 路由設定"></a>5. 路由設定</h4><p><strong>src&#x2F;infrastructure&#x2F;routes&#x2F;basicRouter.ts</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 註冊路由，先執行權限檢查，再執行業務邏輯</span></span><br><span class="line">r.<span class="title function_">get</span>(<span class="string">`<span class="subst">$&#123;basePath&#125;</span>/websearch`</span>, </span><br><span class="line">  auth.<span class="title function_">user</span>(<span class="string">&#x27;web_search&#x27;</span>),  <span class="comment">// 權限中介軟體</span></span><br><span class="line">  <span class="title function_">asyncWrapper</span>(basicController.<span class="property">webSearch</span>.<span class="title function_">bind</span>(basicController))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Phase-4-依賴注入設定"><a href="#Phase-4-依賴注入設定" class="headerlink" title="Phase 4: 依賴注入設定"></a>Phase 4: 依賴注入設定</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inversify.config.ts</span></span><br><span class="line"><span class="comment">// 註冊 UseCase</span></span><br><span class="line">container.<span class="property">bind</span>&lt;<span class="title class_">IUseCase</span>&lt;<span class="title class_">ExecuteWebSearchDTO</span>, <span class="title class_">WebSearchResponseDTO</span>&gt;&gt;(</span><br><span class="line">  <span class="variable constant_">TYPES</span>.<span class="property">ExecuteWebSearch</span></span><br><span class="line">).<span class="title function_">to</span>(<span class="title class_">ExecuteWebSearch</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 註冊 Service</span></span><br><span class="line">container.<span class="property">bind</span>&lt;<span class="title class_">WebSearchService</span>&gt;(</span><br><span class="line">  <span class="variable constant_">TYPES</span>.<span class="property">WebSearchService</span></span><br><span class="line">).<span class="title function_">to</span>(<span class="title class_">GoogleSearchService</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 TYPES 常數</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">TYPES</span> = &#123;</span><br><span class="line">  <span class="comment">// ... existing types</span></span><br><span class="line">  <span class="title class_">ExecuteWebSearch</span>: <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;ExecuteWebSearch&#x27;</span>),</span><br><span class="line">  <span class="title class_">WebSearchService</span>: <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;WebSearchService&#x27;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="測試與驗證"><a href="#測試與驗證" class="headerlink" title="測試與驗證"></a>測試與驗證</h2><h3 id="準備測試環境-–-取得測試-Token"><a href="#準備測試環境-–-取得測試-Token" class="headerlink" title="準備測試環境 – 取得測試 Token"></a>準備測試環境 – 取得測試 Token</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X <span class="string">&#x27;POST&#x27;</span> <span class="string">&#x27;http://localhost:4578/api/v1/auth/login&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: application/json&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;&quot;account&quot;: &quot;test_act&quot;, &quot;password&quot;: &quot;test_pwd&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="測試案例設計"><a href="#測試案例設計" class="headerlink" title="測試案例設計"></a>測試案例設計</h3><p>| AI　會自動幫我跑 End To End 測試（本來是 RD 用curl 或 postman 進行的工作）<br>| 案例的設計上也很細心，很多 RD 是只測試 Happy Case 的</p><h4 id="正常功能測試-happy-case"><a href="#正常功能測試-happy-case" class="headerlink" title="正常功能測試(happy case)"></a>正常功能測試(happy case)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;http://localhost:4578/api/v1/websearch?keyword=nodejs&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Authorization: Bearer &lt;token&gt;&quot;</span></span><br><span class="line"><span class="comment"># 預期: Google 搜尋結果 JSON</span></span><br></pre></td></tr></table></figure><h4 id="權限檢查失敗測試"><a href="#權限檢查失敗測試" class="headerlink" title="權限檢查失敗測試"></a>權限檢查失敗測試</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;http://localhost:4578/api/v1/websearch?keyword=test&quot;</span></span><br><span class="line"><span class="comment"># 預期: &#123;&quot;error&quot;:&quot;Authentication invalid&quot;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="參數驗證測試"><a href="#參數驗證測試" class="headerlink" title="參數驗證測試"></a>參數驗證測試</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺少參數</span></span><br><span class="line">curl -X GET <span class="string">&quot;http://localhost:4578/api/v1/websearch&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Authorization: Bearer &lt;token&gt;&quot;</span></span><br><span class="line"><span class="comment"># 預期: Zod 驗證錯誤，400 status</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空參數</span></span><br><span class="line">curl -X GET <span class="string">&quot;http://localhost:4578/api/v1/websearch?keyword=&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Authorization: Bearer &lt;token&gt;&quot;</span></span><br><span class="line"><span class="comment"># 預期: &#123;&quot;error&quot;:[&#123;...,&quot;message&quot;:&quot;keyword 參數為必填且不能為空字串&quot;&#125;]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="錯誤處理機制"><a href="#錯誤處理機制" class="headerlink" title="錯誤處理機制"></a>錯誤處理機制</h2><h3 id="Zod-驗證整合"><a href="#Zod-驗證整合" class="headerlink" title="Zod 驗證整合"></a>Zod 驗證整合</h3><blockquote><p>專案已內建 Zod 在 req&#x2F;res 檢查參數與錯誤處理有很好的表現，是團隊的開發工具之一<br>但要提醒 AI 不然他會手刻一個錯誤處理給你（刻得也不差就是了）</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// errorHandler.ts 已支援</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="title class_">ZodError</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="number">400</span>,</span><br><span class="line">  <span class="attr">log</span>: <span class="string">&#x27;Zod validation error&#x27;</span>,</span><br><span class="line">  <span class="attr">getMsg</span>: <span class="function">(<span class="params">err: ZodError</span>) =&gt;</span> err.<span class="property">errors</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="❌-錯誤方式：AI-手刻錯誤處理"><a href="#❌-錯誤方式：AI-手刻錯誤處理" class="headerlink" title="❌ 錯誤方式：AI 手刻錯誤處理"></a>❌ 錯誤方式：AI 手刻錯誤處理</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!keyword || <span class="keyword">typeof</span> keyword !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">json</span>(&#123; <span class="attr">error</span>: <span class="string">&#x27;keyword 參數為必填且必須是字串&#x27;</span> &#125;)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="✅-正確方式：使用-Zod"><a href="#✅-正確方式：使用-Zod" class="headerlink" title="✅ 正確方式：使用 Zod"></a>✅ 正確方式：使用 Zod</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; keyword &#125; = webSearchQuerySchema.<span class="title function_">parse</span>(req.<span class="property">query</span>)</span><br></pre></td></tr></table></figure><p>使用 Zod 的好處：</p><ul><li>統一的錯誤格式</li><li>自動整合到全域錯誤處理器</li><li>型別安全保證</li></ul><h3 id="中介軟體執行順序"><a href="#中介軟體執行順序" class="headerlink" title="中介軟體執行順序"></a>中介軟體執行順序</h3><blockquote><p>重構算是這次需求的大目標，只要提示詞寫得夠好 AI 可以提供很完整的路由列表<br>而且重構的狀態也很正確，不過我的專案不大只有 30 隻左右的 API 參加價值可能不高</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">請求 → auth.user(&#x27;web_search&#x27;) → asyncWrapper → zod.parse() → 業務邏輯</span><br></pre></td></tr></table></figure><p>這個順序確保：</p><ol><li>先檢查身份權限</li><li>再進行參數驗證  </li><li>最後執行業務邏輯</li></ol><h2 id="Google-Custom-Search-API-整合要點"><a href="#Google-Custom-Search-API-整合要點" class="headerlink" title="Google Custom Search API 整合要點"></a>Google Custom Search API 整合要點</h2><blockquote><p>商業需求的主邏輯，我一行程式沒寫只與 AI 互動就完成了這個功能，包含點對點的測試<br>不過在零信任原則下，還是請其他 RD 再作一次 Code Review 與完整測試</p></blockquote><h3 id="必要參數說明"><a href="#必要參數說明" class="headerlink" title="必要參數說明"></a>必要參數說明</h3><ul><li><code>key</code>: Google API Key</li><li><code>cx</code>: Custom Search Engine ID  </li><li><code>q</code>: 搜尋關鍵字</li><li><code>num</code>: 結果數量</li></ul><h3 id="API-回應轉換"><a href="#API-回應轉換" class="headerlink" title="API 回應轉換"></a>API 回應轉換</h3><p>Google API 回應結構：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜尋結果標題&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;snippet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜尋結果摘要&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>轉換為系統格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜尋結果標題&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://example.com&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜尋結果摘要&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這次實作讓我深度體驗了 AI 與優良架構在實際專案中的運用。幾個關鍵收穫：</p><h3 id="架構優勢"><a href="#架構優勢" class="headerlink" title="架構優勢"></a>架構優勢</h3><ul><li>清晰的分層讓職責分明，測試容易</li><li>依賴注入讓元件可抽換，符合開放封閉原則</li><li>統一的錯誤處理機制，維護成本低</li></ul><p>上面是原本的優勢，加上 AI 判讀後，可以高效產生 Clean Code  </p><p>不太確定不良代碼會有什麼結果，很幸運是我不在那種環境之中  </p><p>現在三個圈圈是有交集的，好又快又便宜(產出／單位時間)，  </p><p>依照 AI 帶來的生產力與現有的 RD 相比，其實是很便宜的選擇。</p><p>良好的設計結合工具(AI)是提昇效率的手段,  </p><p>3 個人可以當 ７ 個人用。至於為什麼是３個人，有機會再說了。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近購買 Claude Code，在此同時也有試用 Github Copilot &amp;#x2F; Gitlab Duo &amp;#x</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] EAI 機器瀏覽器安裝問題與解決方案</title>
    <link href="https://blog.marsen.me/2025/07/29/2025/ai-eai-browser-install-flatpak-solution/"/>
    <id>https://blog.marsen.me/2025/07/29/2025/ai-eai-browser-install-flatpak-solution/</id>
    <published>2025-07-29T05:51:36.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近拿到一個地端資源 <a href="https://www.lannerinc.com/products/edge-ai-appliance/deep-learning-inference-appliances/eai-i233">EAI-I233</a> 開發地端 AI 應用。<br>過程中遇到了安裝瀏覽器(firefox)無法正常運作的問題。<br>經過查找資料，發現這是 Jetson Orin Nano 上的已知問題，不是個案。<br>記錄一下如何透過 Flatpak 安裝 Chromium 在 EAI 機器上，以解決瀏覽器問題。</p><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>在 Jetson Orin Nano 等 EAI 設備上，透過 snap 安裝的 Chromium 瀏覽器會出現無法正常啟動或運行不穩定的狀況。<br>這個問題並非個案，在 NVIDIA 開發者論壇上有許多用戶回報類似問題。  </p><h2 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h2><h3 id="移除現有的-snap-版本-Chromium"><a href="#移除現有的-snap-版本-Chromium" class="headerlink" title="移除現有的 snap 版本 Chromium"></a>移除現有的 snap 版本 Chromium</h3><p>首先移除透過 snap 安裝的 Chromium：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap remove chromium</span><br></pre></td></tr></table></figure><h3 id="安裝與設定-Flatpak"><a href="#安裝與設定-Flatpak" class="headerlink" title="安裝與設定 Flatpak"></a>安裝與設定 Flatpak</h3><p>更新套件管理器並安裝 Flatpak：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install flatpak</span><br></pre></td></tr></table></figure><p>添加 Flathub 儲存庫：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo</span><br></pre></td></tr></table></figure><h3 id="重開機並安裝-Chromium"><a href="#重開機並安裝-Chromium" class="headerlink" title="重開機並安裝 Chromium"></a>重開機並安裝 Chromium</h3><p>重新啟動機器後，透過 Flatpak 安裝 Chromium：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重開機後執行</span></span><br><span class="line">flatpak install flathub org.chromium.Chromium</span><br></pre></td></tr></table></figure><h2 id="為什麼要用-Flatpak？"><a href="#為什麼要用-Flatpak？" class="headerlink" title="為什麼要用 Flatpak？"></a>為什麼要用 Flatpak？</h2><p>相比於 snap，Flatpak 在 ARM 架構的設備上有更好的相容性。<br>特別是在 Jetson 系列開發板上，Flatpak 能夠提供更穩定的套件執行環境，避免因為 snap 沙盒機制與硬體驅動互動時產生的問題。  </p><h2 id="一些要注意的小問題"><a href="#一些要注意的小問題" class="headerlink" title="一些要注意的小問題"></a>一些要注意的小問題</h2><p><strong>重開機是必要的</strong><br>在安裝完 Flatpak 後，務必重開機再安裝 Chromium，確保所有相依服務正確啟動。</p><p><strong>權限問題</strong><br>如果遇到權限問題，確認當前使用者已加入相關群組：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G sudo <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://forums.developer.nvidia.com/t/jetson-orin-nano-browser-issue/338580/44">Jetson Orin Nano Browser Issue - NVIDIA Developer Forum</a></li><li><a href="https://jetsonhacks.com/2025/07/12/why-chromium-suddenly-broke-on-jetson-orin-and-how-to-bring-it-back/">JetsonHacks: Why Chromium Suddenly Broke on Jetson Orin</a></li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過 Flatpak 安裝 Chromium 是目前在 EAI 設備上最穩定的解決方案。<br>雖然需要額外的設定步驟，但能夠有效解決 snap 版本在 ARM 架構上的相容性問題。<br>這個解決方案不僅適用於 Jetson Orin Nano，也可以應用到其他類似的 ARM 架構開發板上。<br>有機會拿到別的機器再來試試。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近拿到一個地端資源 &lt;a href=&quot;https://www.lannerinc.com/products/edge-ai</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [學習筆記] Express.js middleware auth 的業界標準(res.locals)</title>
    <link href="https://blog.marsen.me/2025/07/25/2025/express-res-locals-auth-best-practice/"/>
    <id>https://blog.marsen.me/2025/07/25/2025/express-res-locals-auth-best-practice/</id>
    <published>2025-07-25T03:17:04.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Express.js 認證系統中，常見的做法是在每個需要驗證的路由中直接解析 JWT token。<br>但有一個更好的實作方式：使用中介軟體將認證結果存放在 <code>res.locals</code> 中。<br>這不僅是官方建議的做法，也避免了重複解析 token 的效能問題。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>使用 <code>res.locals</code> 處理認證是 Express.js 的標準實作：</p><ul><li>避免在每個路由重複解析 JWT token</li><li>Auth.js、Passport.js 等主流函式庫都採用這種模式</li><li>Express.js 官方文檔明確支持這種用法</li></ul><h2 id="直接解析-JWT-的缺點"><a href="#直接解析-JWT-的缺點" class="headerlink" title="直接解析 JWT 的缺點"></a>直接解析 JWT 的缺點</h2><h3 id="重複工作的效能問題"><a href="#重複工作的效能問題" class="headerlink" title="重複工作的效能問題"></a>重複工作的效能問題</h3><p>如果每個路由都直接解析 JWT，會造成不必要的重複運算：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 在每個路由重複解析</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/profile&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> token = req.<span class="property">headers</span>.<span class="property">authorization</span>?.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> user = jwt.<span class="title function_">verify</span>(token, <span class="variable constant_">JWT_SECRET</span>) <span class="comment">// 重複解析</span></span><br><span class="line">  res.<span class="title function_">json</span>(&#123; user &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/orders&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> token = req.<span class="property">headers</span>.<span class="property">authorization</span>?.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> user = jwt.<span class="title function_">verify</span>(token, <span class="variable constant_">JWT_SECRET</span>) <span class="comment">// 又解析一次</span></span><br><span class="line">  res.<span class="title function_">json</span>(&#123; <span class="attr">orders</span>: <span class="title function_">getUserOrders</span>(user.<span class="property">id</span>) &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="程式碼重複與維護困難"><a href="#程式碼重複與維護困難" class="headerlink" title="程式碼重複與維護困難"></a>程式碼重複與維護困難</h3><p>每個需要認證的路由都要寫類似的 token 驗證邏輯，違反了 DRY 原則，也增加了維護成本。</p><h3 id="錯誤處理不一致"><a href="#錯誤處理不一致" class="headerlink" title="錯誤處理不一致"></a>錯誤處理不一致</h3><p>不同路由可能有不同的 token 驗證錯誤處理方式，造成 API 回應不一致。</p><h2 id="什麼是-res-locals？"><a href="#什麼是-res-locals？" class="headerlink" title="什麼是 res.locals？"></a>什麼是 res.locals？</h2><p>根據 Express.js 官方文檔，<code>res.locals</code> 是一個物件，用來存放<strong>請求範圍內的區域變數</strong>，這些變數只在當前請求-回應週期中可用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Express.js 官方範例</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="property">locals</span>.<span class="property">user</span> = req.<span class="property">user</span></span><br><span class="line">  res.<span class="property">locals</span>.<span class="property">authenticated</span> = !req.<span class="property">user</span></span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="主流函式庫的標準實作"><a href="#主流函式庫的標準實作" class="headerlink" title="主流函式庫的標準實作"></a>主流函式庫的標準實作</h2><h3 id="Auth-js-官方範例"><a href="#Auth-js-官方範例" class="headerlink" title="Auth.js 官方範例"></a>Auth.js 官方範例</h3><p>Auth.js 官方文檔明確展示了使用 <code>res.locals</code> 的標準模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getSession &#125; <span class="keyword">from</span> <span class="string">&quot;@auth/express&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">authSession</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="property">locals</span>.<span class="property">session</span> = <span class="keyword">await</span> <span class="title function_">getSession</span>(req)</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(authSession)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在路由中使用</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; session &#125; = res.<span class="property">locals</span></span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&quot;index&quot;</span>, &#123; <span class="attr">user</span>: session?.<span class="property">user</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Passport-js-的實作模式"><a href="#Passport-js-的實作模式" class="headerlink" title="Passport.js 的實作模式"></a>Passport.js 的實作模式</h3><p>Passport.js 在認證成功時會設置 <code>req.user</code> 屬性，許多開發者會將此資訊複製到 <code>res.locals</code> 以便在視圖中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 認證中介軟體</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="property">locals</span>.<span class="property">user</span> = req.<span class="title function_">isAuthenticated</span>() ? req.<span class="property">user</span> : <span class="literal">null</span></span><br><span class="line">  res.<span class="property">locals</span>.<span class="property">isAuthenticated</span> = req.<span class="title function_">isAuthenticated</span>()</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="為什麼這是好實作？"><a href="#為什麼這是好實作？" class="headerlink" title="為什麼這是好實作？"></a>為什麼這是好實作？</h2><h3 id="1-官方支持的標準"><a href="#1-官方支持的標準" class="headerlink" title="1. 官方支持的標準"></a>1. 官方支持的標準</h3><p>Express.js 官方文檔說明 <code>res.locals</code> 就是用來存放請求級別的資訊，如認證用戶、用戶設定等。這不是 hack 或 workaround，而是設計用途。</p><h3 id="2-生態系統共識"><a href="#2-生態系統共識" class="headerlink" title="2. 生態系統共識"></a>2. 生態系統共識</h3><p>主流的認證函式庫都採用類似模式：</p><ul><li>Auth.js 直接在文檔中展示 <code>res.locals.session</code></li><li>Passport.js 社群普遍使用 <code>res.locals.user</code></li><li>許多教學都展示將認證狀態存放在 <code>res.locals</code> 的模式</li></ul><h3 id="3-分離關注點"><a href="#3-分離關注點" class="headerlink" title="3. 分離關注點"></a>3. 分離關注點</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 認證中介軟體 - 只負責認證</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">authMiddleware</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = req.<span class="property">headers</span>.<span class="property">authorization</span>?.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    <span class="keyword">const</span> decoded = jwt.<span class="title function_">verify</span>(token, <span class="variable constant_">JWT_SECRET</span>)</span><br><span class="line">    res.<span class="property">locals</span>.<span class="property">user</span> = decoded</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由處理器 - 只負責業務邏輯</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/profile&#x27;</span>, authMiddleware, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = res.<span class="property">locals</span></span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">401</span>).<span class="title function_">json</span>(&#123; <span class="attr">error</span>: <span class="string">&#x27;Unauthorized&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">json</span>(&#123; <span class="attr">profile</span>: user &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-視圖整合優勢"><a href="#4-視圖整合優勢" class="headerlink" title="4. 視圖整合優勢"></a>4. 視圖整合優勢</h3><p>在使用模板引擎時，<code>res.locals</code> 的資料會自動傳遞給視圖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中介軟體設定</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="property">locals</span>.<span class="property">currentUser</span> = req.<span class="property">user</span></span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 EJS/Pug 模板中直接使用</span></span><br><span class="line"><span class="comment">// &lt;%= currentUser.name %&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常見的反模式"><a href="#常見的反模式" class="headerlink" title="常見的反模式"></a>常見的反模式</h2><h3 id="避免的做法"><a href="#避免的做法" class="headerlink" title="避免的做法"></a>避免的做法</h3><p>有些開發者認為過度使用 <code>res.locals</code> 會讓除錯變困難，但這通常是因為：</p><ol><li><strong>濫用中介軟體模式</strong> - 把業務邏輯也放在中介軟體裡</li><li><strong>過度耦合</strong> - 多個中介軟體互相依賴 <code>res.locals</code> 的順序</li></ol><h3 id="正確的使用原則"><a href="#正確的使用原則" class="headerlink" title="正確的使用原則"></a>正確的使用原則</h3><p>中介軟體應該用於所有 HTTP 請求共通的事項，且不包含業務邏輯：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 好的做法 - 純粹的認證檢查</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">authenticate</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="title function_">getTokenFromRequest</span>(req)</span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">validateToken</span>(token)</span><br><span class="line">  res.<span class="property">locals</span>.<span class="property">user</span> = user</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 好的做法 - 授權檢查</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requireAuth</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!res.<span class="property">locals</span>.<span class="property">user</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">401</span>).<span class="title function_">json</span>(&#123; <span class="attr">error</span>: <span class="string">&#x27;Unauthorized&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 避免的做法 - 在中介軟體中處理業務邏輯</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">badMiddleware</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> user = res.<span class="property">locals</span>.<span class="property">user</span></span><br><span class="line">  <span class="keyword">const</span> orders = <span class="title function_">getUserOrders</span>(user.<span class="property">id</span>) <span class="comment">// 業務邏輯不應該在這裡</span></span><br><span class="line">  res.<span class="property">locals</span>.<span class="property">orders</span> = orders</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="實務上的最佳實作"><a href="#實務上的最佳實作" class="headerlink" title="實務上的最佳實作"></a>實務上的最佳實作</h2><h3 id="標準認證中介軟體"><a href="#標準認證中介軟體" class="headerlink" title="標準認證中介軟體"></a>標準認證中介軟體</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">authMiddleware</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> token = req.<span class="property">headers</span>.<span class="property">authorization</span>?.<span class="title function_">replace</span>(<span class="string">&#x27;Bearer &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="keyword">const</span> decoded = jwt.<span class="title function_">verify</span>(token, process.<span class="property">env</span>.<span class="property">JWT_SECRET</span>)</span><br><span class="line">      res.<span class="property">locals</span>.<span class="property">user</span> = decoded</span><br><span class="line">      res.<span class="property">locals</span>.<span class="property">isAuthenticated</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="property">locals</span>.<span class="property">user</span> = <span class="literal">null</span></span><br><span class="line">      res.<span class="property">locals</span>.<span class="property">isAuthenticated</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.<span class="property">locals</span>.<span class="property">user</span> = <span class="literal">null</span></span><br><span class="line">    res.<span class="property">locals</span>.<span class="property">isAuthenticated</span> = <span class="literal">false</span></span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 授權檢查中介軟體</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requireAuth</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!res.<span class="property">locals</span>.<span class="property">isAuthenticated</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">401</span>).<span class="title function_">json</span>(&#123; <span class="attr">error</span>: <span class="string">&#x27;Authentication required&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">app.<span class="title function_">use</span>(authMiddleware)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/profile&#x27;</span>, requireAuth, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = res.<span class="property">locals</span></span><br><span class="line">  res.<span class="title function_">json</span>(&#123; user &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="與-req-自定義屬性的比較"><a href="#與-req-自定義屬性的比較" class="headerlink" title="與 req 自定義屬性的比較"></a>與 req 自定義屬性的比較</h3><p>雖然也可以使用 <code>req.user</code> 或 <code>req.data</code> 等自定義屬性，但 <code>res.locals</code> 有幾個優勢：</p><ol><li><strong>語意清晰</strong> - 明確表示這是給視圖用的資料</li><li><strong>自動傳遞</strong> - 模板引擎會自動取用 <code>res.locals</code> 的資料</li><li><strong>標準化</strong> - 社群共識，維護性更好</li></ol><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p><code>res.locals</code> 在認證系統中的使用確實是標準實作：</p><ol><li><strong>官方支持</strong> - Express.js 和 Auth.js 官方文檔都展示這種用法</li><li><strong>生態系統標準</strong> - Passport.js 等主流函式庫採用相同模式</li><li><strong>效能考量</strong> - 避免重複解析 JWT 或查詢資料庫</li><li><strong>開發體驗</strong> - 控制器可以直接存取用戶資訊</li></ol><p>所以下次有人說使用 <code>res.locals</code> 不是好實作時，可以拿出這些官方文檔來證明這確實是被廣泛接受的標準做法。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://expressjs.com/en/guide/using-middleware.html">Express.js Using middleware</a></li><li><a href="https://authjs.dev/reference/express">Auth.js Express Integration</a></li><li><a href="https://www.passportjs.org/concepts/authentication/middleware/">Passport.js Middleware Documentation</a></li><li><a href="https://expressjs.com/en/api.html#res.locals">Express.js res.locals API Reference</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Express.js 認證系統中，常見的做法是在每個需要驗證的路由中直接解析 JWT token。&lt;br&gt;但有一個更好的實作方式：使用中</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>[踩雷筆記] GitHub Action ssh-keyscan not found 問題修復</title>
    <link href="https://blog.marsen.me/2025/07/22/2025/ithub-action-ssh-keyscan-not-found-fix/"/>
    <id>https://blog.marsen.me/2025/07/22/2025/ithub-action-ssh-keyscan-not-found-fix/</id>
    <published>2025-07-22T05:42:30.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>GitHub Action <code>marsen/hexo-action@v1.0.11</code> 之前運行正常，但最近開始失敗，錯誤訊息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/app/entrypoint.sh: 9: /usr/app/entrypoint.sh: ssh-keyscan: not found</span><br></pre></td></tr></table></figure><h2 id="問題分析"><a href="#問題分析" class="headerlink" title="問題分析"></a>問題分析</h2><h3 id="初步檢查"><a href="#初步檢查" class="headerlink" title="初步檢查"></a>初步檢查</h3><p>檢查 entrypoint.sh 第9行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keyscan -t rsa github.com &gt;&gt; /root/.ssh/known_hosts</span><br></pre></td></tr></table></figure><p>檢查 Dockerfile 套件安裝：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-buster-slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y git openssh-client</span></span><br></pre></td></tr></table></figure><p>明明有安裝 <code>openssh-client</code>，為什麼找不到 <code>ssh-keyscan</code>？</p><h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p><strong>Debian Buster 生命週期結束</strong></p><ul><li><code>node:20-buster-slim</code> 基於 Debian 10 (Buster)</li><li>Debian 10 於 2024年8月達到 End of Life</li><li>套件庫不再維護，套件結構可能變化</li></ul><p><strong>OpenSSH 套件重組</strong></p><ul><li>2024年 OpenSSH 多個版本發布 (9.7, 9.9)</li><li><code>ssh-keyscan</code> 可能從 <code>openssh-client</code> 移到其他套件</li></ul><p><strong>Docker 映像自動更新</strong></p><ul><li>Docker Hub 會自動重建映像</li><li>新版本移除不必要工具以減少攻擊面</li></ul><h2 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h2><h3 id="快速修復（不推薦）"><a href="#快速修復（不推薦）" class="headerlink" title="快速修復（不推薦）"></a>快速修復（不推薦）</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y git openssh-client openssh-server</span></span><br></pre></td></tr></table></figure><p>雖然可行，但安裝 SSH 伺服器會增加攻擊面。</p><h3 id="正確解法"><a href="#正確解法" class="headerlink" title="正確解法"></a>正確解法</h3><p>升級基底映像到支援版本：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 從過期版本</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-buster-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升級到安全版本  </span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-bookworm-slim</span><br></pre></td></tr></table></figure><p>完整的 Dockerfile 修改：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-bookworm-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0.12&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> repository=<span class="string">&quot;https://github.com/marsen/hexo-action&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> homepage=<span class="string">&quot;https://blog.marsen.me&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;marsen.lin &lt;admin@marsen.me&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> entrypoint.sh /usr/app/entrypoint.sh</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> sync_deploy_history.js /usr/app/sync_deploy_history.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安全且最佳化的套件安裝</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &gt; /dev/null &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y git openssh-client &gt; /dev/null &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/* &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> +x /usr/app/entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/app/entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="關鍵改進"><a href="#關鍵改進" class="headerlink" title="關鍵改進"></a>關鍵改進</h2><ol><li><p><strong>基底映像升級</strong>：buster-slim → bookworm-slim</p><ul><li>Debian 12 取代已 EOL 的 Debian 10</li><li>更好的安全性和長期支援</li></ul></li><li><p><strong>最小權限原則</strong>：只安裝 openssh-client</p><ul><li>包含所需的 ssh-keyscan 工具</li><li>不安裝 SSH 伺服器，減少攻擊面</li></ul></li><li><p><strong>Docker 最佳實踐</strong>：</p><ul><li>清理 apt 快取減少映像大小</li><li>使用 &amp;&amp; 合併 RUN 指令減少層數</li></ul></li></ol><h2 id="預防措施"><a href="#預防措施" class="headerlink" title="預防措施"></a>預防措施</h2><ul><li>使用具體版本標籤而非 latest</li><li>定期檢查基底映像的生命週期</li><li>建立自動化測試驗證依賴可用性</li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這次問題的核心是基底映像過期導致的連鎖反應。在容器化開發中，外部依賴的變化往往會影響既有系統。解決方案不是快速修復，而是從根本上升級到安全的長期支援版本。</p><p>除錯關鍵思路：分析「為什麼之前可以，現在不行」，往往能找到外部環境變化的線索。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;GitHub Action &lt;code&gt;marsen/hexo-action@v1.0.11&lt;/code&gt; 之前運行正常，但</summary>
      
    
    
    
    
    <category term="踩雷筆記" scheme="https://blog.marsen.me/tags/%E8%B8%A9%E9%9B%B7%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] Ollama 容器化調研筆記</title>
    <link href="https://blog.marsen.me/2025/06/22/2025/ai-ollama-containerized/"/>
    <id>https://blog.marsen.me/2025/06/22/2025/ai-ollama-containerized/</id>
    <published>2025-06-22T15:36:35.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近在搞 AI 模型的本地部署，並試著將 Ollama 容器化。<br>經過一段時間的調研和實測，想記錄一下目前的進度和對幾個主流方案的看法。</p><h3 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h3><ul><li>找到穩定的 Ollama 容器化方案</li><li>評估各種新興工具的可用性</li><li>為未來的產品開發做技術預研</li></ul><h3 id="Ollama-簡介"><a href="#Ollama-簡介" class="headerlink" title="Ollama 簡介"></a>Ollama 簡介</h3><p>Ollama 是一個開源工具，讓你在本地電腦上輕鬆運行大型語言模型（如 Llama、CodeLlama、Mistral 等）。<br>安裝簡單，一行指令就能下載和運行各種 AI 模型，無需複雜設定。支援 macOS、Linux 和 Windows。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  安裝後直接用</span></span><br><span class="line">ollama run llama3.2</span><br></pre></td></tr></table></figure><p>類似 Docker 的概念，但專門為 AI 模型設計。<br>還提供 REST API：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 啟動後自動開啟 API server (預設 port 11434)</span></span><br><span class="line">curl http://localhost:11434/api/generate \</span><br><span class="line">  -d <span class="string">&#x27;&#123;&quot;model&quot;: &quot;llama3.2&quot;, &quot;prompt&quot;: &quot;Hello&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>沒有 Ollama 的話，你需要：</p><ul><li>手動下載模型檔案（通常好幾 GB）</li><li>處理不同模型格式（GGUF、GGML 等）</li><li>設定 GPU 加速環境</li><li>寫代碼載入模型到記憶體</li><li>處理 tokenization 和 inference</li><li>自己包 API server</li></ul><p>Ollama 把這些都幫你搞定了。</p><h2 id="選擇"><a href="#選擇" class="headerlink" title="選擇"></a>選擇</h2><h3 id="目前採用：Ollama-Container-指令初始化"><a href="#目前採用：Ollama-Container-指令初始化" class="headerlink" title="目前採用：Ollama Container + 指令初始化"></a>目前採用：Ollama Container + 指令初始化</h3><p>經過評估，選擇 ollama container 方案最穩定且彈性也最高，</p><p>只要需要透過指令的方法來就可以來取模型。</p><p>基本用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 啟動 ollama container</span></span><br><span class="line">docker run -d --name ollama -p 11434:11434 ollama/ollama</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下載模型</span></span><br><span class="line">docker <span class="built_in">exec</span> -it ollama ollama pull llama3.2</span><br></pre></td></tr></table></figure><h3 id="Docker-Model-Runner：值得關注但暫不採用"><a href="#Docker-Model-Runner：值得關注但暫不採用" class="headerlink" title="Docker Model Runner：值得關注但暫不採用"></a>Docker Model Runner：值得關注但暫不採用</h3><p>DMR 在 2025 年 3月隨 Docker Desktop 4.40 推出 Beta 版，</p><p>看起來很有潛力，但目前不打算用在產品上。</p><p>主因如下</p><ul><li>平台支援階段性：最初只支援 Apple Silicon (M1-M4)，5月的 Docker Desktop 4.41 才加入 Windows NVIDIA GPU 支援</li><li>實驗階段：工具變化快速，預期會持續改進，對產品開發風險較高</li><li>Linux 支援：目前在 Linux (包含 WSL2) 上支援 Docker CE，但整體生態還在發展中</li></ul><p>會持續觀察，最新的 Docker Desktop 4.42 甚至支援了 Windows Qualcomm 晶片，發展很快。</p><h3 id="Podman-AI-Lab：概念不錯但有使用限制"><a href="#Podman-AI-Lab：概念不錯但有使用限制" class="headerlink" title="Podman AI Lab：概念不錯但有使用限制"></a>Podman AI Lab：概念不錯但有使用限制</h3><p>Podman AI Lab 提供一份精選的開源 AI 模型清單，概念上跟 DMR 類似，但實際使用上有些考量。</p><p>現況 支援 GGUF、PyTorch、TensorFlow 等常見格式</p><p>提供精選的 recipe 目錄，幫助導航 AI 使用案例和模型</p><p>最近與 RamaLama 整合，簡化本地 AI 模型執行</p><p>但採用精選模型清單的策略，可能不包含所有想要的模型</p><p>相對於 Ollama 的廣泛模型支援，選擇較為有限</p><p>不過隨著 RamaLama 能從任何來源簡化 AI 模型的本地服務，未來可能會更靈活。</p><h2 id="一些要注意的小問題"><a href="#一些要注意的小問題" class="headerlink" title="一些要注意的小問題"></a>一些要注意的小問題</h2><h3 id="Ollama-Container-常見坑"><a href="#Ollama-Container-常見坑" class="headerlink" title="Ollama Container 常見坑"></a>Ollama Container 常見坑</h3><ol><li><strong>GPU 支援</strong>：記得加 <code>--gpus all</code> 或用 docker-compose 設定</li><li><strong>模型路徑</strong>：預設在 <code>/root/.ollama</code>，要持久化記得 mount volume</li><li><strong>網路設定</strong>：如果在 k8s 環境，注意 service 的 port 設定</li></ol><h3 id="Docker-Model-Runner-評估心得"><a href="#Docker-Model-Runner-評估心得" class="headerlink" title="Docker Model Runner 評估心得"></a>Docker Model Runner 評估心得</h3><ul><li>目前主要在 macOS Apple Silicon 上比較穩定</li><li>Linux 支援還在完善中</li><li>Windows 支援是最近才加的，需要更多實測</li></ul><h2 id="技術選型思考"><a href="#技術選型思考" class="headerlink" title="技術選型思考"></a>技術選型思考</h2><p>這次調研讓我想到幾個點：</p><ol><li><strong>穩定性 &gt; 新功能</strong>：對產品開發來說，穩定性永遠是第一考量</li><li><strong>生態完整性</strong>：單一工具再好，生態不完善就是硬傷</li><li><strong>維護成本</strong>：新技術通常需要更多維護工作</li></ol><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>短期計畫：</p><ol><li>把 Ollama container 的初始化流程自動化</li><li>持續追蹤 DMR 發展</li><li>建立技術方案評估標準</li></ol><p>中期目標：</p><ul><li>等 DMR 穩定後再評估導入</li><li>研究其他容器化方案</li><li>整理最佳實踐文件</li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>AI 基礎設施變化很快，容器化技術也在演進。目前沒有完美方案，但這個調研過程很有價值。</p><p>技術選擇是動態平衡的過程，要在穩定性、功能性、維護成本間找平衡點。</p><p>會持續關注這領域的發展，有新發現再分享。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近在搞 AI 模型的本地部署，並試著將 Ollama 容器化。&lt;br&gt;經過一段時間的調研和實測，想記錄一下目前的進度和對幾</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title> [生活筆記] 2025 常用工具整理 - AI 篇</title>
    <link href="https://blog.marsen.me/2025/06/20/2025/ai-tools/"/>
    <id>https://blog.marsen.me/2025/06/20/2025/ai-tools/</id>
    <published>2025-06-20T11:35:51.000Z</published>
    <updated>2025-11-18T02:49:50.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近 AI 工具如雨後春筍般冒出，整理一些目前在用或值得關注的工具，主要分為對話、開發、專業應用三大類。</p><h2 id="對話與通用-AI"><a href="#對話與通用-AI" class="headerlink" title="對話與通用 AI"></a>對話與通用 AI</h2><h3 id="Claude"><a href="#Claude" class="headerlink" title="Claude"></a>Claude</h3><ul><li><a href="https://claude.ai/chat/"><strong>Claude Chat</strong></a></li><li>Anthropic 開發的 AI 助手，擅長寫作、分析、程式開發</li><li>支援多模態輸入（文字、圖片、文件）</li><li>免費版有使用限制，付費版更穩定</li></ul><h3 id="Grok"><a href="#Grok" class="headerlink" title="Grok"></a>Grok</h3><ul><li><a href="https://grok.com/"><strong>Grok</strong></a></li><li>xAI 推出的對話式 AI</li><li>風格比較直接犀利，會吐槽（特色）</li><li>需要 X Premium 會員才能使用</li></ul><h3 id="Gemini-Google"><a href="#Gemini-Google" class="headerlink" title="Gemini (Google)"></a>Gemini (Google)</h3><ul><li><a href="https://gemini.google.com/"><strong>Gemini</strong></a></li><li>Google 最新多模態 AI 助手，支援文字、圖片、程式碼等多種輸入</li><li>已整合進 Google Workspace、Android、Chrome 等生態系</li></ul><h3 id="Microsoft-Copilot"><a href="#Microsoft-Copilot" class="headerlink" title="Microsoft Copilot"></a>Microsoft Copilot</h3><ul><li><a href="https://copilot.microsoft.com/"><strong>Copilot</strong></a></li><li>微軟全家桶 AI 助手，整合於 Windows 11、Edge、Office 365</li><li>支援 Word、Excel、PowerPoint 直接 AI 協作</li></ul><h3 id="Perplexity-AI"><a href="#Perplexity-AI" class="headerlink" title="Perplexity AI"></a>Perplexity AI</h3><ul><li><a href="https://www.perplexity.ai/"><strong>Perplexity</strong></a></li><li>強調即時網路搜尋與問答，支援多語言、引用來源</li><li>適合知識查詢、研究輔助</li></ul><h3 id="Notion-AI"><a href="#Notion-AI" class="headerlink" title="Notion AI"></a>Notion AI</h3><ul><li><a href="https://www.notion.so/product/ai"><strong>Notion AI</strong></a></li><li>整合於 Notion 筆記&#x2F;知識管理平台的 AI 助手</li><li>支援自動摘要、重寫、腦力激盪等功能</li></ul><h3 id="ChatGPT-OpenAI"><a href="#ChatGPT-OpenAI" class="headerlink" title="ChatGPT (OpenAI)"></a>ChatGPT (OpenAI)</h3><ul><li><a href="https://chat.openai.com/"><strong>ChatGPT</strong></a></li><li>OpenAI 的對話式 AI，支援 GPT-4&#x2F;4o，應用於對話、程式、資料分析等</li><li>免費&#x2F;付費版皆有</li></ul><h3 id="Kimi-Chat（Moonshot-AI）"><a href="#Kimi-Chat（Moonshot-AI）" class="headerlink" title="Kimi Chat（Moonshot AI）"></a>Kimi Chat（Moonshot AI）</h3><ul><li><a href="https://kimi.moonshot.cn/"><strong>Kimi Chat</strong></a></li><li>中文社群討論度高，支援長文閱讀、PDF 分析</li></ul><h3 id="Phind"><a href="#Phind" class="headerlink" title="Phind"></a>Phind</h3><ul><li><a href="https://www.phind.com/"><strong>Phind</strong></a></li><li>專為工程師設計的 AI 搜尋與問答平台，程式碼解釋、技術文件查找很強</li></ul><hr><h2 id="程式開發工具"><a href="#程式開發工具" class="headerlink" title="程式開發工具"></a>程式開發工具</h2><h3 id="程式碼生成與協助"><a href="#程式碼生成與協助" class="headerlink" title="程式碼生成與協助"></a>程式碼生成與協助</h3><ul><li><p><a href="https://openai.com/index/introducing-codex/"><strong>OpenAI Codex</strong></a></p><ul><li>雲端軟體工程代理，可同時處理多項開發任務</li><li>支援功能開發、bug 修復、重構等</li></ul></li><li><p><a href="https://docs.github.com/en/copilot"><strong>GitHub Copilot</strong></a></p><ul><li>直接在編輯器中提供程式碼建議</li><li>可生成整行或整個函數</li><li>需付費訂閱</li></ul></li><li><p><a href="https://www.cursor.com/cn/features"><strong>Cursor</strong></a></p><ul><li>AI 程式碼編輯器</li><li>專注於智能程式開發體驗</li><li>支援自然語言與程式碼互動</li></ul></li><li><p><a href="https://www.anthropic.com/claude-code"><strong>Claude Code</strong></a></p><ul><li>官方文件：<a href="https://docs.anthropic.com/zh-TW/docs/claude-code/overview">https://docs.anthropic.com/zh-TW/docs/claude-code/overview</a></li><li>產品頁面：</li><li>Anthropic 的命令列工具</li><li>讓開發者直接從終端委託程式開發任務給 Claude</li><li>目前還在研究預覽階段</li></ul></li><li><p><a href="https://augmentcode.com/"><strong>AugmentCode</strong></a></p><ul><li>AI 驅動的程式碼搜尋與理解平台</li><li>支援跨專案、跨語言的程式碼查詢、摘要與自動解釋</li><li>適合大型專案維護、協作與知識傳承</li></ul></li></ul><h3 id="應用開發"><a href="#應用開發" class="headerlink" title="應用開發"></a>應用開發</h3><ul><li><p><a href="https://studio.firebase.google.com/"><strong>Firebase Studio</strong></a></p><ul><li>Google 的應用開發平台</li><li>整合多種後端服務</li></ul></li><li><p><a href="https://deepwiki.com/"><strong>DeepWiki</strong></a></p><ul><li>AI 驅動的知識搜尋與摘要工具</li><li>支援多語言、快速整理主題重點，適合研究、學習、資料彙整</li><li>可用於技術、學術、產業等多種領域</li></ul></li></ul><h2 id="雜七雜八"><a href="#雜七雜八" class="headerlink" title="雜七雜八"></a>雜七雜八</h2><h3 id="法律專業-—-Harvey-AI"><a href="#法律專業-—-Harvey-AI" class="headerlink" title="法律專業 — Harvey AI"></a>法律專業 — <a href="https://www.harvey.ai/security"><strong>Harvey AI</strong></a></h3><ul><li>專門為法律行業設計的 AI 助手</li><li>強調安全性和合規性（重要）</li></ul><h3 id="文件研究-—-NotebookLM"><a href="#文件研究-—-NotebookLM" class="headerlink" title="文件研究 — NotebookLM"></a>文件研究 — <a href="https://notebooklm.google.com/"><strong>NotebookLM</strong></a></h3><ul><li>Google 的筆記和研究工具</li><li>可以分析和總結文件</li><li>支援多種文件格式上傳</li></ul><h3 id="NVIDIA-Container-Toolkit"><a href="#NVIDIA-Container-Toolkit" class="headerlink" title="NVIDIA Container Toolkit"></a><a href="https://github.com/NVIDIA/nvidia-container-toolkit"><strong>NVIDIA Container Toolkit</strong></a></h3><ul><li>NVIDIA 的容器化工具包</li><li>主要用於 GPU 加速的容器應用</li></ul><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://claude.ai/chat/">https://claude.ai/chat/</a></li><li><a href="https://openai.com/index/introducing-codex/">https://openai.com/index/introducing-codex/</a></li><li><a href="https://hackmd.io/@fL8pq60EQsG3RplVzWfGWA/SkNhLpNGe">https://hackmd.io/@fL8pq60EQsG3RplVzWfGWA/SkNhLpNGe</a></li><li><a href="https://docs.github.com/en/copilot">https://docs.github.com/en/copilot</a></li><li><a href="https://grok.com/">https://grok.com/</a></li><li><a href="https://github.com/NVIDIA/nvidia-container-toolkit?tab=security-ov-file">https://github.com/NVIDIA/nvidia-container-toolkit?tab=security-ov-file</a></li><li><a href="https://docs.anthropic.com/zh-TW/docs/claude-code/overview">https://docs.anthropic.com/zh-TW/docs/claude-code/overview</a></li><li><a href="https://www.harvey.ai/security">https://www.harvey.ai/security</a></li><li><a href="https://www.cursor.com/cn/features">https://www.cursor.com/cn/features</a></li><li><a href="https://studio.firebase.google.com/">https://studio.firebase.google.com/</a></li><li><a href="https://notebooklm.google.com/">https://notebooklm.google.com/</a></li><li><a href="https://www.anthropic.com/claude-code">https://www.anthropic.com/claude-code</a></li><li><a href="https://gemini.google.com/">https://gemini.google.com/</a></li><li><a href="https://copilot.microsoft.com/">https://copilot.microsoft.com/</a></li><li><a href="https://www.perplexity.ai/">https://www.perplexity.ai/</a></li><li><a href="https://www.notion.so/product/ai">https://www.notion.so/product/ai</a></li><li><a href="https://chat.openai.com/">https://chat.openai.com/</a></li><li><a href="https://kimi.moonshot.cn/">https://kimi.moonshot.cn/</a></li><li><a href="https://www.phind.com/">https://www.phind.com/</a></li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>目前 AI 工具生態系統發展迅速，各家都在搶佔不同的應用場景。<br>對話類工具已經相當成熟，程式開發輔助工具也越來越實用，專業領域的 AI 應用則剛起步但潛力巨大。<br>對我個人而言重建自已的工作流程整合 AI 協助已經刻不容緩</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近 AI 工具如雨後春筍般冒出，整理一些目前在用或值得關注的工具，主要分為對話、開發、專業應用三大類。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="生活筆記" scheme="https://blog.marsen.me/tags/%E7%94%9F%E6%B4%BB%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] 用 GitLab CI/CD 實現自動打 Tag、Build 與 Push Docker Image 到 Registry</title>
    <link href="https://blog.marsen.me/2025/06/05/2025/gitlab-cicd-to-registry/"/>
    <id>https://blog.marsen.me/2025/06/05/2025/gitlab-cicd-to-registry/</id>
    <published>2025-06-05T11:11:43.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在專案自動化部署流程中，讓 CI&#x2F;CD pipeline 自動產生遞增 tag、build Docker image 並推送到 GitLab Container Registry，是現代 DevOps 的常見需求。</p><p>這篇文章記錄我在 GitLab CI&#x2F;CD 上實作這一流程的經驗。</p><h3 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h3><ul><li><strong>自動產生遞增 tag</strong>（如 ver.1.0.1）</li><li><strong>自動 build 並 push Docker image</strong>，image tag 與 git tag 同步</li><li><strong>支援多專案共用同一份 CI 設定</strong></li><li><strong>僅 main 分支觸發</strong></li></ul><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><ol><li><p>變數抽象化，支援多專案共用</p><p> 首先，將專案名稱、群組路徑等資訊抽成變數，方便不同專案複用：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">PROJECT_NAME:</span> <span class="string">my-proj</span></span><br><span class="line">  <span class="attr">GROUP_PATH:</span> <span class="string">my-group</span></span><br><span class="line">  <span class="attr">REGISTRY_PATH:</span> <span class="string">registry.gitlab.com/$GROUP_PATH/$PROJECT_NAME</span></span><br></pre></td></tr></table></figure></li><li><p>多階段 Dockerfile 精簡 image</p><p> 使用 multi-stage build，確保 production image 只包含必要檔案與 production dependencies：</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">23</span>-alpine AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">23</span>-alpine AS production</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install --production</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/dist ./dist</span></span><br><span class="line"><span class="keyword">ENV</span> NODE_ENV=production</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span></span><br></pre></td></tr></table></figure><p> 建議搭配 .dockerignore 避免多餘檔案進入 image。</p></li><li><p>GitLab CI&#x2F;CD Pipeline 設定只在 main 分支執行</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">&#x27;$CI_COMMIT_BRANCH == &quot;main&quot;&#x27;</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">always</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">when:</span> <span class="string">never</span></span><br></pre></td></tr></table></figure></li><li><p>自動產生遞增 tag</p><ol><li>採用 major.minor.patch 的版本規則，啟始版號為 ver.1.0.0</li><li>先同步 remote tag，避免本地殘留影響</li><li>取得最大 patch 號，自動 +1</li><li>檢查 tag 是否已存在，確保唯一</li></ol> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">fetch</span> <span class="string">--prune</span> <span class="string">--tags</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">tag</span> <span class="string">-l</span> <span class="string">|</span> <span class="string">xargs</span> <span class="string">-n</span> <span class="number">1</span> <span class="string">git</span> <span class="string">tag</span> <span class="string">-d</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">fetch</span> <span class="string">--tags</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">    prefix=&quot;ver.&quot;</span></span><br><span class="line"><span class="string">    max_patch=$(git tag -l &quot;$&#123;prefix&#125;[0-9]*.[0-9]*.[0-9]*&quot; | grep -oE &#x27;[0-9]+\.[0-9]+\.[0-9]+&#x27; | sort -t. -k1,1nr -k2,2nr -k3,3nr | head -n1 | awk -F. &#x27;&#123;print $3&#125;&#x27;)</span></span><br><span class="line"><span class="string">    if [ -z &quot;$max_patch&quot; ]; then</span></span><br><span class="line"><span class="string">      new_tag=&quot;$&#123;prefix&#125;1.0.0&quot;</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">      major=$(git tag -l &quot;$&#123;prefix&#125;[0-9]*.[0-9]*.[0-9]*&quot; | grep -oE &#x27;[0-9]+\.[0-9]+\.[0-9]+&#x27; | sort -t. -k1,1nr -k2,2nr -k3,3nr | head -n1 | cut -d. -f1)</span></span><br><span class="line"><span class="string">      minor=$(git tag -l &quot;$&#123;prefix&#125;[0-9]*.[0-9]*.[0-9]*&quot; | grep -oE &#x27;[0-9]+\.[0-9]+\.[0-9]+&#x27; | sort -t. -k1,1nr -k2,2nr -k3,3nr | head -n1 | cut -d. -f2)</span></span><br><span class="line"><span class="string">      patch=$((max_patch + 1))</span></span><br><span class="line"><span class="string">      new_tag=&quot;$&#123;prefix&#125;$&#123;major&#125;.$&#123;minor&#125;.$&#123;patch&#125;&quot;</span></span><br><span class="line"><span class="string">    fi</span></span><br><span class="line"><span class="string">    # 確保 tag 唯一</span></span><br><span class="line"><span class="string">    while git rev-parse &quot;$new_tag&quot; &gt;/dev/null 2&gt;&amp;1; do</span></span><br><span class="line"><span class="string">      patch=$((patch + 1))</span></span><br><span class="line"><span class="string">      new_tag=&quot;$&#123;prefix&#125;$&#123;major&#125;.$&#123;minor&#125;.$&#123;patch&#125;&quot;</span></span><br><span class="line"><span class="string">    done</span></span><br><span class="line"><span class="string">    echo &quot;new tag is $new_tag&quot;</span></span><br><span class="line"><span class="string">    echo &quot;NEW_TAG=$new_tag&quot; &gt;&gt; build.env</span></span><br><span class="line"><span class="string"></span>  <span class="bullet">-</span> <span class="string">source</span> <span class="string">build.env</span></span><br></pre></td></tr></table></figure></li><li><p>自動打 tag 並 push</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;rd@example.com&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;gitlab-runner&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">remote</span> <span class="string">set-url</span> <span class="string">origin</span> <span class="string">https://gitlab-runner:$RAG_CICD_TOKEN@gitlab.com/$GITLAB_REPO.git</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">tag</span> <span class="string">&quot;$NEW_TAG&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">&quot;$NEW_TAG&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Loging、Build &amp; Push Docker image</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">docker</span> <span class="string">login</span> <span class="string">-u</span> <span class="string">&quot;$CI_REGISTRY_USER&quot;</span> <span class="string">-p</span> <span class="string">&quot;$CI_REGISTRY_PASSWORD&quot;</span> <span class="string">$CI_REGISTRY</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">$REGISTRY_PATH:$NEW_TAG</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">$REGISTRY_PATH:$NEW_TAG</span></span><br></pre></td></tr></table></figure></li><li><p>Docker-in-Docker 設定</p><p> <code>DOCKER_TLS_CERTDIR=&#39;&#39;</code> 是為了讓 dind 關閉 TLS，讓 CI job 可以直接用明文 TCP 連線 docker daemon，避免 TLS 憑證錯誤。</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker:dind</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">DOCKER_HOST:</span> <span class="string">tcp://docker:2375/</span></span><br><span class="line">  <span class="attr">DOCKER_TLS_CERTDIR:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p> <a href="https://about.gitlab.com/blog/docker-in-docker-with-docker-19-dot-03/">可以參考本文</a></p></li><li><p>一些要注意的小問題</p></li></ol><ul><li><p><strong>DOCKER_TLS_CERTDIR 不能不設定。</strong></p></li><li><p><strong>tag 跳號或重複？</strong><br>請務必先刪除本地 tag 再 fetch remote tag。</p></li><li><p><strong>無法 push tag？</strong><br>請確認 Deploy Token&#x2F;PAT 權限，且 remote url 正確。</p></li><li><p><strong>docker build 失敗，daemon 連不到？</strong><br>請檢查　gitlab runner 是否有 privileged mode，且 dind 有啟動。<br>在<code>/etc/gitlab-runner/config.toml</code>中</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[runners]]</span></span><br><span class="line">  <span class="attr">name</span> = <span class="string">&quot;docker-runner&quot;</span></span><br><span class="line">  <span class="attr">executor</span> = <span class="string">&quot;docker&quot;</span></span><br><span class="line">  <span class="section">[runners.docker]</span></span><br><span class="line">    <span class="attr">privileged</span> = <span class="literal">true</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>完整 .gitlab-ci.yml 範例如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">PROJECT_NAME:</span> <span class="string">my-proj</span></span><br><span class="line">  <span class="attr">GROUP_PATH:</span> <span class="string">my-group</span></span><br><span class="line">  <span class="attr">REGISTRY_PATH:</span> <span class="string">registry.gitlab.com/$GROUP_PATH/$PROJECT_NAME</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build-image:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">docker:latest</span></span><br><span class="line">  <span class="attr">services:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker:dind</span></span><br><span class="line">  <span class="attr">variables:</span></span><br><span class="line">    <span class="attr">DOCKER_HOST:</span> <span class="string">tcp://docker:2375/</span></span><br><span class="line">    <span class="attr">DOCKER_TLS_CERTDIR:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">&#x27;$CI_COMMIT_BRANCH == &quot;main&quot;&#x27;</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">always</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">when:</span> <span class="string">never</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">fetch</span> <span class="string">--prune</span> <span class="string">--tags</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">tag</span> <span class="string">-l</span> <span class="string">|</span> <span class="string">xargs</span> <span class="string">-n</span> <span class="number">1</span> <span class="string">git</span> <span class="string">tag</span> <span class="string">-d</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">fetch</span> <span class="string">--tags</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">      prefix=&quot;ver.&quot;</span></span><br><span class="line"><span class="string">      max_patch=$(git tag -l &quot;$&#123;prefix&#125;[0-9]*.[0-9]*.[0-9]*&quot; | grep -oE &#x27;[0-9]+\.[0-9]+\.[0-9]+&#x27; | sort -t. -k1,1nr -k2,2nr -k3,3nr | head -n1 | awk -F. &#x27;&#123;print $3&#125;&#x27;)</span></span><br><span class="line"><span class="string">      if [ -z &quot;$max_patch&quot; ]; then</span></span><br><span class="line"><span class="string">        new_tag=&quot;$&#123;prefix&#125;1.0.0&quot;</span></span><br><span class="line"><span class="string">      else</span></span><br><span class="line"><span class="string">        major=$(git tag -l &quot;$&#123;prefix&#125;[0-9]*.[0-9]*.[0-9]*&quot; | grep -oE &#x27;[0-9]+\.[0-9]+\.[0-9]+&#x27; | sort -t. -k1,1nr -k2,2nr -k3,3nr | head -n1 | cut -d. -f1)</span></span><br><span class="line"><span class="string">        minor=$(git tag -l &quot;$&#123;prefix&#125;[0-9]*.[0-9]*.[0-9]*&quot; | grep -oE &#x27;[0-9]+\.[0-9]+\.[0-9]+&#x27; | sort -t. -k1,1nr -k2,2nr -k3,3nr | head -n1 | cut -d. -f2)</span></span><br><span class="line"><span class="string">        patch=$((max_patch + 1))</span></span><br><span class="line"><span class="string">        new_tag=&quot;$&#123;prefix&#125;$&#123;major&#125;.$&#123;minor&#125;.$&#123;patch&#125;&quot;</span></span><br><span class="line"><span class="string">      fi</span></span><br><span class="line"><span class="string">      while git rev-parse &quot;$new_tag&quot; &gt;/dev/null 2&gt;&amp;1; do</span></span><br><span class="line"><span class="string">        patch=$((patch + 1))</span></span><br><span class="line"><span class="string">        new_tag=&quot;$&#123;prefix&#125;$&#123;major&#125;.$&#123;minor&#125;.$&#123;patch&#125;&quot;</span></span><br><span class="line"><span class="string">      done</span></span><br><span class="line"><span class="string">      echo &quot;new tag is $new_tag&quot;</span></span><br><span class="line"><span class="string">      echo &quot;NEW_TAG=$new_tag&quot; &gt;&gt; build.env</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="string">source</span> <span class="string">build.env</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;rd@example.com&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;rag-cicd&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">remote</span> <span class="string">set-url</span> <span class="string">origin</span> <span class="string">https://rag-cicd:$RAG_CICD_TOKEN@gitlab.com/$GITLAB_REPO.git</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">tag</span> <span class="string">&quot;$NEW_TAG&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">&quot;$NEW_TAG&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">login</span> <span class="string">-u</span> <span class="string">&quot;$CI_REGISTRY_USER&quot;</span> <span class="string">-p</span> <span class="string">&quot;$CI_REGISTRY_PASSWORD&quot;</span> <span class="string">$CI_REGISTRY</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">$REGISTRY_PATH:$NEW_TAG</span> <span class="string">.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">$REGISTRY_PATH:$NEW_TAG</span></span><br></pre></td></tr></table></figure><p>這樣設定後，每次 main 分支有 commit，CI&#x2F;CD 就會自動產生新 tag、build 並推送對應版本的 Docker image 讓大家共用。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在專案自動化部署流程中，讓 CI&amp;#x2F;CD pipeline 自動產生遞增 tag、build Docker imag</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] GCP Cloud Run 私有化部署：透過 Load Balancer 實現內網存取與 IP 限制</title>
    <link href="https://blog.marsen.me/2025/06/04/2025/gcp-internal-lb-serivce/"/>
    <id>https://blog.marsen.me/2025/06/04/2025/gcp-internal-lb-serivce/</id>
    <published>2025-06-04T03:42:01.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>我用 cloud run 建立一個 api 並且有 webhook 的功能<br>並且希望提供一個對外網址給客戶，而不是 <code>*.run.app</code> 結尾的網址。  </p><p>在某些場景下，我們不希望 GCP Cloud Run 對外暴露，</p><p>例如內部 API Gateway 呼叫、CI&#x2F;CD 系統內部流程、或僅提供給 VPC 內特定服務存取的微服務。</p><p>這次的例子是希望加上 IP 的防護，只允許特定的 IP 呼叫，這時候就會希望：</p><ul><li><p>Cloud Run 不對外公開（Private）</p></li><li><p>僅允許 內網 IP 或 Internal Load Balancer 存取</p></li></ul><p>看似簡單，但 GCP Cloud Run 原生是無伺服器架構，預設就是「公開網址」，要讓它只對內部可見，需要搭配一些 GCP 網路元件操作。這篇筆記會帶你逐步設定，並避開一些常見坑洞。</p><h2 id="實作記錄"><a href="#實作記錄" class="headerlink" title="實作記錄"></a>實作記錄</h2><ol><li><p>將 Cloud Run 設為「不公開」<br> 預設 Cloud Run 是公開的，要改為「只有授權的主體可以存取」：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcloud run services update YOUR_SERVICE \</span><br><span class="line">  --ingress internal-and-cloud-load-balancing \</span><br><span class="line">  --allow-unauthenticated \</span><br><span class="line">  --region YOUR_REGION \</span><br><span class="line">  --project YOUR_PROJECT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 這樣只有內部的網路才能呼叫 Cloud Run。</p><p> 也可以透過 GUI 設定，選擇你的 Cloud Run &gt;  </p><p> Networking &gt; Ingress 選 internal 勾選 Allow Traffic from external Application Load Balancers</p><p> 可以<a href="https://cloud.google.com/run/docs/securing/ingress#gcloud">參考</a></p></li><li><p>建立 Serverless NEG（Network Endpoint Group）<br>可以用 GUI 建立 Loading Blancer &gt;  </p><p>Edit &gt; Backend configuration &gt;  </p><p>下拉選單選 Create backend service &gt;  </p><p>Backend Type 選 Serverless network endpoint group  </p><p><em>因為是 Cloud Run</em></p></li><li><p>設定 Loading Blancer 的 Backend Service”<br>LB &gt; Edit backend service</p><p>Regions 選擇 Cloud Run 所在的 Region</p><p>預設會有一組 Security Policy</p><p>Cloud Armor policies &gt; 找到這組 Policy 可以作更細緻的設定，Ex:指定 Ip 呼叫</p></li><li><p>Loading Blancer URL Map<br>這是一個額外的設定，情境是原本我已有一組 Domain 與 Backend Service  </p><p>並且已經設定在 LB 上面，在想要共用 Domain 的情況下，我需要設定 URL Map</p><p>保留一組 Path 讓流量打向 Cloud Run，但仍保留其他 API 可以用</p><p>LB &gt; Edit &gt; Routing rules &gt; Mode 選擇 Advanced host and path rule  </p><p>找到指定的 Domain，設定參考如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">defaultService:</span> <span class="string">projects/my-gcp-proj/global/backendServices/my-api</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">path-matcher-7</span></span><br><span class="line"><span class="attr">pathRules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">paths:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/api/v1/*</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">projects/my-gcp-proj/global/backendServices/my-api</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">paths:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/cloud-run-app/*</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">projects/my-gcp-proj/global/backendServices/my-cloud-run-app</span></span><br><span class="line">    <span class="attr">routeAction:</span></span><br><span class="line">      <span class="attr">urlRewrite:</span></span><br><span class="line">        <span class="attr">pathPrefixRewrite:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p> 以上設定簡單說明如下，</p><ul><li>&#x2F;api&#x2F;v1&#x2F;*：導向 my-api，保留原始路徑。</li><li>&#x2F;cloud-run-app&#x2F;*：導向 my-cloud-run-app，並將路徑重寫為去除 &#x2F;cloud-run-app 前綴。</li><li>其他路徑：預設導向 my-api。</li></ul><p> 這樣設定可讓多個服務共用同一個負載平衡器並支援乾淨的 URL 管理。</p></li></ol><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://webhook.site/">好用測試 Callback 的工具</a></li><li><a href="https://cloud.google.com/run/docs/securing/ingress#gcloud">Restrict network ingress for Cloud Run</a></li></ul><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;我用 cloud run 建立一個 api 並且有 webhook 的功能&lt;br&gt;並且希望提供一個對外網址給客戶，而不是 &lt;</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [實作筆記] 我的 Vim 設定</title>
    <link href="https://blog.marsen.me/2025/05/24/2025/vim_setting/"/>
    <id>https://blog.marsen.me/2025/05/24/2025/vim_setting/</id>
    <published>2025-05-24T05:06:05.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<p>我的 Vim 快捷鍵設定總表，<strong>IdeaVim 與 JetBrain</strong>：</p><hr><table><thead><tr><th>快捷鍵</th><th>模式</th><th>功能說明</th><th>IdeaVim 設定寫法</th></tr></thead><tbody><tr><td>zcc</td><td>n</td><td>清除所有自訂映射</td><td><code>nmap zcc :mapclear!&lt;CR&gt;</code></td></tr><tr><td>zso</td><td>n</td><td>重新載入主 vimrc</td><td><code>nmap zso :source ~/_ideavimrc&lt;CR&gt;</code></td></tr><tr><td>zf</td><td>n&#x2F;i</td><td>跳到定義（Goto Declaration）</td><td><code>nmap zf :action GotoDeclaration&lt;CR&gt;</code><br><code>imap zf &lt;Esc&gt;:action GotoDeclaration&lt;CR&gt;</code></td></tr><tr><td>zrc, zo</td><td>n&#x2F;i</td><td>格式化程式碼（Reformat Code）</td><td><code>nmap zrc :action ReformatCode&lt;CR&gt;</code><br><code>imap zrc &lt;Esc&gt;:action ReformatCode&lt;CR&gt;</code><br><code>nmap zo :action ReformatCode&lt;CR&gt;</code></td></tr><tr><td>zk</td><td>n&#x2F;i</td><td>返回（Back）</td><td><code>nmap zk :action Back&lt;CR&gt;</code><br><code>imap zk &lt;Esc&gt;:action Back&lt;CR&gt;</code></td></tr><tr><td>zj</td><td>n&#x2F;i</td><td>AceAction（自訂動作）</td><td><code>nmap zj :action AceAction&lt;CR&gt;</code><br><code>imap zj &lt;Esc&gt;:action AceAction&lt;CR&gt;</code></td></tr><tr><td>ztt</td><td>n&#x2F;i</td><td>複製區塊並格式化（自訂巨集）</td><td><code>nmap ztt y?[F&lt;CR&gt;/{&lt;CR&gt;%o&lt;Esc&gt;p:action ReformatCode&lt;CR&gt;</code><br><code>imap ztt &lt;Esc&gt;y?[F&lt;CR&gt;/{&lt;CR&gt;%o&lt;Esc&gt;p:action ReformatCode&lt;CR&gt;</code></td></tr><tr><td>zn</td><td>n&#x2F;i</td><td>跳到上一個錯誤（Goto Previous Error）</td><td><code>nmap zn :action GotoPreviousError&lt;CR&gt;</code><br><code>imap zn &lt;Esc&gt;:action GotoPreviousError&lt;CR&gt;</code></td></tr><tr><td>zrr</td><td>n&#x2F;i</td><td>重新命名（Rename Element）</td><td><code>nmap zrr :action RenameElement&lt;CR&gt;</code><br><code>imap zrr &lt;Esc&gt;:action RenameElement&lt;CR&gt;</code></td></tr><tr><td>zra</td><td>n&#x2F;i</td><td>執行所有單元測試</td><td><code>nmap zra :action RiderUnitTestRunSolutionAction&lt;CR&gt;</code><br><code>imap zra &lt;Esc&gt;:action RiderUnitTestRunSolutionAction&lt;CR&gt;</code></td></tr><tr><td>zrm</td><td>n&#x2F;v</td><td>萃取方法（Extract Method）</td><td><code>nmap zrm :action ExtractMethod&lt;CR&gt;</code><br><code>vmap zrm :action ExtractMethod&lt;CR&gt;</code></td></tr><tr><td>zri</td><td>n</td><td>Inline（內聯變數&#x2F;方法）</td><td><code>map zri :action Inline&lt;CR&gt;&lt;Esc&gt;</code></td></tr><tr><td>zrp</td><td>n</td><td>Introduce Parameter（引入參數）</td><td><code>map zrp :action IntroduceParameter&lt;CR&gt;</code></td></tr><tr><td>zrv</td><td>n</td><td>Introduce Variable（引入變數）</td><td><code>map zrv :action IntroduceVariable&lt;CR&gt;</code></td></tr><tr><td>zrf</td><td>n</td><td>Introduce Field（引入欄位）</td><td><code>map zrf :action IntroduceField&lt;CR&gt;</code></td></tr><tr><td>,m</td><td>n</td><td>顯示檔案結構</td><td><code>nmap ,m :action FileStructurePopup&lt;CR&gt;</code></td></tr><tr><td>zrt</td><td>n</td><td>最近檔案</td><td><code>nmap zrt :action RecentFiles&lt;CR&gt;</code></td></tr><tr><td>zgc</td><td>n</td><td>開啟 Commit 工具視窗</td><td><code>nmap zgc :action ActivateCommitToolWindow&lt;CR&gt;</code></td></tr><tr><td>zx</td><td>n</td><td>快速重構選單</td><td><code>nmap zx :action Refactorings.QuickListPopupAction &lt;CR&gt;</code></td></tr><tr><td>zae</td><td>n&#x2F;i</td><td>插入 Assert.Equal(,);</td><td><code>nmap zae aAssert.Equal(,);&lt;Esc&gt;T(i</code><br><code>imap zae Assert.Equal(,);&lt;Esc&gt;T(i</code></td></tr><tr><td>zrs</td><td>n</td><td>新增 class 並格式化（自訂巨集）</td><td><code>nmap zrs &quot;add? class&lt;CR&gt;2w&quot;bywjopublic &lt;Esc&gt;&quot;bpa()&lt;CR&gt;{&lt;Esc&gt;&quot;apo}&lt;Esc&gt;:action ReformatCode&lt;CR&gt;</code></td></tr><tr><td>z;</td><td>n&#x2F;i</td><td>行尾加分號</td><td><code>nmap z; $a;&lt;Esc&gt;</code><br><code>imap z; &lt;Esc&gt;$a;</code></td></tr><tr><td>,p, ,P</td><td>n</td><td>黏貼暫存區 0 的內容</td><td><code>nmap ,p &quot;0p</code><br><code>nmap ,P &quot;0P</code></td></tr><tr><td>z,p, z,P</td><td>i</td><td>插入暫存區 0 的內容</td><td><code>imap z,p &lt;Esc&gt;&quot;0pa</code><br><code>imap z,P &lt;Esc&gt;&quot;0Pa</code></td></tr><tr><td>z,</td><td>n</td><td>選取括號內內容（vi)）</td><td><code>:nmap z, vi)</code></td></tr><tr><td>z.</td><td>n</td><td>選取大括號內內容（vi}）</td><td><code>:nmap z. vi}</code></td></tr><tr><td><Esc></td><td>v</td><td>連續多次離開選取模式</td><td><code>:vmap &lt;Esc&gt; &lt;Esc&gt;&lt;Esc&gt;&lt;Esc&gt;</code></td></tr><tr><td>jj</td><td>i</td><td>退出插入模式</td><td><code>:imap jj &lt;Esc&gt;</code></td></tr><tr><td><BS></td><td>n</td><td>在普通模式下插入 Backspace</td><td><code>:nmap &lt;BS&gt; a&lt;BS&gt;</code></td></tr><tr><td>zh</td><td>n&#x2F;i</td><td>跳到行首</td><td><code>:nmap zh ^</code><br><code>:imap zh &lt;Esc&gt;^i</code></td></tr><tr><td>zl</td><td>n&#x2F;i</td><td>跳到行尾</td><td><code>:nmap zl $</code><br><code>:imap zl &lt;End&gt;</code></td></tr><tr><td>hc</td><td>n</td><td>Ctrl+C</td><td><code>:nmap hc ^C</code></td></tr><tr><td>zb</td><td>n&#x2F;v</td><td>單字取代</td><td><code>:nmap zb bcw</code><br><code>:vmap zb &lt;Esc&gt;bcw</code></td></tr><tr><td>zd</td><td>i</td><td>刪除當前行</td><td><code>:imap zd &lt;Esc&gt;dd</code></td></tr><tr><td>j, k</td><td>n</td><td>軟換行移動</td><td><code>nmap j gj</code><br><code>nmap k gk</code></td></tr><tr><td>qq</td><td>n</td><td>強制關閉檔案</td><td><code>nmap qq ZQ</code></td></tr><tr><td>zq</td><td>n</td><td>儲存並關閉檔案</td><td><code>nmap zq :wq&lt;CR&gt;</code></td></tr><tr><td><C-x></td><td>i</td><td>刪除當前行</td><td><code>:imap &lt;C-x&gt; &lt;Esc&gt;dd</code></td></tr><tr><td><C-a></td><td>i</td><td>全選</td><td><code>:imap &lt;C-a&gt; &lt;Esc&gt;ma&lt;CR&gt;ggVG</code></td></tr><tr><td>,i, ,a</td><td>n</td><td>替換字元</td><td><code>:map ,i &lt;Esc&gt;r</code><br><code>:map ,a &lt;Esc&gt;r</code></td></tr></tbody></table><hr><p><strong>說明：</strong>  </p><ul><li>n：普通模式（normal mode）  </li><li>i：插入模式（insert mode）  </li><li>v：視覺模式（visual mode）  </li><li><code>&lt;CR&gt;</code> 代表 Enter 鍵，<code>&lt;Esc&gt;</code> 代表 Esc 鍵</li></ul><hr><p>以下是我將 JetBrains（IdeaVim）Vim 快捷鍵移植到 VSCode（VSCodeVim）的對應表，<br>並說明哪些已成功移植、哪些無法移植及原因：</p><hr><table><thead><tr><th>JetBrains 快捷鍵</th><th>VSCode 設定 (before)</th><th>VSCode 指令 (commands)</th><th>功能說明</th><th>可否移植</th><th>備註&#x2F;原因</th></tr></thead><tbody><tr><td>zrr</td><td>[“z”,”r”,”r”]</td><td>editor.action.rename</td><td>重新命名</td><td>✅</td><td>完全支援</td></tr><tr><td>zf</td><td>[“z”,”f”]</td><td>editor.action.revealDefinition</td><td>跳到定義</td><td>✅</td><td>完全支援</td></tr><tr><td>zrc&#x2F;zo</td><td>[“z”,”r”,”c”]&#x2F;[“z”,”o”]</td><td>editor.action.formatDocument</td><td>格式化程式碼</td><td>✅</td><td>完全支援（你已設 zrc，zo 也可加）</td></tr><tr><td>zn</td><td>[“z”,”n”]</td><td>editor.action.marker.prev</td><td>跳到上一個錯誤</td><td>✅</td><td>完全支援</td></tr><tr><td>zrt</td><td>[“z”,”r”,”t”]</td><td>workbench.action.openRecent</td><td>最近檔案</td><td>✅</td><td>完全支援</td></tr><tr><td>,m</td><td>[“,”,”m”]</td><td>workbench.action.gotoSymbol</td><td>檔案結構&#x2F;大綱</td><td>✅</td><td>完全支援</td></tr><tr><td>zx</td><td>[“z”,”x”]</td><td>editor.action.refactor</td><td>顯示重構選單</td><td>✅</td><td>完全支援</td></tr><tr><td>zgc</td><td>[“z”,”g”,”c”]</td><td>workbench.view.scm</td><td>開啟 Source Control 面板</td><td>✅</td><td>完全支援</td></tr><tr><td>zh</td><td>[“z”,”h”]</td><td>cursorHome</td><td>跳到行首</td><td>✅</td><td>完全支援</td></tr><tr><td>zl</td><td>[“z”,”l”]</td><td>cursorEnd</td><td>跳到行尾</td><td>✅</td><td>完全支援</td></tr><tr><td>zrv</td><td>[“z”,”r”,”v”]</td><td>editor.action.codeAction.extract.variable</td><td>萃取變數</td><td>⚠️</td><td>VSCodeVim 有選取限制，部分情境下無法觸發</td></tr><tr><td>zrm</td><td>[“z”,”r”,”m”]</td><td>editor.action.codeAction.extract.method</td><td>萃取方法</td><td>⚠️</td><td>VSCodeVim 有選取限制，部分情境下無法觸發</td></tr><tr><td>zri</td><td>-</td><td>-</td><td>Inline（內聯變數&#x2F;方法）</td><td>❌</td><td>VSCode 沒有公開指令 ID，無法 keybinding</td></tr><tr><td>zrp</td><td>-</td><td>-</td><td>Introduce Parameter</td><td>❌</td><td>VSCode 沒有公開指令 ID，無法 keybinding</td></tr><tr><td>zrf</td><td>-</td><td>-</td><td>Introduce Field</td><td>❌</td><td>VSCode 沒有公開指令 ID，無法 keybinding</td></tr><tr><td>ztt</td><td>-</td><td>-</td><td>巨集&#x2F;多步驟自動化</td><td>❌</td><td>VSCode 不支援 Vim 巨集或多步驟自動化</td></tr><tr><td>zso</td><td>-</td><td>-</td><td>重新載入 vimrc</td><td>❌</td><td>VSCodeVim 不支援 :source 或重新載入 vimrc</td></tr><tr><td>zra</td><td>[“z”,”r”,”a”]</td><td>testing.runAll</td><td>執行所有單元測試</td><td>✅</td><td>需安裝 VSCode 官方 Testing 功能，已可 keybinding</td></tr></tbody></table><hr><h3 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h3><ul><li>✅：完全支援，已可用於 VSCodeVim。</li><li>⚠️：VSCodeVim 有技術限制（如需選取內容，觸發不一定成功）。</li><li>❌：VSCode&#x2F;VSCodeVim 無對應指令或功能，無法移植。</li><li>你可以持續用 VSCode 內建的 <code>Cmd+.</code> 或右鍵選單補足無法 keybinding 的重構功能。</li><li><strong>zra</strong>：VSCode 1.59 以上內建 Testing 功能，指令為 <code>testing.runAll</code>，可直接 keybinding，無需額外外掛。</li></ul><hr><p><strong>總結：</strong><br>我已成功將大部分常用 JetBrains Vim 快捷鍵移植到 VSCode，<br>僅少數 JetBrains 專屬重構、巨集、vimrc 相關功能因 VSCode 限制無法移植。  </p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的 Vim 快捷鍵設定總表，&lt;strong&gt;IdeaVim 與 JetBrain&lt;/strong&gt;：&lt;/p&gt;
&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷鍵&lt;/th&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;功能說明&lt;/th&gt;
&lt;th&gt;IdeaVim 設定寫法</summary>
      
    
    
    
    
    <category term="實作筆記" scheme="https://blog.marsen.me/tags/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title> [學習筆記] TypeScript 不同寫法的除錯難易比較</title>
    <link href="https://blog.marsen.me/2025/05/17/2025/typescript_error_handle_ways/"/>
    <id>https://blog.marsen.me/2025/05/17/2025/typescript_error_handle_ways/</id>
    <published>2025-05-17T05:23:41.000Z</published>
    <updated>2025-11-18T02:49:50.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近在整理一個專案的 API 路由權限設定，<br>對同樣的資料結構、不同的寫法，對於型別檢查和除錯有一點小小心得，稍微作個記錄。</p><h2 id="情境說明"><a href="#情境說明" class="headerlink" title="情境說明"></a>情境說明</h2><p>假設我有一個 API 權限設定如下，每個路由對應一組角色才能訪問：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">endpoint</span>: <span class="string">&quot;/admin&quot;</span>,</span><br><span class="line">  <span class="attr">roles</span>: [<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;superuser&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後我有一個函式 registerPermissions 要吃這個設定。</p><h3 id="建議寫法"><a href="#建議寫法" class="headerlink" title="建議寫法"></a>建議寫法</h3><p>先給最近建議的寫法，先定義型別，然後變數也套型別<br>好處是能具體的抓到錯誤，壞處是要多考慮一個型別(命名、擺放位置都會是一個要考量的點)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PermissionConfig</span> = &#123;</span><br><span class="line">  <span class="attr">routes</span>: &#123;</span><br><span class="line">    <span class="attr">endpoint</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">roles</span>: <span class="built_in">string</span>[];</span><br><span class="line">  &#125;[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">permissionConfig</span>: <span class="title class_">PermissionConfig</span> = &#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">endpoint</span>: <span class="string">&quot;/admin&quot;</span>,</span><br><span class="line">      <span class="attr">roles</span>: [<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;superuser&quot;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">endpoint</span>: <span class="string">&quot;/profile&quot;</span>,</span><br><span class="line">      <span class="attr">roles</span>: <span class="string">&quot;user&quot;</span>, <span class="comment">// ❌ 馬上紅字報錯</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">registerPermissions</span> = (<span class="params">config: PermissionConfig</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 註冊權限邏輯</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">registerPermissions</span>(permissionConfig);</span><br></pre></td></tr></table></figure><h3 id="先定義變數，但沒套型別"><a href="#先定義變數，但沒套型別" class="headerlink" title="先定義變數，但沒套型別"></a>先定義變數，但沒套型別</h3><p>這是最不推薦的寫法。雖然寫起來最快、最順手，不用考慮命名和檔案擺放的位置，但錯誤訊息會一大坨，難以閱讀。</p><p>在現在這個 AI 時代，也許 AI 能幫你更快理解錯誤，但我還是不建議這麼做。因為一旦習慣這種寫法，很容易錯上加錯。單一錯誤 AI 還能理解，但錯中錯時，AI 也可能會搞不清楚狀況。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permissionConfig = &#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">endpoint</span>: <span class="string">&quot;/admin&quot;</span>,</span><br><span class="line">      <span class="attr">roles</span>: [<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;superuser&quot;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">endpoint</span>: <span class="string">&quot;/profile&quot;</span>,</span><br><span class="line">      <span class="attr">roles</span>: <span class="string">&quot;user&quot;</span>, <span class="comment">// 🧨 這裡故意寫錯，應該是 array</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">registerPermissions</span> = (<span class="params">config: &#123;</span></span><br><span class="line"><span class="params">  routes: &#123;</span></span><br><span class="line"><span class="params">    endpoint: <span class="built_in">string</span>;</span></span><br><span class="line"><span class="params">    roles: <span class="built_in">string</span>[];</span></span><br><span class="line"><span class="params">  &#125;[];</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 註冊權限邏輯</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">registerPermissions</span>(permissionConfig);</span><br></pre></td></tr></table></figure><p>這種寫法會噴出一堆錯誤。</p><h3 id="寫法三：直接-inline-傳入函式"><a href="#寫法三：直接-inline-傳入函式" class="headerlink" title="寫法三：直接 inline 傳入函式"></a>寫法三：直接 inline 傳入函式</h3><p>如果沒有共用必要的參數，我通常會推薦 inline 寫法。當然前提是這個方法的複雜度要夠低，讓人容易理解。這樣也可以省去命名和型別檔案擺放位置的煩惱。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">registerPermissions</span> = (<span class="params">config: &#123;</span></span><br><span class="line"><span class="params">  routes: &#123;</span></span><br><span class="line"><span class="params">    endpoint: <span class="built_in">string</span>;</span></span><br><span class="line"><span class="params">    roles: <span class="built_in">string</span>[];</span></span><br><span class="line"><span class="params">  &#125;[];</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 註冊權限邏輯</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">registerPermissions</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">endpoint</span>: <span class="string">&quot;/admin&quot;</span>,</span><br><span class="line">      <span class="attr">roles</span>: [<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;superuser&quot;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">endpoint</span>: <span class="string">&quot;/profile&quot;</span>,</span><br><span class="line">      <span class="attr">roles</span>: <span class="string">&quot;user&quot;</span>, <span class="comment">// ❌ 馬上紅字報錯</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="小結：推薦寫法"><a href="#小結：推薦寫法" class="headerlink" title="小結：推薦寫法"></a>小結：推薦寫法</h2><p>最推薦第一種，但實務上我可能會更多的選擇第三種寫法。<br>要有上下文，請團隊作好自已的判斷。</p><p>(fin)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;最近在整理一個專案的 API 路由權限設定，&lt;br&gt;對同樣的資料結構、不同的寫法，對於型別檢查和除錯有一點小小心得，稍微作個</summary>
      
    
    
    
    
    <category term="學習筆記" scheme="https://blog.marsen.me/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
</feed>
